<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <include name="libxml2" version="2.0"/>
  <package name="camel-1.2"/>
  <c:include name="camel/camel.h"/>
  <namespace name="Camel"
             version="1.2"
             shared-library="libcamel-1.2.so.60"
             c:identifier-prefixes="Camel,camel"
             c:symbol-prefixes="camel,camel">
    <alias name="_block_t" c:type="camel_block_t">
      <type name="guint32" c:type="guint32"/>
    </alias>
    <alias name="_hash_t" c:type="camel_hash_t">
      <type name="guint32" c:type="guint32"/>
    </alias>
    <alias name="_key_t" c:type="camel_key_t">
      <type name="guint32" c:type="guint32"/>
    </alias>
    <constant name="AI_CANONNAME" value="2" c:type="AI_CANONNAME">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AI_NUMERICHOST" value="4" c:type="AI_NUMERICHOST">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Address"
           c:symbol-prefix="address"
           c:type="CamelAddress"
           parent="GObject.Object"
           glib:type-name="CamelAddress"
           glib:get-type="camel_address_get_type"
           glib:type-struct="AddressClass">
      <constructor name="new" c:identifier="camel_address_new">
        <doc xml:space="preserve">Create a new #CamelAddress object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelAddress object</doc>
          <type name="Address" c:type="CamelAddress*"/>
        </return-value>
      </constructor>
      <virtual-method name="cat" invoker="cat">
        <doc xml:space="preserve">Concatenate one address onto another. The addresses must
be of the same type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses concatenated</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">destination #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">source #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decode" invoker="decode">
        <doc xml:space="preserve">Construct a new address from a raw address field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses parsed or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="raw" transfer-ownership="none">
            <doc xml:space="preserve">raw address description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="encode" invoker="encode">
        <doc xml:space="preserve">Encode an address in a format suitable for a raw header.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded address</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="format" invoker="format">
        <doc xml:space="preserve">Format an address in a format suitable for display.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the formatted addresses</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="length" invoker="length">
        <doc xml:space="preserve">Get the number of addresses stored in the address @addr.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses contained in @addr</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove" invoker="remove">
        <doc xml:space="preserve">Remove an address by index, or all addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The address to remove, use %-1 to remove all address.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unformat" invoker="unformat">
        <doc xml:space="preserve">Attempt to convert a previously formatted and/or edited
address back into internal form.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses parsed or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="raw" transfer-ownership="none">
            <doc xml:space="preserve">raw address description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="cat" c:identifier="camel_address_cat">
        <doc xml:space="preserve">Concatenate one address onto another. The addresses must
be of the same type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses concatenated</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">destination #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">source #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="camel_address_copy">
        <doc xml:space="preserve">Copy the contents of one address into another.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses copied</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">destination #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">source #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode" c:identifier="camel_address_decode">
        <doc xml:space="preserve">Construct a new address from a raw address field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses parsed or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="raw" transfer-ownership="none">
            <doc xml:space="preserve">raw address description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encode" c:identifier="camel_address_encode">
        <doc xml:space="preserve">Encode an address in a format suitable for a raw header.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded address</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="format" c:identifier="camel_address_format">
        <doc xml:space="preserve">Format an address in a format suitable for display.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the formatted addresses</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="length" c:identifier="camel_address_length">
        <doc xml:space="preserve">Get the number of addresses stored in the address @addr.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses contained in @addr</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_clone" c:identifier="camel_address_new_clone">
        <doc xml:space="preserve">Clone an existing address type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the cloned address</doc>
          <type name="Address" c:type="CamelAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="camel_address_remove">
        <doc xml:space="preserve">Remove an address by index, or all addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">The address to remove, use %-1 to remove all address.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unformat" c:identifier="camel_address_unformat">
        <doc xml:space="preserve">Attempt to convert a previously formatted and/or edited
address back into internal form.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of addresses parsed or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress object</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </instance-parameter>
          <parameter name="raw" transfer-ownership="none">
            <doc xml:space="preserve">raw address description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="AddressPrivate" c:type="CamelAddressPrivate*"/>
      </field>
    </class>
    <record name="AddressClass"
            c:type="CamelAddressClass"
            glib:is-gtype-struct-for="Address">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="length">
        <callback name="length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of addresses contained in @addr</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="addr" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decode">
        <callback name="decode">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of addresses parsed or %-1 on fail</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="addr" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
            <parameter name="raw" transfer-ownership="none">
              <doc xml:space="preserve">raw address description</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="encode">
        <callback name="encode">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the encoded address</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="addr" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unformat">
        <callback name="unformat">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of addresses parsed or %-1 on fail</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="addr" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
            <parameter name="raw" transfer-ownership="none">
              <doc xml:space="preserve">raw address description</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="format">
        <callback name="format">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly allocated string containing the formatted addresses</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="addr" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cat">
        <callback name="cat">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of addresses concatenated</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="dest" transfer-ownership="none">
              <doc xml:space="preserve">destination #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">source #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove">
        <callback name="remove">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="addr" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress object</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <doc xml:space="preserve">The address to remove, use %-1 to remove all address.</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AddressPrivate" c:type="CamelAddressPrivate" disguised="1">
    </record>
    <record name="AsyncClosure"
            c:type="CamelAsyncClosure"
            disguised="1"
            version="3.12">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <method name="free"
              c:identifier="camel_async_closure_free"
              version="3.12"
              introspectable="0">
        <doc xml:space="preserve">Frees the @closure and the resources it holds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAsyncClosure</doc>
            <type name="AsyncClosure" c:type="CamelAsyncClosure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="wait"
              c:identifier="camel_async_closure_wait"
              version="3.12"
              introspectable="0">
        <doc xml:space="preserve">Call this function immediately after starting an asynchronous operation.
The function waits for the asynchronous operation to complete and returns
its #GAsyncResult to be passed to the operation's "finish" function.

This function can be called repeatedly on the same #CamelAsyncClosure to
easily string together multiple asynchronous operations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GAsyncResult which is owned by the closure</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAsyncClosure</doc>
            <type name="AsyncClosure" c:type="CamelAsyncClosure*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="callback"
                c:identifier="camel_async_closure_callback"
                version="3.12"
                introspectable="0">
        <doc xml:space="preserve">Pass this function as the #GAsyncReadyCallback argument of an asynchronous
function, and the #CamelAsyncClosure as the data argument.

This causes camel_async_closure_wait() to terminate and return @result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="source_object" transfer-ownership="none">
            <doc xml:space="preserve">a #GObject or %NULL</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="closure"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelAsyncClosure</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new"
                c:identifier="camel_async_closure_new"
                version="3.12"
                introspectable="0">
        <doc xml:space="preserve">Creates a new #CamelAsyncClosure for use with asynchronous functions.</doc>
        <return-value>
          <doc xml:space="preserve">a new #CamelAsyncClosure</doc>
          <type name="AsyncClosure" c:type="CamelAsyncClosure*"/>
        </return-value>
      </function>
    </record>
    <enumeration name="AuthenticationResult"
                 version="3.4"
                 glib:type-name="CamelAuthenticationResult"
                 glib:get-type="camel_authentication_result_get_type"
                 c:type="CamelAuthenticationResult">
      <doc xml:space="preserve">Authentication result codes used by #CamelService.</doc>
      <member name="error"
              value="0"
              c:identifier="CAMEL_AUTHENTICATION_ERROR"
              glib:nick="error">
        <doc xml:space="preserve">An error occurred while authenticating.</doc>
      </member>
      <member name="accepted"
              value="1"
              c:identifier="CAMEL_AUTHENTICATION_ACCEPTED"
              glib:nick="accepted">
        <doc xml:space="preserve">Server accepted our authentication attempt.</doc>
      </member>
      <member name="rejected"
              value="2"
              c:identifier="CAMEL_AUTHENTICATION_REJECTED"
              glib:nick="rejected">
        <doc xml:space="preserve">Server rejected our authentication attempt.</doc>
      </member>
    </enumeration>
    <constant name="BLOCK_SIZE" value="1024" c:type="CAMEL_BLOCK_SIZE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="BLOCK_SIZE_BITS" value="10" c:type="CAMEL_BLOCK_SIZE_BITS">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="BestencEncoding" c:type="CamelBestencEncoding">
      <member name="7bit" value="0" c:identifier="CAMEL_BESTENC_7BIT">
      </member>
      <member name="8bit" value="1" c:identifier="CAMEL_BESTENC_8BIT">
      </member>
      <member name="binary" value="2" c:identifier="CAMEL_BESTENC_BINARY">
      </member>
      <member name="text" value="256" c:identifier="CAMEL_BESTENC_TEXT">
      </member>
    </bitfield>
    <bitfield name="BestencRequired" c:type="CamelBestencRequired">
      <member name="get_encoding"
              value="1"
              c:identifier="CAMEL_BESTENC_GET_ENCODING">
      </member>
      <member name="get_charset"
              value="2"
              c:identifier="CAMEL_BESTENC_GET_CHARSET">
      </member>
      <member name="lf_is_crlf"
              value="256"
              c:identifier="CAMEL_BESTENC_LF_IS_CRLF">
      </member>
      <member name="no_from" value="512" c:identifier="CAMEL_BESTENC_NO_FROM">
      </member>
    </bitfield>
    <record name="Block" c:type="CamelBlock">
      <field name="id" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
      <field name="flags" writable="1">
        <type name="BlockFlags" c:type="CamelBlockFlags"/>
      </field>
      <field name="refcount" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="align00" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="data" writable="1">
        <array zero-terminated="0" c:type="guchar" fixed-size="1024">
          <type name="guint8" c:type="guchar"/>
        </array>
      </field>
    </record>
    <class name="BlockFile"
           c:symbol-prefix="block_file"
           c:type="CamelBlockFile"
           parent="GObject.Object"
           glib:type-name="CamelBlockFile"
           glib:get-type="camel_block_file_get_type"
           glib:type-struct="BlockFileClass">
      <constructor name="new" c:identifier="camel_block_file_new">
        <doc xml:space="preserve">Allocate a new block file, stored at @path.  @version contains an 8 character
version string which must match the head of the file, or the file will be
intitialised.

@block_size is currently ignored and is set to CAMEL_BLOCK_SIZE.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new block file, or NULL if it could not be created.</doc>
          <type name="BlockFile" c:type="CamelBlockFile*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a path with file name of the the new #CamelBlockFile</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">file open flags to use</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">a version string</doc>
            <type name="gchar" c:type="const gchar"/>
          </parameter>
          <parameter name="block_size" transfer-ownership="none">
            <doc xml:space="preserve">block size, currently ignored</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="init_root">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="validate_root">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="attach_block" c:identifier="camel_block_file_attach_block">
        <doc xml:space="preserve">Reattach a block that has been detached.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="bl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlock</doc>
            <type name="Block" c:type="CamelBlock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="camel_block_file_delete">
        <doc xml:space="preserve">Deletes existing block file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="detach_block" c:identifier="camel_block_file_detach_block">
        <doc xml:space="preserve">Detatch a block from the block file's cache.  The block should
be unref'd or attached when finished with.  The block file will
perform no writes of this block or flushing of it if the cache
fills.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="bl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlock</doc>
            <type name="Block" c:type="CamelBlock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_block" c:identifier="camel_block_file_free_block">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">a #camel_block_t</doc>
            <type name="_block_t" c:type="camel_block_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_block"
              c:identifier="camel_block_file_get_block"
              introspectable="0">
        <doc xml:space="preserve">Retreive a block @id.</doc>
        <return-value>
          <doc xml:space="preserve">The block, or NULL if blockid is invalid or a file error
occurred.</doc>
          <type name="Block" c:type="CamelBlock*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">a #camel_block_t</doc>
            <type name="_block_t" c:type="camel_block_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cache_limit"
              c:identifier="camel_block_file_get_cache_limit"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Current block cache limit of @bs.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root"
              c:identifier="camel_block_file_get_root"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #CamelBlockRoot of @bs.</doc>
          <type name="BlockRoot" c:type="CamelBlockRoot*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root_block"
              c:identifier="camel_block_file_get_root_block"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A root #CamelBlock of @bs.</doc>
          <type name="Block" c:type="CamelBlock*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_block"
              c:identifier="camel_block_file_new_block"
              introspectable="0">
        <doc xml:space="preserve">Allocate a new block, return a pointer to it.  Old blocks
may be flushed to disk during this call.</doc>
        <return-value>
          <doc xml:space="preserve">The block, or NULL if an error occurred.</doc>
          <type name="Block" c:type="CamelBlock*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rename" c:identifier="camel_block_file_rename">
        <doc xml:space="preserve">Renames existing block file to a new @path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error; errno is set on failure</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">path with filename to rename to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cache_limit"
              c:identifier="camel_block_file_set_cache_limit"
              version="3.24">
        <doc xml:space="preserve">Sets a new block cache limit for @bs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="block_cache_limit" transfer-ownership="none">
            <doc xml:space="preserve">a new block cache limit to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync" c:identifier="camel_block_file_sync">
        <doc xml:space="preserve">Sync all dirty blocks to disk, including the root block.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on io error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sync_block" c:identifier="camel_block_file_sync_block">
        <doc xml:space="preserve">Flush a block to disk immediately.  The block will only
be flushed to disk if it is marked as dirty (touched).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on io error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="bl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlock</doc>
            <type name="Block" c:type="CamelBlock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="touch_block" c:identifier="camel_block_file_touch_block">
        <doc xml:space="preserve">Mark a block as dirty.  The block will be written to disk if
it ever expires from the cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="bl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlock</doc>
            <type name="Block" c:type="CamelBlock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_block" c:identifier="camel_block_file_unref_block">
        <doc xml:space="preserve">Mark a block as unused.  If a block is used it will not be
written to disk, or flushed from memory.

If a block is detatched and this is the last reference, the
block will be freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bs" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlockFile</doc>
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </instance-parameter>
          <parameter name="bl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelBlock</doc>
            <type name="Block" c:type="CamelBlock*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="BlockFilePrivate" c:type="CamelBlockFilePrivate*"/>
      </field>
    </class>
    <record name="BlockFileClass"
            c:type="CamelBlockFileClass"
            glib:is-gtype-struct-for="BlockFile">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="validate_root">
        <callback name="validate_root">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="bs" transfer-ownership="none">
              <type name="BlockFile" c:type="CamelBlockFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="init_root">
        <callback name="init_root">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="bs" transfer-ownership="none">
              <type name="BlockFile" c:type="CamelBlockFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BlockFileFlags" c:type="CamelBlockFileFlags">
      <member name="block_file_sync"
              value="1"
              c:identifier="CAMEL_BLOCK_FILE_SYNC">
      </member>
    </bitfield>
    <record name="BlockFilePrivate"
            c:type="CamelBlockFilePrivate"
            disguised="1">
    </record>
    <bitfield name="BlockFlags" c:type="CamelBlockFlags">
      <member name="dirty" value="1" c:identifier="CAMEL_BLOCK_DIRTY">
      </member>
      <member name="detached" value="2" c:identifier="CAMEL_BLOCK_DETACHED">
      </member>
    </bitfield>
    <record name="BlockRoot" c:type="CamelBlockRoot">
      <field name="version" writable="1">
        <array zero-terminated="0" c:type="gchar" fixed-size="8">
          <type name="gchar" c:type="gchar"/>
        </array>
      </field>
      <field name="flags" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="block_size" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="free" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
      <field name="last" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
    </record>
    <constant name="CIPHER_CERT_INFO_PROPERTY_PHOTO_FILENAME"
              value="photo-filename"
              c:type="CAMEL_CIPHER_CERT_INFO_PROPERTY_PHOTO_FILENAME"
              version="3.22">
      <doc xml:space="preserve">Name of the photo-filename property which can be stored
on a #CamelCipherCertInfo.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="Cert"
            c:type="CamelCert"
            glib:type-name="CamelCert"
            glib:get-type="camel_cert_get_type"
            c:symbol-prefix="cert">
      <field name="refcount" writable="1">
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="issuer" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="subject" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="hostname" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="fingerprint" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="trust" writable="1">
        <type name="CertTrust" c:type="CamelCertTrust"/>
      </field>
      <field name="rawcert" writable="1">
        <type name="GLib.Bytes" c:type="GBytes*"/>
      </field>
      <constructor name="new" c:identifier="camel_cert_new">
        <return-value transfer-ownership="full">
          <type name="Cert" c:type="CamelCert*"/>
        </return-value>
      </constructor>
      <method name="load_cert_file"
              c:identifier="camel_cert_load_cert_file"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert" transfer-ownership="none">
            <type name="Cert" c:type="CamelCert*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="camel_cert_ref">
        <return-value transfer-ownership="full">
          <type name="Cert" c:type="CamelCert*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert" transfer-ownership="none">
            <type name="Cert" c:type="CamelCert*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save_cert_file"
              c:identifier="camel_cert_save_cert_file"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert" transfer-ownership="none">
            <type name="Cert" c:type="CamelCert*"/>
          </instance-parameter>
          <parameter name="der_data" transfer-ownership="none">
            <array name="GLib.ByteArray" c:type="const GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="camel_cert_unref">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cert" transfer-ownership="none">
            <type name="Cert" c:type="CamelCert*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="CertDB"
           c:symbol-prefix="certdb"
           c:type="CamelCertDB"
           parent="GObject.Object"
           glib:type-name="CamelCertDB"
           glib:get-type="camel_certdb_get_type"
           glib:type-struct="CertDBClass">
      <constructor name="new" c:identifier="camel_certdb_new">
        <return-value transfer-ownership="full">
          <type name="CertDB" c:type="CamelCertDB*"/>
        </return-value>
      </constructor>
      <function name="get_default" c:identifier="camel_certdb_get_default">
        <doc xml:space="preserve">FIXME Document me!</doc>
        <return-value transfer-ownership="full">
          <type name="CertDB" c:type="CamelCertDB*"/>
        </return-value>
      </function>
      <virtual-method name="cert_load">
        <return-value transfer-ownership="full">
          <type name="Cert" c:type="CamelCert*"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="istream"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="cert_save">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="cert" transfer-ownership="none">
            <type name="Cert" c:type="CamelCert*"/>
          </parameter>
          <parameter name="ostream"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="header_load">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="istream"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="header_save">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="ostream"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear" c:identifier="camel_certdb_clear">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_host"
              c:identifier="camel_certdb_get_host"
              version="3.6">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #CamelCert corresponding to the pair of @hostname
  and @fingerprint, or %NULL, if no such certificate is stored in the @certdb.</doc>
          <type name="Cert" c:type="CamelCert*"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCertDB</doc>
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">a host name of a certificate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fingerprint" transfer-ownership="none">
            <doc xml:space="preserve">a fingerprint of a certificate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_certs"
              c:identifier="camel_certdb_list_certs"
              version="3.16">
        <doc xml:space="preserve">Gathers a list of known certificates. Each certificate in the returned #GSList
is referenced, thus unref it with camel_cert_unref() when done with it, the same
as free the list itself.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Newly allocated list of
  referenced CamelCert-s, which are stored in the @certdb.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Cert"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCertDB</doc>
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load" c:identifier="camel_certdb_load">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="put" c:identifier="camel_certdb_put" version="3.6">
        <doc xml:space="preserve">Puts a certificate to the database. In case there exists a certificate
with the same hostname and fingerprint, then it is replaced. This adds
its own reference on the @cert.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCertDB</doc>
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="cert" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCert</doc>
            <type name="Cert" c:type="CamelCert*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_host"
              c:identifier="camel_certdb_remove_host"
              version="3.6">
        <doc xml:space="preserve">Removes a certificate identified by the @hostname and @fingerprint.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCertDB</doc>
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="hostname" transfer-ownership="none">
            <doc xml:space="preserve">a host name of a certificate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="fingerprint" transfer-ownership="none">
            <doc xml:space="preserve">a fingerprint of a certificate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="camel_certdb_save">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_default" c:identifier="camel_certdb_set_default">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_filename" c:identifier="camel_certdb_set_filename">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="touch" c:identifier="camel_certdb_touch">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="certdb" transfer-ownership="none">
            <type name="CertDB" c:type="CamelCertDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="CertDBPrivate" c:type="CamelCertDBPrivate*"/>
      </field>
    </class>
    <record name="CertDBClass"
            c:type="CamelCertDBClass"
            glib:is-gtype-struct-for="CertDB">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="header_load">
        <callback name="header_load">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="certdb" transfer-ownership="none">
              <type name="CertDB" c:type="CamelCertDB*"/>
            </parameter>
            <parameter name="istream"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_save">
        <callback name="header_save">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="certdb" transfer-ownership="none">
              <type name="CertDB" c:type="CamelCertDB*"/>
            </parameter>
            <parameter name="ostream"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cert_load">
        <callback name="cert_load">
          <return-value transfer-ownership="full">
            <type name="Cert" c:type="CamelCert*"/>
          </return-value>
          <parameters>
            <parameter name="certdb" transfer-ownership="none">
              <type name="CertDB" c:type="CamelCertDB*"/>
            </parameter>
            <parameter name="istream"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cert_save">
        <callback name="cert_save">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="certdb" transfer-ownership="none">
              <type name="CertDB" c:type="CamelCertDB*"/>
            </parameter>
            <parameter name="cert" transfer-ownership="none">
              <type name="Cert" c:type="CamelCert*"/>
            </parameter>
            <parameter name="ostream"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="CertDBPrivate" c:type="CamelCertDBPrivate" disguised="1">
    </record>
    <enumeration name="CertTrust" c:type="CamelCertTrust">
      <member name="unknown" value="0" c:identifier="CAMEL_CERT_TRUST_UNKNOWN">
      </member>
      <member name="never" value="1" c:identifier="CAMEL_CERT_TRUST_NEVER">
      </member>
      <member name="marginal"
              value="2"
              c:identifier="CAMEL_CERT_TRUST_MARGINAL">
      </member>
      <member name="fully" value="3" c:identifier="CAMEL_CERT_TRUST_FULLY">
      </member>
      <member name="ultimate"
              value="4"
              c:identifier="CAMEL_CERT_TRUST_ULTIMATE">
      </member>
      <member name="temporary"
              value="5"
              c:identifier="CAMEL_CERT_TRUST_TEMPORARY">
      </member>
    </enumeration>
    <record name="Charset" c:type="CamelCharset">
      <field name="mask" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="level" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="best_name" c:identifier="camel_charset_best_name">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="charset" transfer-ownership="none">
            <type name="Charset" c:type="CamelCharset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="camel_charset_init">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="c" transfer-ownership="none">
            <type name="Charset" c:type="CamelCharset*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="step" c:identifier="camel_charset_step">
        <doc xml:space="preserve">Processes more input text with the @cc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCharset</doc>
            <type name="Charset" c:type="CamelCharset*"/>
          </instance-parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">input text</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of the input text</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <function name="best" c:identifier="camel_charset_best">
        <doc xml:space="preserve">Finds the minimum charset for this string NULL means US-ASCII.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the minimum charset or NULL for US_ASCII.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">input text</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of the input text</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="iso_to_windows"
                c:identifier="camel_charset_iso_to_windows">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the equivalent Windows charset.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="isocharset" transfer-ownership="none">
            <doc xml:space="preserve">a canonicalised ISO charset</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="CipherCertInfo" c:type="CamelCipherCertInfo">
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="email" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cert_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="cert_data_free" writable="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="cert_data_clone" writable="1">
        <type name="CipherCloneFunc" c:type="CamelCipherCloneFunc"/>
      </field>
      <field name="properties" writable="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
    </record>
    <record name="CipherCertInfoProperty" c:type="CamelCipherCertInfoProperty">
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="value_free" writable="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="value_clone" writable="1">
        <type name="CipherCloneFunc" c:type="CamelCipherCloneFunc"/>
      </field>
    </record>
    <callback name="CipherCloneFunc" c:type="CamelCipherCloneFunc">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="CipherContext"
           c:symbol-prefix="cipher_context"
           c:type="CamelCipherContext"
           parent="GObject.Object"
           glib:type-name="CamelCipherContext"
           glib:get-type="camel_cipher_context_get_type"
           glib:type-struct="CipherContextClass">
      <constructor name="new" c:identifier="camel_cipher_context_new">
        <doc xml:space="preserve">This creates a new CamelCipherContext object which is used to sign,
verify, encrypt and decrypt streams.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new CamelCipherContext</doc>
          <type name="CipherContext" c:type="CamelCipherContext*"/>
        </return-value>
        <parameters>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="decrypt_sync"
                      invoker="decrypt_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Decrypts @ipart into @opart.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a validity/encryption status, or %NULL on error</doc>
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">clear-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="encrypt_sync"
                      invoker="encrypt_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Encrypts (and optionally signs) the clear-text @ipart and writes the
resulting cipher-text to @opart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="userid" transfer-ownership="none">
            <doc xml:space="preserve">key ID (or email address) to use when signing, or %NULL to not sign</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="recipients" transfer-ownership="none">
            <doc xml:space="preserve">an array of recipient key IDs and/or email addresses</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">clear-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="hash_to_id" invoker="hash_to_id">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="hash" transfer-ownership="none">
            <type name="CipherHash" c:type="CamelCipherHash"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="id_to_hash" invoker="id_to_hash">
        <return-value transfer-ownership="none">
          <type name="CipherHash" c:type="CamelCipherHash"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sign_sync"
                      invoker="sign_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Converts the (unsigned) part @ipart into a new self-contained MIME
part @opart.  This may be a multipart/signed part, or a simple part
for enveloped types.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="userid" transfer-ownership="none">
            <doc xml:space="preserve">a private key to use to sign the stream</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:space="preserve">preferred Message-Integrity-Check hash algorithm</doc>
            <type name="CipherHash" c:type="CamelCipherHash"/>
          </parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">input #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">output #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify_sync" invoker="verify_sync" throws="1">
        <doc xml:space="preserve">Verifies the signature.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelCipherValidity structure containing information
about the integrity of the input stream, or %NULL on failure to
execute at all</doc>
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelMimePart to verify</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="decrypt"
              c:identifier="camel_cipher_context_decrypt"
              version="3.0">
        <doc xml:space="preserve">Asynchronously decrypts @ipart into @opart.

When the operation is finished, @callback will be called.  You can
then call camel_cipher_context_decrypt_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">clear-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="decrypt_finish"
              c:identifier="camel_cipher_context_decrypt_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_cipher_context_decrypt().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a validity/encryption status, or %NULL on error</doc>
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decrypt_sync"
              c:identifier="camel_cipher_context_decrypt_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Decrypts @ipart into @opart.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a validity/encryption status, or %NULL on error</doc>
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">clear-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encrypt"
              c:identifier="camel_cipher_context_encrypt"
              version="3.0">
        <doc xml:space="preserve">Asynchronously encrypts (and optionally signs) the clear-text @ipart and
writes the resulting cipher-text to @opart.

When the operation is finished, @callback will be called.  You can
then call camel_cipher_context_encrypt_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="userid" transfer-ownership="none">
            <doc xml:space="preserve">key id (or email address) to use when signing, or %NULL to not sign</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="recipients" transfer-ownership="none">
            <doc xml:space="preserve">an array of recipient key IDs and/or email addresses</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">clear-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="7">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="encrypt_finish"
              c:identifier="camel_cipher_context_encrypt_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_cipher_context_encrypt().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encrypt_sync"
              c:identifier="camel_cipher_context_encrypt_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Encrypts (and optionally signs) the clear-text @ipart and writes the
resulting cipher-text to @opart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="userid" transfer-ownership="none">
            <doc xml:space="preserve">key ID (or email address) to use when signing, or %NULL to not sign</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="recipients" transfer-ownership="none">
            <doc xml:space="preserve">an array of recipient key IDs and/or email addresses</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">clear-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session"
              c:identifier="camel_cipher_context_get_session"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="Session" c:type="CamelSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash_to_id" c:identifier="camel_cipher_context_hash_to_id">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="hash" transfer-ownership="none">
            <type name="CipherHash" c:type="CamelCipherHash"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_to_hash" c:identifier="camel_cipher_context_id_to_hash">
        <return-value transfer-ownership="none">
          <type name="CipherHash" c:type="CamelCipherHash"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sign"
              c:identifier="camel_cipher_context_sign"
              version="3.0">
        <doc xml:space="preserve">Asynchronously converts the (unsigned) part @ipart into a new
self-contained MIME part @opart.  This may be a multipart/signed part,
or a simple part for enveloped types.

When the operation is finished, @callback will be called.  You can then
call camel_cipher_context_sign_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="userid" transfer-ownership="none">
            <doc xml:space="preserve">a private key to use to sign the stream</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:space="preserve">preferred Message-Integrity-Check hash algorithm</doc>
            <type name="CipherHash" c:type="CamelCipherHash"/>
          </parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">input #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">output #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="7">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sign_finish"
              c:identifier="camel_cipher_context_sign_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_cipher_context_sign().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sign_sync"
              c:identifier="camel_cipher_context_sign_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Converts the (unsigned) part @ipart into a new self-contained MIME
part @opart.  This may be a multipart/signed part, or a simple part
for enveloped types.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="userid" transfer-ownership="none">
            <doc xml:space="preserve">a private key to use to sign the stream</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:space="preserve">preferred Message-Integrity-Check hash algorithm</doc>
            <type name="CipherHash" c:type="CamelCipherHash"/>
          </parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">input #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="opart" transfer-ownership="none">
            <doc xml:space="preserve">output #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify"
              c:identifier="camel_cipher_context_verify"
              version="3.0">
        <doc xml:space="preserve">Asynchronously verifies the signature.

When the operation is finished, @callback will be called.  You can
then call camel_cipher_context_verify_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelMimePart to verify</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_finish"
              c:identifier="camel_cipher_context_verify_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_cipher_context_verify().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelCipherValidity structure containing information
about the integrity of the input stream, or %NULL on failure to
execute at all</doc>
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="verify_sync"
              c:identifier="camel_cipher_context_verify_sync"
              throws="1">
        <doc xml:space="preserve">Verifies the signature.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelCipherValidity structure containing information
about the integrity of the input stream, or %NULL on failure to
execute at all</doc>
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherContext</doc>
            <type name="CipherContext" c:type="CamelCipherContext*"/>
          </instance-parameter>
          <parameter name="ipart" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelMimePart to verify</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="session"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Session"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="CipherContextPrivate" c:type="CamelCipherContextPrivate*"/>
      </field>
    </class>
    <record name="CipherContextClass"
            c:type="CamelCipherContextClass"
            glib:is-gtype-struct-for="CipherContext">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="sign_protocol">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="encrypt_protocol">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="key_protocol">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="id_to_hash">
        <callback name="id_to_hash">
          <return-value transfer-ownership="none">
            <type name="CipherHash" c:type="CamelCipherHash"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="CipherContext" c:type="CamelCipherContext*"/>
            </parameter>
            <parameter name="id" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="hash_to_id">
        <callback name="hash_to_id">
          <return-value transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <type name="CipherContext" c:type="CamelCipherContext*"/>
            </parameter>
            <parameter name="hash" transfer-ownership="none">
              <type name="CipherHash" c:type="CamelCipherHash"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sign_sync">
        <callback name="sign_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelCipherContext</doc>
              <type name="CipherContext" c:type="CamelCipherContext*"/>
            </parameter>
            <parameter name="userid" transfer-ownership="none">
              <doc xml:space="preserve">a private key to use to sign the stream</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="hash" transfer-ownership="none">
              <doc xml:space="preserve">preferred Message-Integrity-Check hash algorithm</doc>
              <type name="CipherHash" c:type="CamelCipherHash"/>
            </parameter>
            <parameter name="ipart" transfer-ownership="none">
              <doc xml:space="preserve">input #CamelMimePart</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="opart" transfer-ownership="none">
              <doc xml:space="preserve">output #CamelMimePart</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="verify_sync">
        <callback name="verify_sync" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #CamelCipherValidity structure containing information
about the integrity of the input stream, or %NULL on failure to
execute at all</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelCipherContext</doc>
              <type name="CipherContext" c:type="CamelCipherContext*"/>
            </parameter>
            <parameter name="ipart" transfer-ownership="none">
              <doc xml:space="preserve">the #CamelMimePart to verify</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="encrypt_sync">
        <callback name="encrypt_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelCipherContext</doc>
              <type name="CipherContext" c:type="CamelCipherContext*"/>
            </parameter>
            <parameter name="userid" transfer-ownership="none">
              <doc xml:space="preserve">key ID (or email address) to use when signing, or %NULL to not sign</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="recipients" transfer-ownership="none">
              <doc xml:space="preserve">an array of recipient key IDs and/or email addresses</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="utf8"/>
              </array>
            </parameter>
            <parameter name="ipart" transfer-ownership="none">
              <doc xml:space="preserve">clear-text #CamelMimePart</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="opart" transfer-ownership="none">
              <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decrypt_sync">
        <callback name="decrypt_sync" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a validity/encryption status, or %NULL on error</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </return-value>
          <parameters>
            <parameter name="context" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelCipherContext</doc>
              <type name="CipherContext" c:type="CamelCipherContext*"/>
            </parameter>
            <parameter name="ipart" transfer-ownership="none">
              <doc xml:space="preserve">cipher-text #CamelMimePart</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="opart" transfer-ownership="none">
              <doc xml:space="preserve">clear-text #CamelMimePart</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="CipherContextPrivate"
            c:type="CamelCipherContextPrivate"
            disguised="1">
    </record>
    <enumeration name="CipherHash" c:type="CamelCipherHash">
      <member name="default"
              value="0"
              c:identifier="CAMEL_CIPHER_HASH_DEFAULT">
      </member>
      <member name="md2" value="1" c:identifier="CAMEL_CIPHER_HASH_MD2">
      </member>
      <member name="md5" value="2" c:identifier="CAMEL_CIPHER_HASH_MD5">
      </member>
      <member name="sha1" value="3" c:identifier="CAMEL_CIPHER_HASH_SHA1">
      </member>
      <member name="sha256" value="4" c:identifier="CAMEL_CIPHER_HASH_SHA256">
      </member>
      <member name="sha384" value="5" c:identifier="CAMEL_CIPHER_HASH_SHA384">
      </member>
      <member name="sha512" value="6" c:identifier="CAMEL_CIPHER_HASH_SHA512">
      </member>
      <member name="ripemd160"
              value="7"
              c:identifier="CAMEL_CIPHER_HASH_RIPEMD160">
      </member>
      <member name="tiger192"
              value="8"
              c:identifier="CAMEL_CIPHER_HASH_TIGER192">
      </member>
      <member name="haval5160"
              value="9"
              c:identifier="CAMEL_CIPHER_HASH_HAVAL5160">
      </member>
    </enumeration>
    <record name="CipherValidity"
            c:type="CamelCipherValidity"
            glib:type-name="CamelCipherValidity"
            glib:get-type="camel_cipher_validity_get_type"
            c:symbol-prefix="cipher_validity">
      <field name="children" writable="1">
        <type name="GLib.Queue" c:type="GQueue"/>
      </field>
      <field name="sign" writable="1">
        <type name="gpointer" c:type="_sign"/>
      </field>
      <field name="encrypt" writable="1">
        <type name="gpointer" c:type="_encrypt"/>
      </field>
      <constructor name="new" c:identifier="camel_cipher_validity_new">
        <return-value transfer-ownership="full">
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
      </constructor>
      <method name="add_certinfo"
              c:identifier="camel_cipher_validity_add_certinfo">
        <doc xml:space="preserve">Add a cert info to the signer or encrypter info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Index of the added certinfo; -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="vin" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherValidity</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherValidityMode, where to add the additional certificate information</doc>
            <type name="CipherValidityMode" c:type="CamelCipherValidityMode"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="email" transfer-ownership="none">
            <doc xml:space="preserve">an e-mail address to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_certinfo_ex"
              c:identifier="camel_cipher_validity_add_certinfo_ex"
              version="2.30">
        <doc xml:space="preserve">Add a cert info to the signer or encrypter info, with extended data set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Index of the added certinfo; -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="vin" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherValidity</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherValidityMode, where to add the additional certificate information</doc>
            <type name="CipherValidityMode" c:type="CamelCipherValidityMode"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="email" transfer-ownership="none">
            <doc xml:space="preserve">an e-mail address to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cert_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     destroy="4">
            <doc xml:space="preserve">a certificate data, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="cert_data_free"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">a destroy function for @cert_data; required, when @cert_data is not %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="cert_data_clone"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="call">
            <doc xml:space="preserve">a copy function for @cert_data, to copy the data; required, when @cert_data is not %NULL</doc>
            <type name="CipherCloneFunc" c:type="CamelCipherCloneFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="camel_cipher_validity_clear">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="validity" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clone" c:identifier="camel_cipher_validity_clone">
        <return-value transfer-ownership="full">
          <type name="CipherValidity" c:type="CamelCipherValidity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vin" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="envelope" c:identifier="camel_cipher_validity_envelope">
        <doc xml:space="preserve">Calculate a conglomerate validity based on wrapping one secure part inside
another one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherValidity</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
          <parameter name="valid" transfer-ownership="none">
            <doc xml:space="preserve">a new #CamelCipherValidity to conglomerate the @parent with</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="camel_cipher_validity_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="validity" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_certinfo_property"
              c:identifier="camel_cipher_validity_get_certinfo_property"
              version="3.22">
        <doc xml:space="preserve">Gets a named property @name value for the given @info_index of the @mode validity part.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Value of a named property of a #CamelCipherCertInfo, or %NULL when no such
   property exists. The returned value is owned by the associated #CamelCipherCertInfo
   and is valid until the cert info is freed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="vin" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherValidity</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">which cipher validity part to use</doc>
            <type name="CipherValidityMode" c:type="CamelCipherValidityMode"/>
          </parameter>
          <parameter name="info_index" transfer-ownership="none">
            <doc xml:space="preserve">a 0-based index of the requested #CamelCipherCertInfo</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a property name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="camel_cipher_validity_get_description">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="validity" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_valid" c:identifier="camel_cipher_validity_get_valid">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="validity" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="camel_cipher_validity_init">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="validity" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_certinfo_property"
              c:identifier="camel_cipher_validity_set_certinfo_property"
              version="3.22">
        <doc xml:space="preserve">Sets a named property @name value @value for the given @info_index
of the @mode validity part. If the @value is %NULL, then the property
is removed. With a non-%NULL @value also @value_free and @value_clone
functions cannot be %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vin" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelCipherValidity</doc>
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">which cipher validity part to use</doc>
            <type name="CipherValidityMode" c:type="CamelCipherValidityMode"/>
          </parameter>
          <parameter name="info_index" transfer-ownership="none">
            <doc xml:space="preserve">a 0-based index of the requested #CamelCipherCertInfo</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a property name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     destroy="4">
            <doc xml:space="preserve">a property value, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="value_free"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve">a free function for the @value</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="value_clone"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="call">
            <doc xml:space="preserve">a clone function for the @value</doc>
            <type name="CipherCloneFunc" c:type="CamelCipherCloneFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_description"
              c:identifier="camel_cipher_validity_set_description">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="validity" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valid" c:identifier="camel_cipher_validity_set_valid">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="validity" transfer-ownership="none">
            <type name="CipherValidity" c:type="CamelCipherValidity*"/>
          </instance-parameter>
          <parameter name="valid" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="CipherValidityEncrypt"
                 c:type="CamelCipherValidityEncrypt">
      <member name="none"
              value="0"
              c:identifier="CAMEL_CIPHER_VALIDITY_ENCRYPT_NONE">
      </member>
      <member name="weak"
              value="1"
              c:identifier="CAMEL_CIPHER_VALIDITY_ENCRYPT_WEAK">
      </member>
      <member name="encrypted"
              value="2"
              c:identifier="CAMEL_CIPHER_VALIDITY_ENCRYPT_ENCRYPTED">
      </member>
      <member name="strong"
              value="3"
              c:identifier="CAMEL_CIPHER_VALIDITY_ENCRYPT_STRONG">
      </member>
    </enumeration>
    <enumeration name="CipherValidityMode" c:type="CamelCipherValidityMode">
      <member name="sign" value="0" c:identifier="CAMEL_CIPHER_VALIDITY_SIGN">
      </member>
      <member name="encrypt"
              value="1"
              c:identifier="CAMEL_CIPHER_VALIDITY_ENCRYPT">
      </member>
    </enumeration>
    <enumeration name="CipherValiditySign" c:type="CamelCipherValiditySign">
      <member name="none"
              value="0"
              c:identifier="CAMEL_CIPHER_VALIDITY_SIGN_NONE">
      </member>
      <member name="good"
              value="1"
              c:identifier="CAMEL_CIPHER_VALIDITY_SIGN_GOOD">
      </member>
      <member name="bad"
              value="2"
              c:identifier="CAMEL_CIPHER_VALIDITY_SIGN_BAD">
      </member>
      <member name="unknown"
              value="3"
              c:identifier="CAMEL_CIPHER_VALIDITY_SIGN_UNKNOWN">
      </member>
      <member name="need_public_key"
              value="4"
              c:identifier="CAMEL_CIPHER_VALIDITY_SIGN_NEED_PUBLIC_KEY">
      </member>
    </enumeration>
    <enumeration name="CompareType"
                 version="3.24"
                 glib:type-name="CamelCompareType"
                 glib:get-type="camel_compare_type_get_type"
                 c:type="CamelCompareType">
      <doc xml:space="preserve">Declares the compare type to use.</doc>
      <member name="insensitive"
              value="0"
              c:identifier="CAMEL_COMPARE_CASE_INSENSITIVE"
              glib:nick="insensitive">
        <doc xml:space="preserve">compare case insensitively</doc>
      </member>
      <member name="sensitive"
              value="1"
              c:identifier="CAMEL_COMPARE_CASE_SENSITIVE"
              glib:nick="sensitive">
        <doc xml:space="preserve">compare case sensitively</doc>
      </member>
    </enumeration>
    <record name="ContentDisposition"
            c:type="CamelContentDisposition"
            glib:type-name="CamelContentDisposition"
            glib:get-type="camel_content_disposition_get_type"
            c:symbol-prefix="content_disposition">
      <field name="disposition" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <type name="gpointer" c:type="_camel_header_param*"/>
      </field>
      <field name="refcount" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="format" c:identifier="camel_content_disposition_format">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="disposition" transfer-ownership="none">
            <type name="ContentDisposition" c:type="CamelContentDisposition*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="camel_content_disposition_ref">
        <return-value transfer-ownership="full">
          <type name="ContentDisposition" c:type="CamelContentDisposition*"/>
        </return-value>
        <parameters>
          <instance-parameter name="disposition" transfer-ownership="none">
            <type name="ContentDisposition" c:type="CamelContentDisposition*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="camel_content_disposition_unref">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="disposition" transfer-ownership="none">
            <type name="ContentDisposition" c:type="CamelContentDisposition*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="decode" c:identifier="camel_content_disposition_decode">
        <return-value transfer-ownership="full">
          <type name="ContentDisposition" c:type="CamelContentDisposition*"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ContentType"
            c:type="CamelContentType"
            glib:type-name="CamelContentType"
            glib:get-type="camel_content_type_get_type"
            c:symbol-prefix="content_type">
      <field name="type" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="subtype" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <type name="gpointer" c:type="_camel_header_param*"/>
      </field>
      <field name="refcount" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="camel_content_type_new">
        <doc xml:space="preserve">Create a new #CamelContentType.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #CamelContentType</doc>
          <type name="ContentType" c:type="CamelContentType*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the major type of the new content-type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="subtype" transfer-ownership="none">
            <doc xml:space="preserve">the subtype</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="dump" c:identifier="camel_content_type_dump">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="format" c:identifier="camel_content_type_format">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is" c:identifier="camel_content_type_is">
        <doc xml:space="preserve">The subtype of "*" will match any subtype.  If @ct is %NULL, then
it will match the type "text/plain".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the content type @ct is of type @type/@subtype or
%FALSE otherwise</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">A content type specifier, or %NULL.</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">A type to check against.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="subtype" transfer-ownership="none">
            <doc xml:space="preserve">A subtype to check against, or "*" to match any subtype.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="param" c:identifier="camel_content_type_param">
        <doc xml:space="preserve">Searches the params on s #CamelContentType for a param named @name
and gets the value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the @name param</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelContentType</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of param to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="camel_content_type_ref">
        <doc xml:space="preserve">Refs the content type.</doc>
        <return-value transfer-ownership="full">
          <type name="ContentType" c:type="CamelContentType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelContentType</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_param" c:identifier="camel_content_type_set_param">
        <doc xml:space="preserve">Set a parameter on @content_type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelContentType</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of param to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value of param to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="simple" c:identifier="camel_content_type_simple">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="camel_content_type_unref">
        <doc xml:space="preserve">Unrefs, and potentially frees, the content type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelContentType</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="decode" c:identifier="camel_content_type_decode">
        <return-value transfer-ownership="full">
          <type name="ContentType" c:type="CamelContentType*"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="CopyFunc" c:type="CamelCopyFunc">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DB"
           c:symbol-prefix="db"
           c:type="CamelDB"
           version="2.24"
           parent="GObject.Object"
           glib:type-name="CamelDB"
           glib:get-type="camel_db_get_type"
           glib:type-struct="DBClass">
      <constructor name="new"
                   c:identifier="camel_db_new"
                   version="3.24"
                   throws="1">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelDB with @filename as its database file.
  Free it with g_object_unref() when no longer needed.</doc>
          <type name="DB" c:type="CamelDB*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">A filename with the database to open/create</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="camel_mir_free"
                c:identifier="camel_db_camel_mir_free"
                version="2.24">
        <doc xml:space="preserve">Frees the @record and all of its associated data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="record"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelMIRecord</doc>
            <type name="MIRecord" c:type="CamelMIRecord*"/>
          </parameter>
        </parameters>
      </function>
      <function name="free_sqlized_string"
                c:identifier="camel_db_free_sqlized_string"
                version="2.24">
        <doc xml:space="preserve">Frees a string previosuly returned by camel_db_sqlize_string().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="string"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a string to free</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_column_ident"
                c:identifier="camel_db_get_column_ident"
                version="3.4">
        <doc xml:space="preserve">Traverses column name from index @index into an enum
#CamelDBKnownColumnNames value.  The @col_names contains @ncols columns.
First time this is called is created the @hash from col_names indexes into
the enum, and this is reused for every other call.  The function expects
that column names are returned always in the same order.  When all rows
are read the @hash table can be freed with g_hash_table_destroy().</doc>
        <return-value transfer-ownership="none">
          <type name="DBKnownColumnNames" c:type="CamelDBKnownColumnNames"/>
        </return-value>
        <parameters>
          <parameter name="hash"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a #GHashTable</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index to start with, between 0 and @ncols</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="ncols" transfer-ownership="none">
            <doc xml:space="preserve">number of @col_names</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="col_names" transfer-ownership="none">
            <doc xml:space="preserve">column names to traverse</doc>
            <array length="2" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_column_name"
                c:identifier="camel_db_get_column_name"
                version="2.24">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">A corresponding column name in the message info table
  for the @raw_name, or %NULL, when there is no corresponding column in the summary.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="raw_name" transfer-ownership="none">
            <doc xml:space="preserve">raw name to find the column name for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="release_cache_memory"
                c:identifier="camel_db_release_cache_memory"
                version="3.24">
        <doc xml:space="preserve">Instructs sqlite to release its memory, if possible. This can be avoided
when CAMEL_SQLITE_FREE_CACHE environment variable is set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="sqlize_string"
                c:identifier="camel_db_sqlize_string"
                version="2.24">
        <doc xml:space="preserve">Converts the @string to be usable in the SQLite statements.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated sqlized @string. The returned
   value should be freed with camel_db_sqlize_string(), when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string to "sqlize"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="abort_transaction"
              c:identifier="camel_db_abort_transaction"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Ends an ongoing transaction by ignoring the changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="add_to_transaction"
              c:identifier="camel_db_add_to_transaction"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Adds a statement to an ongoing transaction.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">an SQL (SQLite) statement</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="begin_transaction"
              c:identifier="camel_db_begin_transaction"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Begins transaction. End it with camel_db_end_transaction() or camel_db_abort_transaction().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_folder_summary"
              c:identifier="camel_db_clear_folder_summary"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Deletes the given folder from the 'folders' table and empties
its message info table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="command"
              c:identifier="camel_db_command"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Executes an SQLite command.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve">an SQL (SQLite) statement to execute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_deleted_message_info"
              c:identifier="camel_db_count_deleted_message_info"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Counts how many deleted messages is stored in the given table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="table_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the table</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">where to store the resulting count</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_junk_message_info"
              c:identifier="camel_db_count_junk_message_info"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Counts how many junk messages is stored in the given table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="table_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the table</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">where to store the resulting count</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_junk_not_deleted_message_info"
              c:identifier="camel_db_count_junk_not_deleted_message_info"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="table_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_message_info"
              c:identifier="camel_db_count_message_info"
              version="2.26"
              throws="1">
        <doc xml:space="preserve">Executes a COUNT() query (like "SELECT COUNT(*) FROM table") and provides
the result of it as an unsigned 32-bit integer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">a COUNT() query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the result of the query</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_total_message_info"
              c:identifier="camel_db_count_total_message_info"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Counts how many messages is stored in the given table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="table_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the table</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">where to store the resulting count</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_unread_message_info"
              c:identifier="camel_db_count_unread_message_info"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Counts how many unread messages is stored in the given table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="table_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the table</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">where to store the resulting count</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_visible_message_info"
              c:identifier="camel_db_count_visible_message_info"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Counts how many visible (not deleted and not junk) messages is stored in the given table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="table_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the table</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">where to store the resulting count</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_visible_unread_message_info"
              c:identifier="camel_db_count_visible_unread_message_info"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Counts how many visible (not deleted and not junk) and unread messages is stored in the given table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="table_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the table</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="count"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">where to store the resulting count</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_folders_table"
              c:identifier="camel_db_create_folders_table"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Creates a 'folders' table, if it doesn't exist yet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete_folder"
              c:identifier="camel_db_delete_folder"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Deletes the given folder from the 'folders' table and also drops
its message info table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_uid"
              c:identifier="camel_db_delete_uid"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Deletes single mesage info in the given folder with
the given UID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a message info UID to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_uids"
              c:identifier="camel_db_delete_uids"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Deletes a list of message UIDs as one transaction.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">A #GList of uids</doc>
            <type name="GLib.List" c:type="const GList*">
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="end_transaction"
              c:identifier="camel_db_end_transaction"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Ends an ongoing transaction by committing the changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush_in_memory_transactions"
              c:identifier="camel_db_flush_in_memory_transactions"
              version="2.26"
              throws="1">
        <doc xml:space="preserve">A pair function for camel_db_start_in_memory_transactions(),
to commit the changes to @folder_name and free the in-memory table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_filename"
              c:identifier="camel_db_get_filename"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A filename associated with @cdb.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder_deleted_uids"
              c:identifier="camel_db_get_folder_deleted_uids"
              version="2.24"
              throws="1">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">An array
  of the UID-s of the deleted messages in the given folder. Use
  camel_pstring_free() to free the elements.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folder_junk_uids"
              c:identifier="camel_db_get_folder_junk_uids"
              version="2.24"
              throws="1">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">An array
  of the UID-s of the junk messages in the given folder. Use
  camel_pstring_free() to free the elements.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folder_uids"
              c:identifier="camel_db_get_folder_uids"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Fills hash with uid-&gt;GUINT_TO_POINTER (flag). Use camel_pstring_free()
to free the keys of the @hash.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="sort_by"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional ORDER BY clause (without the "ORDER BY" prefix)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="collate"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional collate function name to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:space="preserve">a hash table to fill</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="guint32"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="maybe_run_maintenance"
              c:identifier="camel_db_maybe_run_maintenance"
              version="3.16"
              throws="1">
        <doc xml:space="preserve">Runs a @cdb maintenance, which includes vacuum, if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepare_message_info_table"
              c:identifier="camel_db_prepare_message_info_table"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Prepares message info table for the given folder.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_folder_info_record"
              c:identifier="camel_db_read_folder_info_record"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">reads folder information for the given folder and stores it into the @record.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="record"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFIRecord</doc>
            <type name="FIRecord" c:type="CamelFIRecord*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_message_info_record_with_uid"
              c:identifier="camel_db_read_message_info_record_with_uid"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Selects single message info for the given @uid in folder @folder_name and calls
the @callback for it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a message info UID to read the record for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data of the @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">callback to call for the found row</doc>
            <type name="DBSelectCB" c:type="CamelDBSelectCB"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_message_info_records"
              c:identifier="camel_db_read_message_info_records"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Reads all mesasge info records for the given folder and calls @callback for them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for the @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:space="preserve">callback to call for each found row</doc>
            <type name="DBSelectCB" c:type="CamelDBSelectCB"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_folder"
              c:identifier="camel_db_rename_folder"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Renames tables for the @old_folder_name to be used with @new_folder_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="old_folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the existing folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder to rename it to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset_folder_version"
              c:identifier="camel_db_reset_folder_version"
              version="2.28"
              throws="1">
        <doc xml:space="preserve">Sets a version number for the given folder.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="reset_version" transfer-ownership="none">
            <doc xml:space="preserve">version number to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="select"
              c:identifier="camel_db_select"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Executes a SELECT staement and calls the @callback for each selected row.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve">a SELECT statment to execute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">a callback to call for each row</doc>
            <type name="DBSelectCB" c:type="CamelDBSelectCB"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for the @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_collate"
              c:identifier="camel_db_set_collate"
              version="2.24">
        <doc xml:space="preserve">Defines a collation @collate, which can be used in SQL (SQLite)
statement as a collation function. The @func is called when
colation is used.</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="col" transfer-ownership="none">
            <doc xml:space="preserve">a column name; currently unused</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="collate" transfer-ownership="none">
            <doc xml:space="preserve">collation name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:space="preserve">a #CamelDBCollate collation function</doc>
            <type name="DBCollate" c:type="CamelDBCollate"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_in_memory_transactions"
              c:identifier="camel_db_start_in_memory_transactions"
              version="2.26"
              throws="1">
        <doc xml:space="preserve">Creates an in-memory table for a batch transactions. Use camel_db_flush_in_memory_transactions()
to commit the changes and free the in-memory table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="transaction_command"
              c:identifier="camel_db_transaction_command"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Runs the list of commands as a single transaction.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="qry_list" transfer-ownership="none">
            <doc xml:space="preserve">A #GList of querries</doc>
            <type name="GLib.List" c:type="const GList*">
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="write_folder_info_record"
              c:identifier="camel_db_write_folder_info_record"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Write the @record to the 'folders' table.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="record" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFIRecord</doc>
            <type name="FIRecord" c:type="CamelFIRecord*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_message_info_record"
              c:identifier="camel_db_write_message_info_record"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Write the @record to the message info table of the given folder.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdb" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDB</doc>
            <type name="DB" c:type="CamelDB*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="record" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMIRecord</doc>
            <type name="MIRecord" c:type="CamelMIRecord*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBPrivate" c:type="CamelDBPrivate*"/>
      </field>
    </class>
    <record name="DBClass" c:type="CamelDBClass" glib:is-gtype-struct-for="DB">
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="DBCollate" c:type="CamelDBCollate" version="2.24">
      <doc xml:space="preserve">A collation callback function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">less than zero, zero, or greater than zero value, the same as for example strcmp() does.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="enc"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a used encoding (SQLITE_UTF8)</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="length1" transfer-ownership="none">
          <doc xml:space="preserve">length of the @data1</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="data1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the first value, of lenth @length1</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="length2" transfer-ownership="none">
          <doc xml:space="preserve">length of the @data2</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="data2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the second value, of lenth @length2</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="DBKnownColumnNames"
                 version="3.4"
                 c:type="CamelDBKnownColumnNames">
      <doc xml:space="preserve">An enum of all the known columns, which can be used for a quick column lookups.</doc>
      <member name="unknown" value="-1" c:identifier="CAMEL_DB_COLUMN_UNKNOWN">
        <doc xml:space="preserve">unknown column name</doc>
      </member>
      <member name="attachment"
              value="0"
              c:identifier="CAMEL_DB_COLUMN_ATTACHMENT">
        <doc xml:space="preserve">attachment</doc>
      </member>
      <member name="bdata" value="1" c:identifier="CAMEL_DB_COLUMN_BDATA">
        <doc xml:space="preserve">bdata</doc>
      </member>
      <member name="cinfo" value="2" c:identifier="CAMEL_DB_COLUMN_CINFO">
        <doc xml:space="preserve">cinfo</doc>
      </member>
      <member name="deleted" value="3" c:identifier="CAMEL_DB_COLUMN_DELETED">
        <doc xml:space="preserve">deleted</doc>
      </member>
      <member name="deleted_count"
              value="4"
              c:identifier="CAMEL_DB_COLUMN_DELETED_COUNT">
        <doc xml:space="preserve">deleted_count</doc>
      </member>
      <member name="dreceived"
              value="5"
              c:identifier="CAMEL_DB_COLUMN_DRECEIVED">
        <doc xml:space="preserve">dreceived</doc>
      </member>
      <member name="dsent" value="6" c:identifier="CAMEL_DB_COLUMN_DSENT">
        <doc xml:space="preserve">dsent</doc>
      </member>
      <member name="flags" value="7" c:identifier="CAMEL_DB_COLUMN_FLAGS">
        <doc xml:space="preserve">flags</doc>
      </member>
      <member name="folder_name"
              value="8"
              c:identifier="CAMEL_DB_COLUMN_FOLDER_NAME">
        <doc xml:space="preserve">folder_name</doc>
      </member>
      <member name="followup_completed_on"
              value="9"
              c:identifier="CAMEL_DB_COLUMN_FOLLOWUP_COMPLETED_ON">
        <doc xml:space="preserve">followup_completed_on</doc>
      </member>
      <member name="followup_due_by"
              value="10"
              c:identifier="CAMEL_DB_COLUMN_FOLLOWUP_DUE_BY">
        <doc xml:space="preserve">followup_due_by</doc>
      </member>
      <member name="followup_flag"
              value="11"
              c:identifier="CAMEL_DB_COLUMN_FOLLOWUP_FLAG">
        <doc xml:space="preserve">followup_flag</doc>
      </member>
      <member name="important"
              value="12"
              c:identifier="CAMEL_DB_COLUMN_IMPORTANT">
        <doc xml:space="preserve">important</doc>
      </member>
      <member name="jnd_count"
              value="13"
              c:identifier="CAMEL_DB_COLUMN_JND_COUNT">
        <doc xml:space="preserve">jnd_count</doc>
      </member>
      <member name="junk" value="14" c:identifier="CAMEL_DB_COLUMN_JUNK">
        <doc xml:space="preserve">junk</doc>
      </member>
      <member name="junk_count"
              value="15"
              c:identifier="CAMEL_DB_COLUMN_JUNK_COUNT">
        <doc xml:space="preserve">junk_count</doc>
      </member>
      <member name="labels" value="16" c:identifier="CAMEL_DB_COLUMN_LABELS">
        <doc xml:space="preserve">labels</doc>
      </member>
      <member name="mail_cc" value="17" c:identifier="CAMEL_DB_COLUMN_MAIL_CC">
        <doc xml:space="preserve">mail_cc</doc>
      </member>
      <member name="mail_from"
              value="18"
              c:identifier="CAMEL_DB_COLUMN_MAIL_FROM">
        <doc xml:space="preserve">mail_from</doc>
      </member>
      <member name="mail_to" value="19" c:identifier="CAMEL_DB_COLUMN_MAIL_TO">
        <doc xml:space="preserve">mail_to</doc>
      </member>
      <member name="mlist" value="20" c:identifier="CAMEL_DB_COLUMN_MLIST">
        <doc xml:space="preserve">mlist</doc>
      </member>
      <member name="nextuid" value="21" c:identifier="CAMEL_DB_COLUMN_NEXTUID">
        <doc xml:space="preserve">nextuid</doc>
      </member>
      <member name="part" value="22" c:identifier="CAMEL_DB_COLUMN_PART">
        <doc xml:space="preserve">part</doc>
      </member>
      <member name="read" value="23" c:identifier="CAMEL_DB_COLUMN_READ">
        <doc xml:space="preserve">read</doc>
      </member>
      <member name="replied" value="24" c:identifier="CAMEL_DB_COLUMN_REPLIED">
        <doc xml:space="preserve">replied</doc>
      </member>
      <member name="saved_count"
              value="25"
              c:identifier="CAMEL_DB_COLUMN_SAVED_COUNT">
        <doc xml:space="preserve">saved_count</doc>
      </member>
      <member name="size" value="26" c:identifier="CAMEL_DB_COLUMN_SIZE">
        <doc xml:space="preserve">size</doc>
      </member>
      <member name="subject" value="27" c:identifier="CAMEL_DB_COLUMN_SUBJECT">
        <doc xml:space="preserve">subject</doc>
      </member>
      <member name="time" value="28" c:identifier="CAMEL_DB_COLUMN_TIME">
        <doc xml:space="preserve">time</doc>
      </member>
      <member name="uid" value="29" c:identifier="CAMEL_DB_COLUMN_UID">
        <doc xml:space="preserve">uid</doc>
      </member>
      <member name="unread_count"
              value="30"
              c:identifier="CAMEL_DB_COLUMN_UNREAD_COUNT">
        <doc xml:space="preserve">unread_count</doc>
      </member>
      <member name="usertags"
              value="31"
              c:identifier="CAMEL_DB_COLUMN_USERTAGS">
        <doc xml:space="preserve">usertags</doc>
      </member>
      <member name="version" value="32" c:identifier="CAMEL_DB_COLUMN_VERSION">
        <doc xml:space="preserve">version</doc>
      </member>
      <member name="visible_count"
              value="33"
              c:identifier="CAMEL_DB_COLUMN_VISIBLE_COUNT">
        <doc xml:space="preserve">visible_count</doc>
      </member>
      <member name="vuid" value="34" c:identifier="CAMEL_DB_COLUMN_VUID">
        <doc xml:space="preserve">vuid</doc>
      </member>
    </enumeration>
    <record name="DBPrivate" c:type="CamelDBPrivate" disguised="1">
    </record>
    <callback name="DBSelectCB" c:type="CamelDBSelectCB" version="2.24">
      <doc xml:space="preserve">A callback called for the SELECT statements. The items at the same index of @colvalues
and @colnames correspond to each other.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 to continue the SELECT execution, non-zero to abort the execution.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="0">
          <doc xml:space="preserve">a callback user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="ncol" transfer-ownership="none">
          <doc xml:space="preserve">how many columns is provided</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="colvalues" transfer-ownership="none">
          <doc xml:space="preserve">array of column values, as UTF-8 strings</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="colnames" transfer-ownership="none">
          <doc xml:space="preserve">array of column names</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </callback>
    <constant name="DB_FILE"
              value="folders.db"
              c:type="CAMEL_DB_FILE"
              version="2.24">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DB_FREE_CACHE_SIZE"
              value="2097152"
              c:type="CAMEL_DB_FREE_CACHE_SIZE"
              version="2.24">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DB_IN_MEMORY_DB"
              value="EVO_IN_meM_hAnDlE"
              c:type="CAMEL_DB_IN_MEMORY_DB"
              version="2.26">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DB_IN_MEMORY_TABLE"
              value="EVO_IN_meM_hAnDlE.temp"
              c:type="CAMEL_DB_IN_MEMORY_TABLE"
              version="2.26">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DB_IN_MEMORY_TABLE_LIMIT"
              value="100000"
              c:type="CAMEL_DB_IN_MEMORY_TABLE_LIMIT"
              version="2.26">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DB_SLEEP_INTERVAL"
              value="100"
              c:type="CAMEL_DB_SLEEP_INTERVAL"
              version="2.24">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DEBUG_IMAP" value="imap" c:type="CAMEL_DEBUG_IMAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DEBUG_IMAP_FOLDER"
              value="imap:folder"
              c:type="CAMEL_DEBUG_IMAP_FOLDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DOT_LOCK_REFRESH"
              value="30"
              c:type="CAMEL_DOT_LOCK_REFRESH">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="DataCache"
           c:symbol-prefix="data_cache"
           c:type="CamelDataCache"
           parent="GObject.Object"
           glib:type-name="CamelDataCache"
           glib:get-type="camel_data_cache_get_type"
           glib:type-struct="DataCacheClass">
      <constructor name="new" c:identifier="camel_data_cache_new" throws="1">
        <doc xml:space="preserve">Create a new data cache.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new cache object, or NULL if the base path cannot
be written to.</doc>
          <type name="DataCache" c:type="CamelDataCache*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Base path of cache, subdirectories will be created here.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="camel_data_cache_add" throws="1">
        <doc xml:space="preserve">Add a new item to the cache, returning a #GIOStream to the new item.

The key and the path combine to form a unique key used to store the item.

Potentially, expiry processing will be performed while this call is
executing.

The returned #GIOStream is referenced for thread-safety and must be
unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream for the new cache item, or %NULL</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">A #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Relative path of item to add.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">Key of item to add.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="camel_data_cache_clear" version="3.2">
        <doc xml:space="preserve">Clear cache's content in @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Path to the (sub) cache the item exists in.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_remove"
              c:identifier="camel_data_cache_foreach_remove"
              version="3.26">
        <doc xml:space="preserve">Traverses the @cdc sub-cache identified by @path and calls @func for each found file.
If the @func returns %TRUE, then the file is removed, if %FALSE, it's kept in the cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Path to the (sub) cache the items exist in</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">a callback to call for each found file in the cache</doc>
            <type name="DataCacheRemoveFunc"
                  c:type="CamelDataCacheRemoveFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="camel_data_cache_get" throws="1">
        <doc xml:space="preserve">Lookup an item in the cache.  If the item exists, a #GIOStream is returned
for the item.  The stream may be shared by multiple callers, so ensure the
stream is in a valid state through external locking.

The returned #GIOStream is referenced for thread-safety and must be
unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream for the requested cache item, or %NULL</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">A #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Path to the (sub) cache the item exists in.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">Key for the cache item.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_expire_enabled"
              c:identifier="camel_data_cache_get_expire_enabled"
              version="3.24">
        <doc xml:space="preserve">Gets whether expire of cache data is enabled.

This is a complementary property for camel_data_cache_set_expire_age()
and camel_data_cache_set_expire_access(), which allows to disable expiry
without touching the two values. Having expire enabled, but not have set
any of the two times, still behaves like not having expiry enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether expire is enabled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename"
              c:identifier="camel_data_cache_get_filename"
              version="2.26">
        <doc xml:space="preserve">Lookup the filename for an item in the cache</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The filename for a cache item</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">A #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Path to the (sub) cache the item exists in.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">Key for the cache item.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_path"
              c:identifier="camel_data_cache_get_path"
              version="2.32">
        <doc xml:space="preserve">Returns the path to the data cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the path to the data cache</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="camel_data_cache_remove" throws="1">
        <doc xml:space="preserve">Remove/expire a cache item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success, -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">A #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">Path to the (sub) cache the item exists in.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">Key for the cache item.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expire_access"
              c:identifier="camel_data_cache_set_expire_access">
        <doc xml:space="preserve">Set the cache expiration policy for access times.

Items in the cache which haven't been accessed for @when
seconds may be expired at any time.  Items are expired in a lazy
manner, so it is indeterminate when the items will
physically be removed.

Note you can set both an age and an access limit.  The
age acts as a hard limit on cache entries.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">A #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="when" transfer-ownership="none">
            <doc xml:space="preserve">Timeout for access, or -1 to disable access expiry.</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expire_age"
              c:identifier="camel_data_cache_set_expire_age">
        <doc xml:space="preserve">Set the cache expiration policy for aged entries.

Items in the cache older than @when seconds may be
flushed at any time.  Items are expired in a lazy
manner, so it is indeterminate when the items will
physically be removed.

Note you can set both an age and an access limit.  The
age acts as a hard limit on cache entries.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">A #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="when" transfer-ownership="none">
            <doc xml:space="preserve">Timeout for age expiry, or -1 to disable.</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expire_enabled"
              c:identifier="camel_data_cache_set_expire_enabled"
              version="3.24">
        <doc xml:space="preserve">Sets whether expire of cache data is enabled.

This is a complementary property for camel_data_cache_set_expire_age()
and camel_data_cache_set_expire_access(), which allows to disable expiry
without touching the two values. Having expire enabled, but not have set
any of the two times, still behaves like not having expiry enabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="expire_enabled" transfer-ownership="none">
            <doc xml:space="preserve">a value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path"
              c:identifier="camel_data_cache_set_path"
              version="2.32">
        <doc xml:space="preserve">Sets the path to the data cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cdc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataCache</doc>
            <type name="DataCache" c:type="CamelDataCache*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">path to the data cache</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="expire-enabled"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="path"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="DataCachePrivate" c:type="CamelDataCachePrivate*"/>
      </field>
    </class>
    <record name="DataCacheClass"
            c:type="CamelDataCacheClass"
            glib:is-gtype-struct-for="DataCache">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DataCachePrivate"
            c:type="CamelDataCachePrivate"
            disguised="1">
    </record>
    <callback name="DataCacheRemoveFunc"
              c:type="CamelDataCacheRemoveFunc"
              version="3.26">
      <doc xml:space="preserve">A callback called for each found file in the cache, used
by camel_data_cache_foreach_remove(). The @filename corresponds
to the result of camel_data_cache_get_filename().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE, to delete the file, %FALSE to keep in in the cache</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cdc" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelDataCache</doc>
          <type name="DataCache" c:type="CamelDataCache*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a file name found in the cache</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">user data passed to camel_data_cache_foreach_remove()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DataWrapper"
           c:symbol-prefix="data_wrapper"
           c:type="CamelDataWrapper"
           parent="GObject.Object"
           glib:type-name="CamelDataWrapper"
           glib:get-type="camel_data_wrapper_get_type"
           glib:type-struct="DataWrapperClass">
      <constructor name="new" c:identifier="camel_data_wrapper_new">
        <doc xml:space="preserve">Create a new #CamelDataWrapper object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelDataWrapper object</doc>
          <type name="DataWrapper" c:type="CamelDataWrapper*"/>
        </return-value>
      </constructor>
      <virtual-method name="construct_from_input_stream_sync"
                      invoker="construct_from_input_stream_sync"
                      version="3.12"
                      throws="1">
        <doc xml:space="preserve">Constructs the content of @data_wrapper from @input_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="input_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="construct_from_stream_sync"
                      invoker="construct_from_stream_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Constructs the content of @data_wrapper from the given @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">an input #CamelStream</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decode_to_output_stream_sync"
                      invoker="decode_to_output_stream_sync"
                      version="3.12"
                      throws="1">
        <doc xml:space="preserve">Writes the decoded data content to @output_stream.

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @output_stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decode_to_stream_sync"
                      invoker="decode_to_stream_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Writes the decoded data content to @stream.

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream for decoded data to be written to</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mime_type" invoker="get_mime_type">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the MIME type which must be freed by the caller</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mime_type_field" invoker="get_mime_type_field">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parsed form of the data wrapper's MIME type</doc>
          <type name="ContentType" c:type="CamelContentType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_offline" invoker="is_offline">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @data_wrapper is "offline" (data stored
remotely) or not. Some optional code paths may choose to not
operate on offline data.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_mime_type" invoker="set_mime_type">
        <doc xml:space="preserve">This sets the data wrapper's MIME type.

It might fail, but you won't know. It will allow you to set
Content-Type parameters on the data wrapper, which are meaningless.
You should not be allowed to change the MIME type of a data wrapper
that contains data, or at least, if you do, it should invalidate the
data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve">a MIME type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_mime_type_field" invoker="set_mime_type_field">
        <doc xml:space="preserve">This sets the data wrapper's MIME type. It adds its own reference
to @mime_type, if not %NULL.

It suffers from the same flaws as camel_data_wrapper_set_mime_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="mime_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelContentType</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_to_output_stream_sync"
                      invoker="write_to_output_stream_sync"
                      version="3.12"
                      throws="1">
        <doc xml:space="preserve">Writes the content of @data_wrapper to @output_stream in a
machine-independent format appropriate for the data.

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @output_stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_to_stream_sync"
                      invoker="write_to_stream_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Writes the content of @data_wrapper to @stream in a machine-independent
format appropriate for the data.  It should be possible to construct an
equivalent data wrapper object later by passing this stream to
camel_data_wrapper_construct_from_stream_sync().

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream for output</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="calculate_decoded_size_sync"
              c:identifier="camel_data_wrapper_calculate_decoded_size_sync"
              version="3.24"
              throws="1">
        <doc xml:space="preserve">Calculates decoded size of the @data_wrapper by saving it to a null-stream
and returns how many bytes had been written. It's using
camel_data_wrapper_decode_to_stream_sync() internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">how many bytes the @data_wrapper would use when saved,
  or -1 on error.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="calculate_size_sync"
              c:identifier="camel_data_wrapper_calculate_size_sync"
              version="3.24"
              throws="1">
        <doc xml:space="preserve">Calculates size of the @data_wrapper by saving it to a null-stream
and returns how many bytes had been written. It's using
camel_data_wrapper_write_to_stream_sync() internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">how many bytes the @data_wrapper would use when saved,
  or -1 on error.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_input_stream"
              c:identifier="camel_data_wrapper_construct_from_input_stream"
              version="3.12">
        <doc xml:space="preserve">Asynchronously constructs the content of @data_wrapper from @input_stream.

When the operation is finished, @callback will be called.  You can then
call camel_data_wrapper_construct_from_input_stream_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="input_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_input_stream_finish"
              c:identifier="camel_data_wrapper_construct_from_input_stream_finish"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with
camel_data_wrapper_construct_from_input_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_input_stream_sync"
              c:identifier="camel_data_wrapper_construct_from_input_stream_sync"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Constructs the content of @data_wrapper from @input_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="input_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_stream"
              c:identifier="camel_data_wrapper_construct_from_stream"
              version="3.0">
        <doc xml:space="preserve">Asynchronously constructs the content of @data_wrapper from the given
@stream.

When the operation is finished, @callback will be called.  You can then
call camel_data_wrapper_construct_from_stream_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">an input #CamelStream</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_stream_finish"
              c:identifier="camel_data_wrapper_construct_from_stream_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with
camel_data_wrapper_construct_from_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_stream_sync"
              c:identifier="camel_data_wrapper_construct_from_stream_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Constructs the content of @data_wrapper from the given @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">an input #CamelStream</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_to_output_stream"
              c:identifier="camel_data_wrapper_decode_to_output_stream"
              version="3.12">
        <doc xml:space="preserve">Asynchronously writes the decoded data content to @output_stream.

When the operation is finished, @callback will be called.  You can then
call camel_data_wrapper_decode_to_output_stream_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_to_output_stream_finish"
              c:identifier="camel_data_wrapper_decode_to_output_stream_finish"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with
camel_data_wrapper_decode_to_output_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_to_output_stream_sync"
              c:identifier="camel_data_wrapper_decode_to_output_stream_sync"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Writes the decoded data content to @output_stream.

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @output_stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_to_stream"
              c:identifier="camel_data_wrapper_decode_to_stream"
              version="3.0">
        <doc xml:space="preserve">Asynchronously writes the decoded data content to @stream.

When the operation is finished, @callback will be called.  You can then
call camel_data_wrapper_decode_to_stream_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream for decoded data to be written to</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_to_stream_finish"
              c:identifier="camel_data_wrapper_decode_to_stream_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_data_wrapper_decode_to_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_to_stream_sync"
              c:identifier="camel_data_wrapper_decode_to_stream_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Writes the decoded data content to @stream.

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream for decoded data to be written to</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_byte_array"
              c:identifier="camel_data_wrapper_get_byte_array"
              version="3.2">
        <doc xml:space="preserve">Returns the #GByteArray being used to hold the contents of @data_wrapper.

Note, it's up to the caller to use this in a thread-safe manner.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GByteArray for @data_wrapper</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_encoding"
              c:identifier="camel_data_wrapper_get_encoding"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An encoding (#CamelTransferEncoding) of the @data_wrapper</doc>
          <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mime_type"
              c:identifier="camel_data_wrapper_get_mime_type">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the MIME type which must be freed by the caller</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mime_type_field"
              c:identifier="camel_data_wrapper_get_mime_type_field">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parsed form of the data wrapper's MIME type</doc>
          <type name="ContentType" c:type="CamelContentType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_offline" c:identifier="camel_data_wrapper_is_offline">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @data_wrapper is "offline" (data stored
remotely) or not. Some optional code paths may choose to not
operate on offline data.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_encoding"
              c:identifier="camel_data_wrapper_set_encoding"
              version="3.24">
        <doc xml:space="preserve">Sets encoding (#CamelTransferEncoding) for the @data_wrapper.
It doesn't re-encode the content, if the encoding changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="encoding" transfer-ownership="none">
            <doc xml:space="preserve">an encoding to set</doc>
            <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mime_type"
              c:identifier="camel_data_wrapper_set_mime_type">
        <doc xml:space="preserve">This sets the data wrapper's MIME type.

It might fail, but you won't know. It will allow you to set
Content-Type parameters on the data wrapper, which are meaningless.
You should not be allowed to change the MIME type of a data wrapper
that contains data, or at least, if you do, it should invalidate the
data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="mime_type" transfer-ownership="none">
            <doc xml:space="preserve">a MIME type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mime_type_field"
              c:identifier="camel_data_wrapper_set_mime_type_field">
        <doc xml:space="preserve">This sets the data wrapper's MIME type. It adds its own reference
to @mime_type, if not %NULL.

It suffers from the same flaws as camel_data_wrapper_set_mime_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="mime_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelContentType</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_offline"
              c:identifier="camel_data_wrapper_set_offline"
              version="3.24">
        <doc xml:space="preserve">Sets whether the @data_wrapper is "offline". It applies only to this
concrete instance. See camel_data_wrapper_is_offline().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="offline" transfer-ownership="none">
            <doc xml:space="preserve">whether the @data_wrapper is "offline"</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_mime_type_field"
              c:identifier="camel_data_wrapper_take_mime_type_field"
              version="3.24">
        <doc xml:space="preserve">Sets mime-type filed to be @mime_type and consumes it, aka unlike
camel_data_wrapper_set_mime_type_field(), this doesn't add its own
reference to @mime_type.

It suffers from the same flaws as camel_data_wrapper_set_mime_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="mime_type"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelContentType</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_output_stream"
              c:identifier="camel_data_wrapper_write_to_output_stream"
              version="3.12">
        <doc xml:space="preserve">Asynchronously writes the content of @data_wrapper to @output_stream in
a machine-independent format appropriate for the data.

When the operation is finished, @callback will be called.  You can then
call camel_data_wrapper_write_to_output_stream_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_output_stream_finish"
              c:identifier="camel_data_wrapper_write_to_output_stream_finish"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with
camel_data_wrapper_write_to_output_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_output_stream_sync"
              c:identifier="camel_data_wrapper_write_to_output_stream_sync"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Writes the content of @data_wrapper to @output_stream in a
machine-independent format appropriate for the data.

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @output_stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_stream"
              c:identifier="camel_data_wrapper_write_to_stream"
              version="3.0">
        <doc xml:space="preserve">Asynchronously writes the content of @data_wrapper to @stream in a
machine-independent format appropriate for the data.  It should be
possible to construct an equivalent data wrapper object later by
passing this stream to camel_data_wrapper_construct_from_stream().

When the operation is finished, @callback will be called.  You can then
call camel_data_wrapper_write_to_stream_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream for writed data to be written to</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_stream_finish"
              c:identifier="camel_data_wrapper_write_to_stream_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_data_wrapper_write_to_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 or error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_stream_sync"
              c:identifier="camel_data_wrapper_write_to_stream_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Writes the content of @data_wrapper to @stream in a machine-independent
format appropriate for the data.  It should be possible to construct an
equivalent data wrapper object later by passing this stream to
camel_data_wrapper_construct_from_stream_sync().

&lt;note&gt;
  &lt;para&gt;
    This function may block even if the given output stream does not.
    For example, the content may have to be fetched across a network
    before it can be written to @stream.
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_wrapper" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream for output</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="DataWrapperPrivate" c:type="CamelDataWrapperPrivate*"/>
      </field>
    </class>
    <record name="DataWrapperClass"
            c:type="CamelDataWrapperClass"
            glib:is-gtype-struct-for="DataWrapper">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="set_mime_type">
        <callback name="set_mime_type">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="mime_type" transfer-ownership="none">
              <doc xml:space="preserve">a MIME type</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mime_type">
        <callback name="get_mime_type">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the MIME type which must be freed by the caller</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mime_type_field">
        <callback name="get_mime_type_field">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the parsed form of the data wrapper's MIME type</doc>
            <type name="ContentType" c:type="CamelContentType*"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_mime_type_field">
        <callback name="set_mime_type_field">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="mime_type"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #CamelContentType</doc>
              <type name="ContentType" c:type="CamelContentType*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_offline">
        <callback name="is_offline">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether @data_wrapper is "offline" (data stored
remotely) or not. Some optional code paths may choose to not
operate on offline data.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_to_stream_sync">
        <callback name="write_to_stream_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStream for output</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decode_to_stream_sync">
        <callback name="decode_to_stream_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStream for decoded data to be written to</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="construct_from_stream_sync">
        <callback name="construct_from_stream_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">an input #CamelStream</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_to_output_stream_sync">
        <callback name="write_to_output_stream_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="output_stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream</doc>
              <type name="Gio.OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decode_to_output_stream_sync">
        <callback name="decode_to_output_stream_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written, or %-1 on error</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="output_stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GOutputStream</doc>
              <type name="Gio.OutputStream" c:type="GOutputStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="construct_from_input_stream_sync">
        <callback name="construct_from_input_stream_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="data_wrapper" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
            <parameter name="input_stream" transfer-ownership="none">
              <doc xml:space="preserve">a #GInputStream</doc>
              <type name="Gio.InputStream" c:type="GInputStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DataWrapperPrivate"
            c:type="CamelDataWrapperPrivate"
            disguised="1">
    </record>
    <constant name="EAI_ADDRFAMILY" value="-9" c:type="EAI_ADDRFAMILY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_AGAIN" value="-3" c:type="EAI_AGAIN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_BADFLAGS" value="-1" c:type="EAI_BADFLAGS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_FAIL" value="-4" c:type="EAI_FAIL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_FAMILY" value="-6" c:type="EAI_FAMILY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_MEMORY" value="-10" c:type="EAI_MEMORY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_NODATA" value="-5" c:type="EAI_NODATA">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_NONAME" value="-2" c:type="EAI_NONAME">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_OVERFLOW" value="-12" c:type="EAI_OVERFLOW">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_SERVICE" value="-8" c:type="EAI_SERVICE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_SOCKTYPE" value="-7" c:type="EAI_SOCKTYPE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EAI_SYSTEM" value="-11" c:type="EAI_SYSTEM">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EDS_CAMEL_PROVIDER_DIR"
              value="EDS_CAMEL_PROVIDER_DIR"
              c:type="EDS_CAMEL_PROVIDER_DIR">
      <doc xml:space="preserve">This environment variable configures where the camel
provider modules are loaded from.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="Error"
                 version="2.32"
                 c:type="CamelError"
                 glib:error-domain="camel-error-quark">
      <member name="error_generic"
              value="0"
              c:identifier="CAMEL_ERROR_GENERIC">
        <doc xml:space="preserve">a generic (fallback) error code</doc>
      </member>
    </enumeration>
    <record name="FIRecord" c:type="CamelFIRecord" version="2.24">
      <doc xml:space="preserve">Values to store/load for single folder's #CamelFolderSummary structure.</doc>
      <field name="folder_name" writable="1">
        <doc xml:space="preserve">name of the folder</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="version" writable="1">
        <doc xml:space="preserve">version of the saved information</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">folder flags</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="nextuid" writable="1">
        <doc xml:space="preserve">next free uid</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="timestamp" writable="1">
        <doc xml:space="preserve">timestamp of the summary</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="saved_count" writable="1">
        <doc xml:space="preserve">count of all messages</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="unread_count" writable="1">
        <doc xml:space="preserve">count of unread messages</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="deleted_count" writable="1">
        <doc xml:space="preserve">count of deleted messages</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="junk_count" writable="1">
        <doc xml:space="preserve">count of junk messages</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="visible_count" writable="1">
        <doc xml:space="preserve">count of visible (not deleted and not junk) messages</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="jnd_count" writable="1">
        <doc xml:space="preserve">count of junk and not deleted messages</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="bdata" writable="1">
        <doc xml:space="preserve">custom data of the #CamelFolderSummary descendants</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
    </record>
    <constant name="FOLDER_TYPE_BIT" value="10" c:type="CAMEL_FOLDER_TYPE_BIT">
      <doc xml:space="preserve">The folder type bitshift value.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FOLDER_TYPE_MASK"
              value="64512"
              c:type="CAMEL_FOLDER_TYPE_MASK">
      <doc xml:space="preserve">The folder type mask value.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FOLD_MAX_SIZE" value="998" c:type="CAMEL_FOLD_MAX_SIZE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FOLD_SIZE" value="77" c:type="CAMEL_FOLD_SIZE">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="FetchHeadersType"
                 version="3.2"
                 glib:type-name="CamelFetchHeadersType"
                 glib:get-type="camel_fetch_headers_type_get_type"
                 c:type="CamelFetchHeadersType">
      <doc xml:space="preserve">Describes what headers to fetch when downloading message summaries.</doc>
      <member name="basic"
              value="0"
              c:identifier="CAMEL_FETCH_HEADERS_BASIC"
              glib:nick="basic">
        <doc xml:space="preserve">Fetch only basic headers (Date, From, To, Subject, etc.).</doc>
      </member>
      <member name="basic_and_mailing_list"
              value="1"
              c:identifier="CAMEL_FETCH_HEADERS_BASIC_AND_MAILING_LIST"
              glib:nick="basic-and-mailing-list">
        <doc xml:space="preserve">Fetch all basic headers and mailing list headers.</doc>
      </member>
      <member name="all"
              value="2"
              c:identifier="CAMEL_FETCH_HEADERS_ALL"
              glib:nick="all">
        <doc xml:space="preserve">Fetch all available message headers.</doc>
      </member>
    </enumeration>
    <enumeration name="FetchType" version="3.4" c:type="CamelFetchType">
      <member name="old_messages"
              value="0"
              c:identifier="CAMEL_FETCH_OLD_MESSAGES">
        <doc xml:space="preserve">fetch old messages</doc>
      </member>
      <member name="new_messages"
              value="1"
              c:identifier="CAMEL_FETCH_NEW_MESSAGES">
        <doc xml:space="preserve">fetch new messages</doc>
      </member>
    </enumeration>
    <class name="FilterDriver"
           c:symbol-prefix="filter_driver"
           c:type="CamelFilterDriver"
           parent="GObject.Object"
           glib:type-name="CamelFilterDriver"
           glib:get-type="camel_filter_driver_get_type"
           glib:type-struct="FilterDriverClass">
      <constructor name="new" c:identifier="camel_filter_driver_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new CamelFilterDriver object</doc>
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </return-value>
        <parameters>
          <parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_rule" c:identifier="camel_filter_driver_add_rule">
        <doc xml:space="preserve">Adds a new rule to set of rules to process by the filter driver.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the rule</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">a code (#CamelSExp) to execute to check whether the rule can be applied</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="action" transfer-ownership="none">
            <doc xml:space="preserve">an action code (#CamelSExp) to execute, when the @match evaluates to %TRUE</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_folder"
              c:identifier="camel_filter_driver_filter_folder"
              throws="1">
        <doc xml:space="preserve">Filters a folder based on rules defined in the FilterDriver
object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 if errors were encountered during filtering,
otherwise returns 0.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="driver" transfer-ownership="none">
            <doc xml:space="preserve">CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">CamelFolder to be filtered</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">UID cache (needed for POP folders)</doc>
            <type name="UIDCache" c:type="CamelUIDCache*"/>
          </parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">message uids to be filtered or NULL (as a
       shortcut to filter all messages)</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="remove" transfer-ownership="none">
            <doc xml:space="preserve">TRUE to mark filtered messages as deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_mbox"
              c:identifier="camel_filter_driver_filter_mbox"
              throws="1">
        <doc xml:space="preserve">Filters an mbox file based on rules defined in the FilterDriver
object. Is more efficient as it doesn't need to open the folder
through Camel directly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 if errors were encountered during filtering,
otherwise returns 0.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="driver" transfer-ownership="none">
            <doc xml:space="preserve">CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="mbox" transfer-ownership="none">
            <doc xml:space="preserve">mbox filename to be filtered</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="original_source_url"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">URI of the @mbox, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_message"
              c:identifier="camel_filter_driver_filter_message"
              throws="1">
        <doc xml:space="preserve">Filters a message based on rules defined in the FilterDriver
object. If the source folder (@source) and the uid (@uid) are
provided, the filter will operate on the CamelFolder (which in
certain cases is more efficient than using the default
camel_folder_append_message() function).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 if errors were encountered during filtering,
otherwise returns 0.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="driver" transfer-ownership="none">
            <doc xml:space="preserve">CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">message to filter or NULL</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">message info or NULL</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">message uid or NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">source folder or NULL</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="store_uid" transfer-ownership="none">
            <doc xml:space="preserve">UID of source store, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="original_store_uid" transfer-ownership="none">
            <doc xml:space="preserve">UID of source store (pre-movemail), or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="camel_filter_driver_flush" throws="1">
        <doc xml:space="preserve">Flush all of the only-once filter actions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="driver" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="log_info"
              c:identifier="camel_filter_driver_log_info"
              version="3.24"
              introspectable="0">
        <doc xml:space="preserve">Logs an informational message to a filter log. The function does
nothing when @driver is %NULL or when there is no log file being
set in @driver.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="driver"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #CamelFilterDriver, or %NULL</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a printf-like format to use for the informational log entry</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">arguments for @format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_rule_by_name"
              c:identifier="camel_filter_driver_remove_rule_by_name">
        <doc xml:space="preserve">Removes a rule by name, added by camel_filter_driver_add_rule().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the rule had been found and removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">rule name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_folder"
              c:identifier="camel_filter_driver_set_default_folder">
        <doc xml:space="preserve">Sets a default folder for the driver. The function adds
its own reference for the folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="def"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a default #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_folder_func"
              c:identifier="camel_filter_driver_set_folder_func"
              introspectable="0">
        <doc xml:space="preserve">Sets a callback (of type #CamelFilterGetFolderFunc) to get a folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="get_folder"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a callback to get a folder</doc>
            <type name="FilterGetFolderFunc"
                  c:type="CamelFilterGetFolderFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to @get_folder</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_logfile"
              c:identifier="camel_filter_driver_set_logfile">
        <doc xml:space="preserve">Sets a log file to use for logging.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="logfile"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a FILE handle where to write logging</doc>
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_play_sound_func"
              c:identifier="camel_filter_driver_set_play_sound_func">
        <doc xml:space="preserve">Sets a callback to call when a play of a sound is requested.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a callback to play a sound</doc>
            <type name="FilterPlaySoundFunc"
                  c:type="CamelFilterPlaySoundFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_shell_func"
              c:identifier="camel_filter_driver_set_shell_func">
        <doc xml:space="preserve">Sets a shell command callback, which is called when a shell command
execution is requested.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a shell command callback</doc>
            <type name="FilterShellFunc" c:type="CamelFilterShellFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_status_func"
              c:identifier="camel_filter_driver_set_status_func">
        <doc xml:space="preserve">Sets a status callback, which is used to report progress/status.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a callback to report progress</doc>
            <type name="FilterStatusFunc" c:type="CamelFilterStatusFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_system_beep_func"
              c:identifier="camel_filter_driver_set_system_beep_func">
        <doc xml:space="preserve">Sets a callback to use for system beep.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="d" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterDriver</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a system beep callback</doc>
            <type name="FilterSystemBeepFunc"
                  c:type="CamelFilterSystemBeepFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="FilterDriverPrivate" c:type="CamelFilterDriverPrivate*"/>
      </field>
    </class>
    <record name="FilterDriverClass"
            c:type="CamelFilterDriverClass"
            glib:is-gtype-struct-for="FilterDriver">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="FilterDriverPrivate"
            c:type="CamelFilterDriverPrivate"
            disguised="1">
    </record>
    <callback name="FilterGetFolderFunc"
              c:type="CamelFilterGetFolderFunc"
              introspectable="0"
              throws="1">
      <return-value>
        <type name="Folder" c:type="CamelFolder*"/>
      </return-value>
      <parameters>
        <parameter name="driver" transfer-ownership="none">
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="FilterInputStream"
           c:symbol-prefix="filter_input_stream"
           c:type="CamelFilterInputStream"
           parent="Gio.FilterInputStream"
           glib:type-name="CamelFilterInputStream"
           glib:get-type="camel_filter_input_stream_get_type"
           glib:type-struct="FilterInputStreamClass">
      <constructor name="new"
                   c:identifier="camel_filter_input_stream_new"
                   version="3.12">
        <doc xml:space="preserve">Creates a new filtered input stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GInputStream</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_filter"
              c:identifier="camel_filter_input_stream_get_filter"
              version="3.12">
        <doc xml:space="preserve">Gets the #CamelMimeFilter that is used by @filter_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMimeFilter</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterInputStream</doc>
            <type name="FilterInputStream" c:type="CamelFilterInputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="filter"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="MimeFilter"/>
      </property>
      <field name="parent">
        <type name="Gio.FilterInputStream" c:type="GFilterInputStream"/>
      </field>
      <field name="priv">
        <type name="FilterInputStreamPrivate"
              c:type="CamelFilterInputStreamPrivate*"/>
      </field>
    </class>
    <record name="FilterInputStreamClass"
            c:type="CamelFilterInputStreamClass"
            glib:is-gtype-struct-for="FilterInputStream">
      <field name="parent_class">
        <type name="Gio.FilterInputStreamClass"
              c:type="GFilterInputStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="FilterInputStreamPrivate"
            c:type="CamelFilterInputStreamPrivate"
            disguised="1">
    </record>
    <class name="FilterOutputStream"
           c:symbol-prefix="filter_output_stream"
           c:type="CamelFilterOutputStream"
           parent="Gio.FilterOutputStream"
           glib:type-name="CamelFilterOutputStream"
           glib:get-type="camel_filter_output_stream_get_type"
           glib:type-struct="FilterOutputStreamClass">
      <constructor name="new"
                   c:identifier="camel_filter_output_stream_new"
                   version="3.12">
        <doc xml:space="preserve">Creates a new filtered output stream for the @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GOutputStream</doc>
          <type name="Gio.OutputStream" c:type="GOutputStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GOutputStream</doc>
            <type name="Gio.OutputStream" c:type="GOutputStream*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_filter"
              c:identifier="camel_filter_output_stream_get_filter"
              version="3.12">
        <doc xml:space="preserve">Gets the #CamelMimeFilter that is used by @filter_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMimeFilter</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFilterOutputStream</doc>
            <type name="FilterOutputStream" c:type="CamelFilterOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="filter"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="MimeFilter"/>
      </property>
      <field name="parent">
        <type name="Gio.FilterOutputStream" c:type="GFilterOutputStream"/>
      </field>
      <field name="priv">
        <type name="FilterOutputStreamPrivate"
              c:type="CamelFilterOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="FilterOutputStreamClass"
            c:type="CamelFilterOutputStreamClass"
            glib:is-gtype-struct-for="FilterOutputStream">
      <field name="parent_class">
        <type name="Gio.FilterOutputStreamClass"
              c:type="GFilterOutputStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="FilterOutputStreamPrivate"
            c:type="CamelFilterOutputStreamPrivate"
            disguised="1">
    </record>
    <callback name="FilterPlaySoundFunc" c:type="CamelFilterPlaySoundFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="driver" transfer-ownership="none">
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </parameter>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="FilterSearchGetMessageFunc"
              c:type="CamelFilterSearchGetMessageFunc"
              introspectable="0"
              throws="1">
      <return-value>
        <type name="MimeMessage" c:type="CamelMimeMessage*"/>
      </return-value>
      <parameters>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="FilterShellFunc" c:type="CamelFilterShellFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="driver" transfer-ownership="none">
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </parameter>
        <parameter name="argc" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="FilterStatusFunc" c:type="CamelFilterStatusFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="driver" transfer-ownership="none">
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </parameter>
        <parameter name="status"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="camel_filter_status_t"/>
        </parameter>
        <parameter name="pc" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="desc" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="4">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="FilterSystemBeepFunc" c:type="CamelFilterSystemBeepFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="driver" transfer-ownership="none">
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Folder"
           c:symbol-prefix="folder"
           c:type="CamelFolder"
           parent="Object"
           abstract="1"
           glib:type-name="CamelFolder"
           glib:get-type="camel_folder_get_type"
           glib:type-struct="FolderClass">
      <function name="error_quark" c:identifier="camel_folder_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="threaded_messages_dump"
                c:identifier="camel_folder_threaded_messages_dump">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="c" transfer-ownership="none">
            <type name="FolderThreadNode" c:type="CamelFolderThreadNode*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="append_message_sync"
                      invoker="append_message_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Appends @message to @folder.  Only the flag and tag data from @info
are used.  If @info is %NULL, no flags or tags will be set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo with additional flags/etc to set on the
       new message, or %NULL</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
          <parameter name="appended_uid" transfer-ownership="none">
            <doc xml:space="preserve">if non-%NULL, the UID of the appended message will
               be returned here, if it is known</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="changed" invoker="changed" version="2.32">
        <doc xml:space="preserve">Emits the #CamelFolder::changed signal from an idle source on the
main loop.  The idle source's priority is #G_PRIORITY_LOW.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="changes" transfer-ownership="none">
            <doc xml:space="preserve">change information for @folder</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="cmp_uids" invoker="cmp_uids" version="2.28">
        <doc xml:space="preserve">Compares two uids. The return value meaning is the same as in any other compare function.

Note that the default compare function expects a decimal number at the beginning of a uid,
thus if provider uses different uid values, then it should subclass this function.</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid1" transfer-ownership="none">
            <doc xml:space="preserve">The first uid.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uid2" transfer-ownership="none">
            <doc xml:space="preserve">the second uid.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="count_by_expression"
                      invoker="count_by_expression"
                      version="2.26"
                      throws="1">
        <doc xml:space="preserve">Searches the folder for count of messages matching the given search expression.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an interger</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">a search expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="deleted">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="expunge_sync"
                      invoker="expunge_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Deletes messages which have been marked as "DELETED".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="free_summary" invoker="free_summary">
        <doc xml:space="preserve">Frees the summary array returned by camel_folder_get_summary().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the summary array to free</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="MessageInfo"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="free_uids" invoker="free_uids">
        <doc xml:space="preserve">Frees the array of UIDs returned by camel_folder_get_uids().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the array of uids to free</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="freeze" invoker="freeze">
        <doc xml:space="preserve">Freezes the folder so that a series of operation can be performed
without "folder_changed" signals being emitted.  When the folder is
later thawed with camel_folder_thaw(), the suppressed signals will
be emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_filename"
                      invoker="get_filename"
                      version="2.26"
                      throws="1">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a file name corresponding to a message
  with UID @uid. Free the returned string with g_free(), when
  no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_cached"
                      invoker="get_message_cached"
                      version="3.24">
        <doc xml:space="preserve">Gets the message corresponding to @message_uid from the @folder cache,
if available locally. This should not do any network I/O, only check
if message is already downloaded and return it quickly, not being
blocked by the folder's lock. Returning NULL is not considered as
an error, it just means that the message is still to-be-downloaded.

Note: This function is called automatically within camel_folder_get_message_sync().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a cached #CamelMimeMessage corresponding
   to the requested UID</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">the message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_count" invoker="get_message_count">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of messages in the folder, or %-1 if unknown</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_flags"
                      invoker="get_message_flags"
                      deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_folder_get_message_info() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #CamelMessageFlags that are set on the indicated
message.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_info" invoker="get_message_info">
        <doc xml:space="preserve">Retrieve the #CamelMessageInfo for the specified @uid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The summary information for the indicated message, or %NULL
  if the uid does not exist. Free the returned object with g_object_unref(),
  when done with it.</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the uid of a message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_sync"
                      invoker="get_message_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Gets the message corresponding to @message_uid from @folder.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMimeMessage corresponding to the requested UID</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">the message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_user_flag"
                      invoker="get_message_user_flag"
                      deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_get_user_flag() on the message
info directly</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the given user flag is set on the message or
%FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a user flag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_user_tag"
                      invoker="get_message_user_tag"
                      deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_get_user_tag() on the
#CamelMessageInfo directly.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the user tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a user tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_permanent_flags" invoker="get_permanent_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the set of #CamelMessageFlags that can be permanently
stored on a message between sessions. If it includes
#CAMEL_FLAG_USER, then user-defined flags will be remembered.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_quota_info_sync"
                      invoker="get_quota_info_sync"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Gets a list of known quotas for @folder.  Free the returned
#CamelFolderQuotaInfo struct with camel_folder_quota_info_free().

If quotas are not supported for @folder, the function returns %NULL
and sets @error to #G_IO_ERROR_NOT_SUPPORTED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelFolderQuotaInfo, or %NULL</doc>
          <type name="FolderQuotaInfo" c:type="CamelFolderQuotaInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_summary" invoker="get_summary">
        <doc xml:space="preserve">This returns the summary information for the folder. This array
should not be modified, and must be freed with
camel_folder_free_summary().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of UID-s of #CamelMessageInfo</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uids" invoker="get_uids">
        <doc xml:space="preserve">Get the list of UIDs available in a folder. This routine is useful
for finding what messages are available when the folder does not
support summaries. The returned array should not be modified, and
must be freed by passing it to camel_folder_free_uids().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a GPtrArray of UIDs
corresponding to the messages available in the folder</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_uncached_uids"
                      invoker="get_uncached_uids"
                      version="2.26"
                      throws="1">
        <doc xml:space="preserve">Returns the known-uncached uids from a list of uids. It may return uids
which are locally cached but should never filter out a uid which is not
locally cached. Free the result by called camel_folder_free_uids().
Frees the array of UIDs returned by camel_folder_get_uids().</doc>
        <return-value transfer-ownership="none">
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">the array of uids to filter down to uncached ones.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_search_capability">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_frozen" invoker="is_frozen">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the folder is frozen</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare_content_refresh"
                      invoker="prepare_content_refresh"
                      version="3.22">
        <doc xml:space="preserve">Lets the @folder know that it should refresh its content
the next time from fresh. This is useful for remote accounts,
to fully re-check the folder content against the server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="purge_message_cache_sync"
                      invoker="purge_message_cache_sync"
                      version="3.4"
                      throws="1">
        <doc xml:space="preserve">Delete the local cache of all messages between these uids.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="start_uid" transfer-ownership="none">
            <doc xml:space="preserve">the start message UID</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="end_uid" transfer-ownership="none">
            <doc xml:space="preserve">the end message UID</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="refresh_info_sync"
                      invoker="refresh_info_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Synchronizes a folder's summary with its backing store.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rename" invoker="rename">
        <doc xml:space="preserve">Marks @folder as renamed.

This also emits the #CamelFolder::renamed signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

NOTE: This is an internal function used by camel stores, no locking
is performed on the folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:space="preserve">new name for the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="renamed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="old_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="search_by_expression"
                      invoker="search_by_expression"
                      throws="1">
        <doc xml:space="preserve">Searches the folder for messages matching the given search expression.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GPtrArray of uids of
matching messages. The caller must free the list and each of the elements
when it is done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">a search expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="search_by_uids"
                      invoker="search_by_uids"
                      throws="1">
        <doc xml:space="preserve">Search a subset of uid's for an expression match.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GPtrArray of uids of
matching messages. The caller must free the list and each of the elements
when it is done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">search expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">array of uid's to match against.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="search_free" invoker="search_free">
        <doc xml:space="preserve">Free the result of a search as gotten by camel_folder_search() or
camel_folder_search_by_uids().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">search results to free</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_message_flags"
                      invoker="set_message_flags"
                      deprecated="1">
        <doc xml:space="preserve">Sets those flags specified by @mask to the values specified by @set
on the indicated message. (This may or may not persist after the
folder or store is closed. See camel_folder_get_permanent_flags())

E.g. to set the deleted flag and clear the draft flag, use
camel_folder_set_message_flags (folder, uid, CAMEL_MESSAGE_DELETED|CAMEL_MESSAGE_DRAFT, CAMEL_MESSAGE_DELETED);</doc>
        <doc-deprecated xml:space="preserve">Use camel_message_info_set_flags() on the message info directly
(when it works)</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the flags were changed or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a mask of #CamelMessageFlag bit-or values to use</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">the flags to ser, also bit-or of #CamelMessageFlag</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_message_user_flag"
                      invoker="set_message_user_flag"
                      deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_set_user_flag() on the
#CamelMessageInfo directly (when it works)

Sets the user flag specified by @name to the value specified by @value
on the indicated message. (This may or may not persist after the
folder or store is closed. See camel_folder_get_permanent_flags())</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the user flag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_message_user_tag"
                      invoker="set_message_user_tag"
                      deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_set_user_tag() on the
#CamelMessageInfo directly (when it works).

Sets the user tag specified by @name to the value specified by @value
on the indicated message. (This may or may not persist after the
folder or store is closed. See camel_folder_get_permanent_flags())</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the user tag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sort_uids" invoker="sort_uids" version="2.24">
        <doc xml:space="preserve">Sorts the array of UIDs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">array of uids</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronize_message_sync"
                      invoker="synchronize_message_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Ensure that a message identified by @message_uid has been synchronized in
@folder so that calling camel_folder_get_message() on it later will work
in offline mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronize_sync"
                      invoker="synchronize_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Synchronizes any changes that have been made to @folder to its
backing store, optionally expunging deleted messages as well.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expunge" transfer-ownership="none">
            <doc xml:space="preserve">whether to expunge after synchronizing</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="thaw" invoker="thaw">
        <doc xml:space="preserve">Thaws the folder and emits any pending folder_changed
signals.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transfer_messages_to_sync"
                      invoker="transfer_messages_to_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Copies or moves messages from one folder to another.  If the
@source and @destination folders have the same parent_store, this
may be more efficient than using camel_folder_append_message_sync().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uids" transfer-ownership="none">
            <doc xml:space="preserve">message UIDs in @source</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="delete_originals" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to delete the original messages</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="transferred_uids"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if non-%NULL, the UIDs of the
                   resulting messages in @destination will be stored here,
                   if known.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="append_message"
              c:identifier="camel_folder_append_message"
              version="3.0">
        <doc xml:space="preserve">Appends @message to @folder asynchronously.  Only the flag and tag data
from @info are used.  If @info is %NULL, no flags or tags will be set.

When the operation is finished, @callback will be called.  You can
then call camel_folder_append_message_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo with additional flags/etc to set on the
       new message, or %NULL</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_message_finish"
              c:identifier="camel_folder_append_message_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_append_message_finish().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="appended_uid" transfer-ownership="none">
            <doc xml:space="preserve">if non-%NULL, the UID of the appended message will
               be returned here, if it is known</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_message_sync"
              c:identifier="camel_folder_append_message_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Appends @message to @folder.  Only the flag and tag data from @info
are used.  If @info is %NULL, no flags or tags will be set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo with additional flags/etc to set on the
       new message, or %NULL</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
          <parameter name="appended_uid" transfer-ownership="none">
            <doc xml:space="preserve">if non-%NULL, the UID of the appended message will
               be returned here, if it is known</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="changed"
              c:identifier="camel_folder_changed"
              version="2.32">
        <doc xml:space="preserve">Emits the #CamelFolder::changed signal from an idle source on the
main loop.  The idle source's priority is #G_PRIORITY_LOW.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="changes" transfer-ownership="none">
            <doc xml:space="preserve">change information for @folder</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="cmp_uids"
              c:identifier="camel_folder_cmp_uids"
              version="2.28">
        <doc xml:space="preserve">Compares two uids. The return value meaning is the same as in any other compare function.

Note that the default compare function expects a decimal number at the beginning of a uid,
thus if provider uses different uid values, then it should subclass this function.</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid1" transfer-ownership="none">
            <doc xml:space="preserve">The first uid.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uid2" transfer-ownership="none">
            <doc xml:space="preserve">the second uid.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count_by_expression"
              c:identifier="camel_folder_count_by_expression"
              version="2.26"
              throws="1">
        <doc xml:space="preserve">Searches the folder for count of messages matching the given search expression.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an interger</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">a search expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="camel_folder_delete">
        <doc xml:space="preserve">Marks @folder as deleted and performs any required cleanup.

This also emits the #CamelFolder::deleted signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_description"
              c:identifier="camel_folder_dup_description"
              version="3.8">
        <doc xml:space="preserve">Thread-safe variation of camel_folder_get_description().
Use this function when accessing @folder from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelFolder:description</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_display_name"
              c:identifier="camel_folder_dup_display_name"
              version="3.8">
        <doc xml:space="preserve">Thread-safe variation of camel_folder_get_display_name().
Use this function when accessing @folder from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelFolder:display-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_full_name"
              c:identifier="camel_folder_dup_full_name"
              version="3.8">
        <doc xml:space="preserve">Thread-safe variation of camel_folder_get_full_name().
Use this function when accessing @folder from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelFolder:full-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="expunge" c:identifier="camel_folder_expunge" version="3.0">
        <doc xml:space="preserve">Asynchronously deletes messages which have been marked as "DELETED".

When the operation is finished, @callback will be called.  You can then
call camel_folder_expunge_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="expunge_finish"
              c:identifier="camel_folder_expunge_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_expunge().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="expunge_sync"
              c:identifier="camel_folder_expunge_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Deletes messages which have been marked as "DELETED".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_deep" c:identifier="camel_folder_free_deep">
        <doc xml:space="preserve">Frees the provided array and its contents. Used by #CamelFolder
subclasses as an implementation for free_uids when the provided
information was created explicitly by the corresponding get_ call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array of uids</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="free_shallow" c:identifier="camel_folder_free_shallow">
        <doc xml:space="preserve">Frees the provided array but not its contents. Used by #CamelFolder
subclasses as an implementation for free_uids or free_summary when
the returned array needs to be freed but its contents come from
"static" information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">an array of uids or #CamelMessageInfo</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="free_summary" c:identifier="camel_folder_free_summary">
        <doc xml:space="preserve">Frees the summary array returned by camel_folder_get_summary().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the summary array to free</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="MessageInfo"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="free_uids" c:identifier="camel_folder_free_uids">
        <doc xml:space="preserve">Frees the array of UIDs returned by camel_folder_get_uids().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the array of uids to free</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="freeze" c:identifier="camel_folder_freeze">
        <doc xml:space="preserve">Freezes the folder so that a series of operation can be performed
without "folder_changed" signals being emitted.  When the folder is
later thawed with camel_folder_thaw(), the suppressed signals will
be emitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_deleted_message_count"
              c:identifier="camel_folder_get_deleted_message_count">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of deleted messages in the folder, or %-1 if
unknown</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="camel_folder_get_description"
              version="2.32">
        <doc xml:space="preserve">Returns a description of the folder suitable for displaying to the user.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a description of the folder</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_display_name"
              c:identifier="camel_folder_get_display_name"
              version="3.2">
        <doc xml:space="preserve">Returns the display name for the folder.  The fully qualified name
can be obtained with camel_folder_get_full_name().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the display name of the folder</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename"
              c:identifier="camel_folder_get_filename"
              version="2.26"
              throws="1">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a file name corresponding to a message
  with UID @uid. Free the returned string with g_free(), when
  no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="camel_folder_get_flags"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Folder flags (bit-or of #CamelFolderFlags) of the @folder</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder_summary"
              c:identifier="camel_folder_get_folder_summary"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelFolderSummary of the folder</doc>
          <type name="FolderSummary" c:type="CamelFolderSummary*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frozen_count"
              c:identifier="camel_folder_get_frozen_count"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_full_name" c:identifier="camel_folder_get_full_name">
        <doc xml:space="preserve">Returns the fully qualified name of the folder.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the fully qualified name of the folder</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message"
              c:identifier="camel_folder_get_message"
              version="3.0">
        <doc xml:space="preserve">Asynchronously gets the message corresponding to @message_uid from @folder.

When the operation is finished, @callback will be called.  You can then
call camel_folder_get_message_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">the message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_cached"
              c:identifier="camel_folder_get_message_cached"
              version="3.24">
        <doc xml:space="preserve">Gets the message corresponding to @message_uid from the @folder cache,
if available locally. This should not do any network I/O, only check
if message is already downloaded and return it quickly, not being
blocked by the folder's lock. Returning NULL is not considered as
an error, it just means that the message is still to-be-downloaded.

Note: This function is called automatically within camel_folder_get_message_sync().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a cached #CamelMimeMessage corresponding
   to the requested UID</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">the message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_count"
              c:identifier="camel_folder_get_message_count">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of messages in the folder, or %-1 if unknown</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message_finish"
              c:identifier="camel_folder_get_message_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_get_message().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMimeMessage corresponding to the requested UID</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_flags"
              c:identifier="camel_folder_get_message_flags"
              deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_folder_get_message_info() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #CamelMessageFlags that are set on the indicated
message.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_info"
              c:identifier="camel_folder_get_message_info">
        <doc xml:space="preserve">Retrieve the #CamelMessageInfo for the specified @uid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The summary information for the indicated message, or %NULL
  if the uid does not exist. Free the returned object with g_object_unref(),
  when done with it.</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the uid of a message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_sync"
              c:identifier="camel_folder_get_message_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Gets the message corresponding to @message_uid from @folder.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMimeMessage corresponding to the requested UID</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">the message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_user_flag"
              c:identifier="camel_folder_get_message_user_flag"
              deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_get_user_flag() on the message
info directly</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the given user flag is set on the message or
%FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a user flag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_user_tag"
              c:identifier="camel_folder_get_message_user_tag"
              deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_get_user_tag() on the
#CamelMessageInfo directly.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the user tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of a user tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent_store"
              c:identifier="camel_folder_get_parent_store">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the parent #CamelStore of the folder</doc>
          <type name="gpointer" c:type="_CamelStore*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permanent_flags"
              c:identifier="camel_folder_get_permanent_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the set of #CamelMessageFlags that can be permanently
stored on a message between sessions. If it includes
#CAMEL_FLAG_USER, then user-defined flags will be remembered.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_quota_info"
              c:identifier="camel_folder_get_quota_info"
              version="3.2">
        <doc xml:space="preserve">Asynchronously gets a list of known quotas for @folder.

When the operation is finished, @callback will be called.  You can
then call camel_folder_get_quota_info_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_quota_info_finish"
              c:identifier="camel_folder_get_quota_info_finish"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_get_quota_info().
Free the returned #CamelFolderQuotaInfo struct with
camel_folder_quota_info_free().

If quotas are not supported for @folder, the function returns %NULL
and sets @error to #G_IO_ERROR_NOT_SUPPORTED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelFolderQuotaInfo, or %NULL</doc>
          <type name="FolderQuotaInfo" c:type="CamelFolderQuotaInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_quota_info_sync"
              c:identifier="camel_folder_get_quota_info_sync"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Gets a list of known quotas for @folder.  Free the returned
#CamelFolderQuotaInfo struct with camel_folder_quota_info_free().

If quotas are not supported for @folder, the function returns %NULL
and sets @error to #G_IO_ERROR_NOT_SUPPORTED.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelFolderQuotaInfo, or %NULL</doc>
          <type name="FolderQuotaInfo" c:type="CamelFolderQuotaInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_summary" c:identifier="camel_folder_get_summary">
        <doc xml:space="preserve">This returns the summary information for the folder. This array
should not be modified, and must be freed with
camel_folder_free_summary().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an array of UID-s of #CamelMessageInfo</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uids" c:identifier="camel_folder_get_uids">
        <doc xml:space="preserve">Get the list of UIDs available in a folder. This routine is useful
for finding what messages are available when the folder does not
support summaries. The returned array should not be modified, and
must be freed by passing it to camel_folder_free_uids().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a GPtrArray of UIDs
corresponding to the messages available in the folder</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uncached_uids"
              c:identifier="camel_folder_get_uncached_uids"
              version="2.26"
              throws="1">
        <doc xml:space="preserve">Returns the known-uncached uids from a list of uids. It may return uids
which are locally cached but should never filter out a uid which is not
locally cached. Free the result by called camel_folder_free_uids().
Frees the array of UIDs returned by camel_folder_get_uids().</doc>
        <return-value transfer-ownership="none">
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">the array of uids to filter down to uncached ones.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_unread_message_count"
              c:identifier="camel_folder_get_unread_message_count"
              deprecated="1">
        <doc-deprecated xml:space="preserve">use camel_object_get() instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of unread messages in the folder, or %-1 if
unknown</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_summary_capability"
              c:identifier="camel_folder_has_summary_capability">
        <doc xml:space="preserve">Get whether or not the folder has a summary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a summary is available or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_frozen" c:identifier="camel_folder_is_frozen">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not the folder is frozen</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock" c:identifier="camel_folder_lock" version="2.32">
        <doc xml:space="preserve">Locks @folder. Unlock it with camel_folder_unlock().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepare_content_refresh"
              c:identifier="camel_folder_prepare_content_refresh"
              version="3.22">
        <doc xml:space="preserve">Lets the @folder know that it should refresh its content
the next time from fresh. This is useful for remote accounts,
to fully re-check the folder content against the server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="purge_message_cache"
              c:identifier="camel_folder_purge_message_cache"
              version="3.4">
        <doc xml:space="preserve">Delete the local cache of all messages between these uids.

When the operation is finished, @callback will be called.  You can then
call camel_folder_purge_message_cache_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="start_uid" transfer-ownership="none">
            <doc xml:space="preserve">the start message UID</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="end_uid" transfer-ownership="none">
            <doc xml:space="preserve">the end message UID</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="purge_message_cache_finish"
              c:identifier="camel_folder_purge_message_cache_finish"
              version="3.4"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_purge_message_cache().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="purge_message_cache_sync"
              c:identifier="camel_folder_purge_message_cache_sync"
              version="3.4"
              throws="1">
        <doc xml:space="preserve">Delete the local cache of all messages between these uids.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="start_uid" transfer-ownership="none">
            <doc xml:space="preserve">the start message UID</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="end_uid" transfer-ownership="none">
            <doc xml:space="preserve">the end message UID</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh_info"
              c:identifier="camel_folder_refresh_info"
              version="3.2">
        <doc xml:space="preserve">Asynchronously synchronizes a folder's summary with its backing store.

When the operation is finished, @callback will be called.  You can then
call camel_folder_refresh_info_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh_info_finish"
              c:identifier="camel_folder_refresh_info_finish"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_refresh_info().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh_info_sync"
              c:identifier="camel_folder_refresh_info_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Synchronizes a folder's summary with its backing store.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename" c:identifier="camel_folder_rename">
        <doc xml:space="preserve">Marks @folder as renamed.

This also emits the #CamelFolder::renamed signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

NOTE: This is an internal function used by camel stores, no locking
is performed on the folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:space="preserve">new name for the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_by_expression"
              c:identifier="camel_folder_search_by_expression"
              throws="1">
        <doc xml:space="preserve">Searches the folder for messages matching the given search expression.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GPtrArray of uids of
matching messages. The caller must free the list and each of the elements
when it is done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">a search expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_by_uids"
              c:identifier="camel_folder_search_by_uids"
              throws="1">
        <doc xml:space="preserve">Search a subset of uid's for an expression match.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GPtrArray of uids of
matching messages. The caller must free the list and each of the elements
when it is done.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">search expression</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">array of uid's to match against.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_free" c:identifier="camel_folder_search_free">
        <doc xml:space="preserve">Free the result of a search as gotten by camel_folder_search() or
camel_folder_search_by_uids().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">search results to free</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_description"
              c:identifier="camel_folder_set_description"
              version="2.32">
        <doc xml:space="preserve">Sets a description of the folder suitable for displaying to the user.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">a description of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name"
              c:identifier="camel_folder_set_display_name"
              version="3.2">
        <doc xml:space="preserve">Sets the display name for the folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a display name for the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags"
              c:identifier="camel_folder_set_flags"
              version="3.24">
        <doc xml:space="preserve">Sets folder flags (bit-or of #CamelFolderFlags) for the @folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="folder_flags" transfer-ownership="none">
            <doc xml:space="preserve">flags (bit-or of #CamelFolderFlags) to set</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_full_name"
              c:identifier="camel_folder_set_full_name"
              version="2.32">
        <doc xml:space="preserve">Sets the fully qualified name of the folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="full_name" transfer-ownership="none">
            <doc xml:space="preserve">a fully qualified name for the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_lock_async"
              c:identifier="camel_folder_set_lock_async"
              version="2.30">
        <doc xml:space="preserve">Sets whether folder locking (camel_folder_lock() and camel_folder_unlock())
should be used. When set to %FALSE, the two functions do nothing and simply
return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="skip_folder_lock" transfer-ownership="none">
            <doc xml:space="preserve">a value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message_flags"
              c:identifier="camel_folder_set_message_flags"
              deprecated="1">
        <doc xml:space="preserve">Sets those flags specified by @mask to the values specified by @set
on the indicated message. (This may or may not persist after the
folder or store is closed. See camel_folder_get_permanent_flags())

E.g. to set the deleted flag and clear the draft flag, use
camel_folder_set_message_flags (folder, uid, CAMEL_MESSAGE_DELETED|CAMEL_MESSAGE_DRAFT, CAMEL_MESSAGE_DELETED);</doc>
        <doc-deprecated xml:space="preserve">Use camel_message_info_set_flags() on the message info directly
(when it works)</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the flags were changed or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">a mask of #CamelMessageFlag bit-or values to use</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">the flags to ser, also bit-or of #CamelMessageFlag</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message_user_flag"
              c:identifier="camel_folder_set_message_user_flag"
              deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_set_user_flag() on the
#CamelMessageInfo directly (when it works)

Sets the user flag specified by @name to the value specified by @value
on the indicated message. (This may or may not persist after the
folder or store is closed. See camel_folder_get_permanent_flags())</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the user flag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message_user_tag"
              c:identifier="camel_folder_set_message_user_tag"
              deprecated="1">
        <doc-deprecated xml:space="preserve">Use camel_message_info_set_user_tag() on the
#CamelMessageInfo directly (when it works).

Sets the user tag specified by @name to the value specified by @value
on the indicated message. (This may or may not persist after the
folder or store is closed. See camel_folder_get_permanent_flags())</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">the UID of a message in @folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the user tag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value to set it to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort_uids"
              c:identifier="camel_folder_sort_uids"
              version="2.24">
        <doc xml:space="preserve">Sorts the array of UIDs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">array of uids</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize"
              c:identifier="camel_folder_synchronize"
              version="3.0">
        <doc xml:space="preserve">Synchronizes any changes that have been made to @folder to its backing
store asynchronously, optionally expunging deleted messages as well.

When the operation is finished, @callback will be called.  You can then
call camel_folder_synchronize_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expunge" transfer-ownership="none">
            <doc xml:space="preserve">whether to expunge after synchronizing</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_finish"
              c:identifier="camel_folder_synchronize_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_synchronize().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on sucess, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_message"
              c:identifier="camel_folder_synchronize_message"
              version="3.0">
        <doc xml:space="preserve">Asynchronously ensure that a message identified by @message_uid has been
synchronized in @folder so that calling camel_folder_get_message() on it
later will work in offline mode.

When the operation is finished, @callback will be called.  You can then
call camel_folder_synchronize_message_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_message_finish"
              c:identifier="camel_folder_synchronize_message_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_synchronize_message().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_message_sync"
              c:identifier="camel_folder_synchronize_message_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Ensure that a message identified by @message_uid has been synchronized in
@folder so that calling camel_folder_get_message() on it later will work
in offline mode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_sync"
              c:identifier="camel_folder_synchronize_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Synchronizes any changes that have been made to @folder to its
backing store, optionally expunging deleted messages as well.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="expunge" transfer-ownership="none">
            <doc xml:space="preserve">whether to expunge after synchronizing</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_folder_summary"
              c:identifier="camel_folder_take_folder_summary"
              version="3.24">
        <doc xml:space="preserve">Sets a #CamelFolderSummary of the folder. It consumes the @summary.

This is supposed to be called only by the descendants of
the #CamelFolder and only at the construction time. Calling
this function twice yeilds to an error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="summary" transfer-ownership="full">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </parameter>
        </parameters>
      </method>
      <method name="thaw" c:identifier="camel_folder_thaw">
        <doc xml:space="preserve">Thaws the folder and emits any pending folder_changed
signals.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="transfer_messages_to"
              c:identifier="camel_folder_transfer_messages_to"
              version="3.0">
        <doc xml:space="preserve">Asynchronously copies or moves messages from one folder to another.
If the @source or @destination folders have the same parent store,
this may be more efficient than using camel_folder_append_message().

When the operation is finished, @callback will be called.  You can then
call camel_folder_transfer_messages_to_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uids" transfer-ownership="none">
            <doc xml:space="preserve">message UIDs in @source</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="delete_originals" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to delete the original messages</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="transfer_messages_to_finish"
              c:identifier="camel_folder_transfer_messages_to_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_folder_transfer_messages_to().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="transferred_uids"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if non-%NULL, the UIDs of the
                   resulting messages in @destination will be stored here,
                   if known.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="transfer_messages_to_sync"
              c:identifier="camel_folder_transfer_messages_to_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Copies or moves messages from one folder to another.  If the
@source and @destination folders have the same parent_store, this
may be more efficient than using camel_folder_append_message_sync().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the source #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
          <parameter name="message_uids" transfer-ownership="none">
            <doc xml:space="preserve">message UIDs in @source</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">the destination #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="delete_originals" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to delete the original messages</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="transferred_uids"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if non-%NULL, the UIDs of the
                   resulting messages in @destination will be stored here,
                   if known.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlock" c:identifier="camel_folder_unlock" version="2.32">
        <doc xml:space="preserve">Unlocks @folder, previously locked with camel_folder_lock().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="description"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The folder's description.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="display-name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The folder's display name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="full-name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The folder's fully qualified name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent-store"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #CamelStore to which the folder belongs.</doc>
        <type name="Store"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="CamelObject"/>
      </field>
      <field name="priv">
        <type name="FolderPrivate" c:type="CamelFolderPrivate*"/>
      </field>
      <glib:signal name="changed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="changes" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelFolderChangeInfo with the list of changes</doc>
            <type name="FolderChangeInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="deleted" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="renamed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the previous folder name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="FolderChangeInfo"
            c:type="CamelFolderChangeInfo"
            glib:type-name="CamelFolderChangeInfo"
            glib:get-type="camel_folder_change_info_get_type"
            c:symbol-prefix="folder_change_info">
      <field name="uid_added" writable="1">
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="uid_removed" writable="1">
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="uid_changed" writable="1">
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="uid_recent" writable="1">
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FolderChangeInfoPrivate"
              c:type="CamelFolderChangeInfoPrivate*"/>
      </field>
      <constructor name="new" c:identifier="camel_folder_change_info_new">
        <doc xml:space="preserve">Create a new folder change info structure.

Change info structures are not MT-SAFE and must be
locked for exclusive access externally.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelFolderChangeInfo</doc>
          <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
        </return-value>
      </constructor>
      <method name="add_source"
              c:identifier="camel_folder_change_info_add_source">
        <doc xml:space="preserve">Add a source uid for generating a changeset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_source_list"
              c:identifier="camel_folder_change_info_add_source_list">
        <doc xml:space="preserve">Add a list of source uid's for generating a changeset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="list" transfer-ownership="container">
            <doc xml:space="preserve">a list of uids</doc>
            <array name="GLib.PtrArray" c:type="const GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_uid" c:identifier="camel_folder_change_info_add_uid">
        <doc xml:space="preserve">Add a new uid to the changeinfo.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_update"
              c:identifier="camel_folder_change_info_add_update">
        <doc xml:space="preserve">Add a uid from the updated list, used to generate a changeset diff.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_update_list"
              c:identifier="camel_folder_change_info_add_update_list">
        <doc xml:space="preserve">Add a list of uid's from the updated list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="list" transfer-ownership="container">
            <doc xml:space="preserve">a list of uids</doc>
            <array name="GLib.PtrArray" c:type="const GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="build_diff"
              c:identifier="camel_folder_change_info_build_diff">
        <doc xml:space="preserve">Compare the source uid set to the updated uid set and generate the
differences into the added and removed lists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cat" c:identifier="camel_folder_change_info_cat">
        <doc xml:space="preserve">Concatenate one change info onto antoher. Can be used to copy them
too.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo to append to</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo to append from</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_uid"
              c:identifier="camel_folder_change_info_change_uid">
        <doc xml:space="preserve">Add a uid to the changed uid list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="changed" c:identifier="camel_folder_change_info_changed">
        <doc xml:space="preserve">Gets whether or not there have been any changes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the changeset contains any changes or %FALSE
otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="camel_folder_change_info_clear">
        <doc xml:space="preserve">Empty out the change info; called after changes have been
processed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="camel_folder_change_info_copy"
              version="3.24">
        <doc xml:space="preserve">Creates a copy of the @src.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Copy of the @src.</doc>
          <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo to make copy of</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="camel_folder_change_info_free">
        <doc xml:space="preserve">Free memory associated with the folder change info lists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_added_uids"
              c:identifier="camel_folder_change_info_get_added_uids"
              version="3.24">
        <doc xml:space="preserve">Returns an array of added messages UIDs. The returned array, the same as its content,
is owned by the @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An array of added UIDs.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_changed_uids"
              c:identifier="camel_folder_change_info_get_changed_uids"
              version="3.24">
        <doc xml:space="preserve">Returns an array of changed messages UIDs. The returned array, the same as its content,
is owned by the @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An array of changed UIDs.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_recent_uids"
              c:identifier="camel_folder_change_info_get_recent_uids"
              version="3.24">
        <doc xml:space="preserve">Returns an array of recent messages UIDs. The returned array, the same as its content,
is owned by the @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An array of recent UIDs.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_removed_uids"
              c:identifier="camel_folder_change_info_get_removed_uids"
              version="3.24">
        <doc xml:space="preserve">Returns an array of removed messages UIDs. The returned array, the same as its content,
is owned by the @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An array of removed UIDs.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="recent_uid"
              c:identifier="camel_folder_change_info_recent_uid">
        <doc xml:space="preserve">Add a recent uid to the changedinfo.
This will also add the uid to the uid_filter array for potential
filtering</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_uid"
              c:identifier="camel_folder_change_info_remove_uid">
        <doc xml:space="preserve">Add a uid to the removed uid list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderChangeInfo</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="FolderChangeInfoPrivate"
            c:type="CamelFolderChangeInfoPrivate"
            disguised="1">
    </record>
    <record name="FolderClass"
            c:type="CamelFolderClass"
            glib:is-gtype-struct-for="Folder">
      <field name="parent_class">
        <type name="ObjectClass" c:type="CamelObjectClass"/>
      </field>
      <field name="get_message_count">
        <callback name="get_message_count">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of messages in the folder, or %-1 if unknown</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_permanent_flags">
        <callback name="get_permanent_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the set of #CamelMessageFlags that can be permanently
stored on a message between sessions. If it includes
#CAMEL_FLAG_USER, then user-defined flags will be remembered.</doc>
            <type name="guint32" c:type="guint32"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_message_flags">
        <callback name="get_message_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the #CamelMessageFlags that are set on the indicated
message.</doc>
            <type name="guint32" c:type="guint32"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">the UID of a message in @folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_message_flags">
        <callback name="set_message_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the flags were changed or %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">the UID of a message in @folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="mask" transfer-ownership="none">
              <doc xml:space="preserve">a mask of #CamelMessageFlag bit-or values to use</doc>
              <type name="guint32" c:type="guint32"/>
            </parameter>
            <parameter name="set" transfer-ownership="none">
              <doc xml:space="preserve">the flags to ser, also bit-or of #CamelMessageFlag</doc>
              <type name="guint32" c:type="guint32"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_message_user_flag">
        <callback name="get_message_user_flag">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the given user flag is set on the message or
%FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">the UID of a message in @folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name of a user flag</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_message_user_flag">
        <callback name="set_message_user_flag">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">the UID of a message in @folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the user flag to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the value to set it to</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_message_user_tag">
        <callback name="get_message_user_tag">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the value of the user tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">the UID of a message in @folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name of a user tag</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_message_user_tag">
        <callback name="set_message_user_tag">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">the UID of a message in @folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the user tag to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">the value to set it to</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uids">
        <callback name="get_uids">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a GPtrArray of UIDs
corresponding to the messages available in the folder</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="free_uids">
        <callback name="free_uids">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="array" transfer-ownership="none">
              <doc xml:space="preserve">the array of uids to free</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="utf8"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cmp_uids">
        <callback name="cmp_uids">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid1" transfer-ownership="none">
              <doc xml:space="preserve">The first uid.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="uid2" transfer-ownership="none">
              <doc xml:space="preserve">the second uid.</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sort_uids">
        <callback name="sort_uids">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uids" transfer-ownership="none">
              <doc xml:space="preserve">array of uids</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="utf8"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_summary">
        <callback name="get_summary">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">an array of UID-s of #CamelMessageInfo</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="free_summary">
        <callback name="free_summary">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="array" transfer-ownership="none">
              <doc xml:space="preserve">the summary array to free</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="MessageInfo"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_search_capability">
        <callback name="has_search_capability">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="search_by_expression">
        <callback name="search_by_expression" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GPtrArray of uids of
matching messages. The caller must free the list and each of the elements
when it is done.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="expression" transfer-ownership="none">
              <doc xml:space="preserve">a search expression</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="search_by_uids">
        <callback name="search_by_uids" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GPtrArray of uids of
matching messages. The caller must free the list and each of the elements
when it is done.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="expression" transfer-ownership="none">
              <doc xml:space="preserve">search expression</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="uids" transfer-ownership="none">
              <doc xml:space="preserve">array of uid's to match against.</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="utf8"/>
              </array>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="search_free">
        <callback name="search_free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">search results to free</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="utf8"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_message_info">
        <callback name="get_message_info">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">The summary information for the indicated message, or %NULL
  if the uid does not exist. Free the returned object with g_object_unref(),
  when done with it.</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">the uid of a message</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_">
        <callback name="delete_">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rename">
        <callback name="rename">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="new_name" transfer-ownership="none">
              <doc xml:space="preserve">new name for the folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="freeze">
        <callback name="freeze">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="thaw">
        <callback name="thaw">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_frozen">
        <callback name="is_frozen">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether or not the folder is frozen</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="count_by_expression">
        <callback name="count_by_expression" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">an interger</doc>
            <type name="guint32" c:type="guint32"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="expression" transfer-ownership="none">
              <doc xml:space="preserve">a search expression</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GCancellable</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uncached_uids">
        <callback name="get_uncached_uids" throws="1">
          <return-value transfer-ownership="none">
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uids" transfer-ownership="none">
              <doc xml:space="preserve">the array of uids to filter down to uncached ones.</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="utf8"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_filename">
        <callback name="get_filename" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a file name corresponding to a message
  with UID @uid. Free the returned string with g_free(), when
  no longer needed.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">a message UID</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_message_cached">
        <callback name="get_message_cached">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a cached #CamelMimeMessage corresponding
   to the requested UID</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="message_uid" transfer-ownership="none">
              <doc xml:space="preserve">the message UID</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="append_message_sync">
        <callback name="append_message_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeMessage</doc>
              <type name="MimeMessage" c:type="CamelMimeMessage*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo with additional flags/etc to set on the
       new message, or %NULL</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="appended_uid" transfer-ownership="none">
              <doc xml:space="preserve">if non-%NULL, the UID of the appended message will
               be returned here, if it is known</doc>
              <type name="utf8" c:type="gchar**"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="expunge_sync">
        <callback name="expunge_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_message_sync">
        <callback name="get_message_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage corresponding to the requested UID</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="message_uid" transfer-ownership="none">
              <doc xml:space="preserve">the message UID</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_quota_info_sync">
        <callback name="get_quota_info_sync" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #CamelFolderQuotaInfo, or %NULL</doc>
            <type name="FolderQuotaInfo" c:type="CamelFolderQuotaInfo*"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="purge_message_cache_sync">
        <callback name="purge_message_cache_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="start_uid" transfer-ownership="none">
              <doc xml:space="preserve">the start message UID</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="end_uid" transfer-ownership="none">
              <doc xml:space="preserve">the end message UID</doc>
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="refresh_info_sync">
        <callback name="refresh_info_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronize_sync">
        <callback name="synchronize_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="expunge" transfer-ownership="none">
              <doc xml:space="preserve">whether to expunge after synchronizing</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronize_message_sync">
        <callback name="synchronize_message_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="message_uid" transfer-ownership="none">
              <doc xml:space="preserve">a message UID</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transfer_messages_to_sync">
        <callback name="transfer_messages_to_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="source" transfer-ownership="none">
              <doc xml:space="preserve">the source #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="message_uids" transfer-ownership="none">
              <doc xml:space="preserve">message UIDs in @source</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="utf8"/>
              </array>
            </parameter>
            <parameter name="destination" transfer-ownership="none">
              <doc xml:space="preserve">the destination #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="delete_originals" transfer-ownership="none">
              <doc xml:space="preserve">whether or not to delete the original messages</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="transferred_uids"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">if non-%NULL, the UIDs of the
                   resulting messages in @destination will be stored here,
                   if known.</doc>
              <array name="GLib.PtrArray" c:type="GPtrArray**">
                <type name="utf8"/>
              </array>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare_content_refresh">
        <callback name="prepare_content_refresh">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_methods">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="changed">
        <callback name="changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="changes" transfer-ownership="none">
              <doc xml:space="preserve">change information for @folder</doc>
              <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="deleted">
        <callback name="deleted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="renamed">
        <callback name="renamed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="old_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_signals">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="FolderError" version="2.32" c:type="CamelFolderError">
      <member name="invalid"
              value="0"
              c:identifier="CAMEL_FOLDER_ERROR_INVALID">
        <doc xml:space="preserve">a generic error about invalid operation with the folder</doc>
      </member>
      <member name="invalid_state"
              value="1"
              c:identifier="CAMEL_FOLDER_ERROR_INVALID_STATE">
        <doc xml:space="preserve">the folder is in an invalid state</doc>
      </member>
      <member name="non_empty"
              value="2"
              c:identifier="CAMEL_FOLDER_ERROR_NON_EMPTY">
        <doc xml:space="preserve">the folder is not empty</doc>
      </member>
      <member name="non_uid"
              value="3"
              c:identifier="CAMEL_FOLDER_ERROR_NON_UID">
        <doc xml:space="preserve">requested UID is not a UID</doc>
      </member>
      <member name="insufficient_permission"
              value="4"
              c:identifier="CAMEL_FOLDER_ERROR_INSUFFICIENT_PERMISSION">
        <doc xml:space="preserve">insufficient permissions for the requested operation</doc>
      </member>
      <member name="invalid_path"
              value="5"
              c:identifier="CAMEL_FOLDER_ERROR_INVALID_PATH">
        <doc xml:space="preserve">the folder path is invalid</doc>
      </member>
      <member name="invalid_uid"
              value="6"
              c:identifier="CAMEL_FOLDER_ERROR_INVALID_UID">
        <doc xml:space="preserve">requested UID is invalid/cannot be found</doc>
      </member>
      <member name="summary_invalid"
              value="7"
              c:identifier="CAMEL_FOLDER_ERROR_SUMMARY_INVALID">
        <doc xml:space="preserve">the folder's summary is invalid/broken</doc>
      </member>
    </enumeration>
    <bitfield name="FolderFlags"
              glib:type-name="CamelFolderFlags"
              glib:get-type="camel_folder_flags_get_type"
              c:type="CamelFolderFlags">
      <member name="has_summary_capability"
              value="1"
              c:identifier="CAMEL_FOLDER_HAS_SUMMARY_CAPABILITY"
              glib:nick="has-summary-capability">
      </member>
      <member name="filter_recent"
              value="4"
              c:identifier="CAMEL_FOLDER_FILTER_RECENT"
              glib:nick="filter-recent">
      </member>
      <member name="has_been_deleted"
              value="8"
              c:identifier="CAMEL_FOLDER_HAS_BEEN_DELETED"
              glib:nick="has-been-deleted">
      </member>
      <member name="is_trash"
              value="16"
              c:identifier="CAMEL_FOLDER_IS_TRASH"
              glib:nick="is-trash">
      </member>
      <member name="is_junk"
              value="32"
              c:identifier="CAMEL_FOLDER_IS_JUNK"
              glib:nick="is-junk">
      </member>
      <member name="filter_junk"
              value="64"
              c:identifier="CAMEL_FOLDER_FILTER_JUNK"
              glib:nick="filter-junk">
      </member>
    </bitfield>
    <record name="FolderInfo"
            c:type="CamelFolderInfo"
            glib:type-name="CamelFolderInfo"
            glib:get-type="camel_folder_info_get_type"
            c:symbol-prefix="folder_info">
      <field name="next" writable="1">
        <type name="gpointer" c:type="_CamelFolderInfo*"/>
      </field>
      <field name="parent" writable="1">
        <type name="gpointer" c:type="_CamelFolderInfo*"/>
      </field>
      <field name="child" writable="1">
        <type name="gpointer" c:type="_CamelFolderInfo*"/>
      </field>
      <field name="full_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="display_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="FolderInfoFlags" c:type="CamelFolderInfoFlags"/>
      </field>
      <field name="unread" writable="1">
        <type name="gint32" c:type="gint32"/>
      </field>
      <field name="total" writable="1">
        <type name="gint32" c:type="gint32"/>
      </field>
      <constructor name="new"
                   c:identifier="camel_folder_info_new"
                   version="2.22">
        <doc xml:space="preserve">Allocates a new #CamelFolderInfo instance.  Free it with
camel_folder_info_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelFolderInfo instance</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
      </constructor>
      <method name="clone" c:identifier="camel_folder_info_clone">
        <doc xml:space="preserve">Clones @fi recursively.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the cloned #CamelFolderInfo tree.</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderInfo</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="camel_folder_info_free">
        <doc xml:space="preserve">Frees @fi.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderInfo</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="build" c:identifier="camel_folder_info_build">
        <doc xml:space="preserve">This takes an array of folders and attaches them together according
to the hierarchy described by their full_names and @separator. If
@namespace_ is non-%NULL, then it will be ignored as a full_name
prefix, for purposes of comparison. If necessary,
camel_folder_info_build() will create additional #CamelFolderInfo with
%NULL urls to fill in gaps in the tree. The value of @short_names
is used in constructing the names of these intermediate folders.

NOTE: This is deprected, do not use this.
FIXME: remove this/move it to imap, which is the only user of it now.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the top level of the tree of linked folder info.</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <parameter name="folders" transfer-ownership="none">
            <doc xml:space="preserve">an array of #CamelFolderInfo</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="FolderInfo"/>
            </array>
          </parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">an ignorable prefix on the folder names</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="separator" transfer-ownership="none">
            <doc xml:space="preserve">the hieararchy separator character</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
          <parameter name="short_names" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the (short) name of a folder is the part after
the last @separator in the full name. %FALSE if it is the full name.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="FolderInfoFlags"
              glib:type-name="CamelFolderInfoFlags"
              glib:get-type="camel_folder_info_flags_get_type"
              c:type="CamelFolderInfoFlags">
      <doc xml:space="preserve">These flags are abstractions.  It's up to the CamelProvider to give
them suitable interpretations.  Use #CAMEL_FOLDER_TYPE_MASK to isolate
the folder's type.</doc>
      <member name="noselect"
              value="1"
              c:identifier="CAMEL_FOLDER_NOSELECT"
              glib:nick="noselect">
        <doc xml:space="preserve">The folder cannot contain messages.</doc>
      </member>
      <member name="noinferiors"
              value="2"
              c:identifier="CAMEL_FOLDER_NOINFERIORS"
              glib:nick="noinferiors">
        <doc xml:space="preserve">The folder cannot have child folders.</doc>
      </member>
      <member name="children"
              value="4"
              c:identifier="CAMEL_FOLDER_CHILDREN"
              glib:nick="children">
        <doc xml:space="preserve">The folder has children (not yet fully implemented).</doc>
      </member>
      <member name="nochildren"
              value="8"
              c:identifier="CAMEL_FOLDER_NOCHILDREN"
              glib:nick="nochildren">
        <doc xml:space="preserve">The folder does not have children (not yet fully implemented).</doc>
      </member>
      <member name="subscribed"
              value="16"
              c:identifier="CAMEL_FOLDER_SUBSCRIBED"
              glib:nick="subscribed">
        <doc xml:space="preserve">The folder is subscribed.</doc>
      </member>
      <member name="virtual"
              value="32"
              c:identifier="CAMEL_FOLDER_VIRTUAL"
              glib:nick="virtual">
        <doc xml:space="preserve">The folder is virtual.  Messages cannot be copied or moved to
   virtual folders since they are only queries of other folders.</doc>
      </member>
      <member name="system"
              value="64"
              c:identifier="CAMEL_FOLDER_SYSTEM"
              glib:nick="system">
        <doc xml:space="preserve">The folder is a built-in "system" folder.  System folders
   cannot be renamed or deleted.</doc>
      </member>
      <member name="vtrash"
              value="128"
              c:identifier="CAMEL_FOLDER_VTRASH"
              glib:nick="vtrash">
        <doc xml:space="preserve">The folder is a virtual trash folder.  It cannot be copied to,
   and can only be moved to if in an existing folder.</doc>
      </member>
      <member name="shared_to_me"
              value="256"
              c:identifier="CAMEL_FOLDER_SHARED_TO_ME"
              glib:nick="shared-to-me">
        <doc xml:space="preserve">A folder being shared by someone else.</doc>
      </member>
      <member name="shared_by_me"
              value="512"
              c:identifier="CAMEL_FOLDER_SHARED_BY_ME"
              glib:nick="shared-by-me">
        <doc xml:space="preserve">A folder being shared by the user.</doc>
      </member>
      <member name="type_normal"
              value="0"
              c:identifier="CAMEL_FOLDER_TYPE_NORMAL"
              glib:nick="type-normal">
        <doc xml:space="preserve">The folder is a normal folder.</doc>
      </member>
      <member name="type_inbox"
              value="1024"
              c:identifier="CAMEL_FOLDER_TYPE_INBOX"
              glib:nick="type-inbox">
        <doc xml:space="preserve">The folder is an inbox folder.</doc>
      </member>
      <member name="type_outbox"
              value="2048"
              c:identifier="CAMEL_FOLDER_TYPE_OUTBOX"
              glib:nick="type-outbox">
        <doc xml:space="preserve">The folder is an outbox folder.</doc>
      </member>
      <member name="type_trash"
              value="3072"
              c:identifier="CAMEL_FOLDER_TYPE_TRASH"
              glib:nick="type-trash">
        <doc xml:space="preserve">The folder shows deleted messages.</doc>
      </member>
      <member name="type_junk"
              value="4096"
              c:identifier="CAMEL_FOLDER_TYPE_JUNK"
              glib:nick="type-junk">
        <doc xml:space="preserve">The folder shows junk messages.</doc>
      </member>
      <member name="type_sent"
              value="5120"
              c:identifier="CAMEL_FOLDER_TYPE_SENT"
              glib:nick="type-sent">
        <doc xml:space="preserve">The folder shows sent messages.</doc>
      </member>
      <member name="type_contacts"
              value="6144"
              c:identifier="CAMEL_FOLDER_TYPE_CONTACTS"
              glib:nick="type-contacts">
        <doc xml:space="preserve">The folder contains contacts, instead of mail messages.</doc>
      </member>
      <member name="type_events"
              value="7168"
              c:identifier="CAMEL_FOLDER_TYPE_EVENTS"
              glib:nick="type-events">
        <doc xml:space="preserve">The folder contains calendar events, instead of mail messages.</doc>
      </member>
      <member name="type_memos"
              value="8192"
              c:identifier="CAMEL_FOLDER_TYPE_MEMOS"
              glib:nick="type-memos">
        <doc xml:space="preserve">The folder contains memos, instead of mail messages.</doc>
      </member>
      <member name="type_tasks"
              value="9216"
              c:identifier="CAMEL_FOLDER_TYPE_TASKS"
              glib:nick="type-tasks">
        <doc xml:space="preserve">The folder contains tasks, instead of mail messages.</doc>
      </member>
      <member name="type_all"
              value="10240"
              c:identifier="CAMEL_FOLDER_TYPE_ALL"
              glib:nick="type-all">
        <doc xml:space="preserve">This folder contains all the messages. Used by RFC 6154.</doc>
      </member>
      <member name="type_archive"
              value="11264"
              c:identifier="CAMEL_FOLDER_TYPE_ARCHIVE"
              glib:nick="type-archive">
        <doc xml:space="preserve">This folder contains archived messages. Used by RFC 6154.</doc>
      </member>
      <member name="type_drafts"
              value="12288"
              c:identifier="CAMEL_FOLDER_TYPE_DRAFTS"
              glib:nick="type-drafts">
        <doc xml:space="preserve">This folder contains drafts. Used by RFC 6154.</doc>
      </member>
      <member name="readonly"
              value="65536"
              c:identifier="CAMEL_FOLDER_READONLY"
              glib:nick="readonly">
        <doc xml:space="preserve">The folder is read only.</doc>
      </member>
      <member name="writeonly"
              value="131072"
              c:identifier="CAMEL_FOLDER_WRITEONLY"
              glib:nick="writeonly">
        <doc xml:space="preserve">The folder is write only.</doc>
      </member>
      <member name="flagged"
              value="262144"
              c:identifier="CAMEL_FOLDER_FLAGGED"
              glib:nick="flagged">
        <doc xml:space="preserve">This folder contains flagged messages. Some clients call this "starred". Used by RFC 6154.</doc>
      </member>
      <member name="flags_last"
              value="16777216"
              c:identifier="CAMEL_FOLDER_FLAGS_LAST"
              glib:nick="flags-last">
        <doc xml:space="preserve">The last define bit of the flags. The #CamelProvider can use this and
   upper bits to store its own flags.</doc>
      </member>
    </bitfield>
    <record name="FolderPrivate" c:type="CamelFolderPrivate" disguised="1">
    </record>
    <record name="FolderQuotaInfo"
            c:type="CamelFolderQuotaInfo"
            version="2.24"
            glib:type-name="CamelFolderQuotaInfo"
            glib:get-type="camel_folder_quota_info_get_type"
            c:symbol-prefix="folder_quota_info">
      <field name="name" writable="1">
        <doc xml:space="preserve">name, aka identification, of the quota type</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="used" writable="1">
        <doc xml:space="preserve">how many bytes is currently in use</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="total" writable="1">
        <doc xml:space="preserve">what is the maximum quota to use</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="next" writable="1">
        <doc xml:space="preserve">a reference to a follwing #CamelFolderQuotaInfo</doc>
        <type name="gpointer" c:type="_CamelFolderQuotaInfo*"/>
      </field>
      <constructor name="new"
                   c:identifier="camel_folder_quota_info_new"
                   version="2.24">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">newly allocated #CamelFolderQuotaInfo structure with
initialized values based on the parameters, with next member set to NULL.</doc>
          <type name="FolderQuotaInfo" c:type="CamelFolderQuotaInfo*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">Name of the quota.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="used" transfer-ownership="none">
            <doc xml:space="preserve">Current usage of the quota.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="total" transfer-ownership="none">
            <doc xml:space="preserve">Total available size of the quota.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="clone"
              c:identifier="camel_folder_quota_info_clone"
              version="2.24">
        <doc xml:space="preserve">Makes a copy of the given info and all next-s.</doc>
        <return-value transfer-ownership="full">
          <type name="FolderQuotaInfo" c:type="CamelFolderQuotaInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderQuotaInfo object to clone.</doc>
            <type name="FolderQuotaInfo" c:type="const CamelFolderQuotaInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="camel_folder_quota_info_free"
              version="2.24">
        <doc xml:space="preserve">Frees this and all next objects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderQuotaInfo object to free.</doc>
            <type name="FolderQuotaInfo" c:type="CamelFolderQuotaInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="FolderSearch"
           c:symbol-prefix="folder_search"
           c:type="CamelFolderSearch"
           parent="GObject.Object"
           glib:type-name="CamelFolderSearch"
           glib:get-type="camel_folder_search_get_type"
           glib:type-struct="FolderSearchClass">
      <constructor name="new" c:identifier="camel_folder_search_new">
        <doc xml:space="preserve">Create a new CamelFolderSearch object.

A CamelFolderSearch is a subclassable, extensible s-exp
evaluator which enforces a particular set of s-expressions.
Particular methods may be overriden by an implementation to
implement a search for any sort of backend.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new CamelFolderSearch intstance.</doc>
          <type name="FolderSearch" c:type="CamelFolderSearch*"/>
        </return-value>
      </constructor>
      <function name="util_add_months"
                c:identifier="camel_folder_search_util_add_months"
                version="3.2">
        <doc xml:space="preserve">Increases time @t by the given number of months (or decreases, if
@months is negative).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a new #time_t value</doc>
          <type name="glong" c:type="time_t"/>
        </return-value>
        <parameters>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">Initial time</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
          <parameter name="months" transfer-ownership="none">
            <doc xml:space="preserve">number of months to add or subtract</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <method name="count"
              c:identifier="camel_folder_search_count"
              version="2.26"
              throws="1">
        <doc xml:space="preserve">Run a search.  Search must have had Folder already set on it, and
it must implement summaries.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Number of messages that match the query.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="expr" transfer-ownership="none">
            <doc xml:space="preserve">a search expression to run</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free_result"
              c:identifier="camel_folder_search_free_result">
        <doc xml:space="preserve">Frees result of camel_folder_search_search() call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="result"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a result to free</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_message_info"
              c:identifier="camel_folder_search_get_current_message_info"
              version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the currently processing #CamelMessageInfo</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_current_summary"
              c:identifier="camel_folder_search_get_current_summary"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current summary, and array
  of message info UID-s to use.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder"
              c:identifier="camel_folder_search_get_folder"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelFolder for which the @search is currently running.</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_only_cached_messages"
              c:identifier="camel_folder_search_get_only_cached_messages"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether only cached messages can be searched. See
   camel_folder_search_set_only_cached_messages() for more
   information what it means.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_summary"
              c:identifier="camel_folder_search_get_summary"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A summary of UID-s of #CamelMessageInfo
  previously set by camel_folder_search_set_summary().</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_summary_empty"
              c:identifier="camel_folder_search_get_summary_empty">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the summary (as returned by camel_folder_search_get_summary()) is empty.
  It returns %FALSE when the summary is set and contains at least one item.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="search"
              c:identifier="camel_folder_search_search"
              throws="1">
        <doc xml:space="preserve">Run a search.  Search must have had Folder already set on it, and
it must implement summaries.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GPtrArray with matching UIDs,
   or %NULL on error. Use camel_folder_search_free_result() to free it when
   no longer needed.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="expr" transfer-ownership="none">
            <doc xml:space="preserve">a search expression to run</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">to search against, NULL for all uid's.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_body_index"
              c:identifier="camel_folder_search_set_body_index">
        <doc xml:space="preserve">Set the index representing the contents of all messages
in this folder.  If this is not set, then the folder implementation
should sub-class the CamelFolderSearch and provide its own
body-contains function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="body_index"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_current_message_info"
              c:identifier="camel_folder_search_set_current_message_info"
              version="3.24">
        <doc xml:space="preserve">Sets, or unsets, the @info as the currently processing #CamelMessageInfo.
The function adds its own reference to @info, if not %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_folder" c:identifier="camel_folder_search_set_folder">
        <doc xml:space="preserve">Set the folder attribute of the search. This can be used to perform a slow-search
when indexes and so forth are not available. Or for use by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_only_cached_messages"
              c:identifier="camel_folder_search_set_only_cached_messages"
              version="3.24">
        <doc xml:space="preserve">Sets whether only locally cached messages can be searched. The default
value is %FALSE, which means that when a message is required and it is
not available locally, then it is downloaded from the server, if possible.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="only_cached_messages" transfer-ownership="none">
            <doc xml:space="preserve">a value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_summary"
              c:identifier="camel_folder_search_set_summary">
        <doc xml:space="preserve">Set the array of summary objects representing the span of the search.

If this is not set, then a subclass must provide the functions
for searching headers and for the match-all operator.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">An array of UID-s of #CamelMessageInfo.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="take_current_message_info"
              c:identifier="camel_folder_search_take_current_message_info"
              version="3.24">
        <doc xml:space="preserve">Sets, or unsets, the @info as the currently processing #CamelMessageInfo.
Unlike camel_folder_search_set_current_message_info(), this function
assumes ownership of the @info, if not %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="search" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSearch</doc>
            <type name="FolderSearch" c:type="CamelFolderSearch*"/>
          </instance-parameter>
          <parameter name="info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="FolderSearchPrivate" c:type="CamelFolderSearchPrivate*"/>
      </field>
    </class>
    <record name="FolderSearchClass"
            c:type="CamelFolderSearchClass"
            glib:is-gtype-struct-for="FolderSearch">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="and_" introspectable="0">
        <callback name="and_" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpTerm" c:type="CamelSExpTerm**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="or_" introspectable="0">
        <callback name="or_" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpTerm" c:type="CamelSExpTerm**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="not_" introspectable="0">
        <callback name="not_" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lt" introspectable="0">
        <callback name="lt" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpTerm" c:type="CamelSExpTerm**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="gt" introspectable="0">
        <callback name="gt" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpTerm" c:type="CamelSExpTerm**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eq" introspectable="0">
        <callback name="eq" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpTerm" c:type="CamelSExpTerm**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="match_all" introspectable="0">
        <callback name="match_all" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpTerm" c:type="CamelSExpTerm**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="match_threads" introspectable="0">
        <callback name="match_threads" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpTerm" c:type="CamelSExpTerm**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="body_contains" introspectable="0">
        <callback name="body_contains" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="body_regex" introspectable="0">
        <callback name="body_regex" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_contains" introspectable="0">
        <callback name="header_contains" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_matches" introspectable="0">
        <callback name="header_matches" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_starts_with" introspectable="0">
        <callback name="header_starts_with" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_ends_with" introspectable="0">
        <callback name="header_ends_with" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_exists" introspectable="0">
        <callback name="header_exists" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_soundex" introspectable="0">
        <callback name="header_soundex" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_regex" introspectable="0">
        <callback name="header_regex" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="header_full_regex" introspectable="0">
        <callback name="header_full_regex" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="user_flag" introspectable="0">
        <callback name="user_flag" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="user_tag" introspectable="0">
        <callback name="user_tag" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="system_flag" introspectable="0">
        <callback name="system_flag" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_sent_date" introspectable="0">
        <callback name="get_sent_date" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_received_date" introspectable="0">
        <callback name="get_received_date" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_current_date" introspectable="0">
        <callback name="get_current_date" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_relative_months" introspectable="0">
        <callback name="get_relative_months" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_size" introspectable="0">
        <callback name="get_size" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="uid" introspectable="0">
        <callback name="uid" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="message_location" introspectable="0">
        <callback name="message_location" introspectable="0">
          <return-value>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </return-value>
          <parameters>
            <parameter name="sexp" transfer-ownership="none">
              <type name="SExp" c:type="CamelSExp*"/>
            </parameter>
            <parameter name="argc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="argv" transfer-ownership="none">
              <type name="SExpResult" c:type="CamelSExpResult**"/>
            </parameter>
            <parameter name="search" transfer-ownership="none">
              <type name="FolderSearch" c:type="CamelFolderSearch*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="FolderSearchPrivate"
            c:type="CamelFolderSearchPrivate"
            disguised="1">
    </record>
    <class name="FolderSummary"
           c:symbol-prefix="folder_summary"
           c:type="CamelFolderSummary"
           parent="GObject.Object"
           glib:type-name="CamelFolderSummary"
           glib:get-type="camel_folder_summary_get_type"
           glib:type-struct="FolderSummaryClass">
      <constructor name="new" c:identifier="camel_folder_summary_new">
        <doc xml:space="preserve">Create a new #CamelFolderSummary object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelFolderSummary object</doc>
          <type name="FolderSummary" c:type="CamelFolderSummary*"/>
        </return-value>
        <parameters>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">parent #CamelFolder object</doc>
            <type name="Folder" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="free_array"
                c:identifier="camel_folder_summary_free_array"
                version="3.4">
        <doc xml:space="preserve">Free's array and its elements returned from camel_folder_summary_get_array().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #GPtrArray returned from camel_folder_summary_get_array()</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="message_info_from_uid" introspectable="0">
        <return-value>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="message_info_new_from_headers" introspectable="0">
        <return-value>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="headers" transfer-ownership="none">
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="message_info_new_from_message" introspectable="0">
        <return-value>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="message_info_new_from_parser" introspectable="0">
        <return-value>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_uid_string" invoker="next_uid_string">
        <doc xml:space="preserve">Retrieve the next uid, but as a formatted string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the next uid as an unsigned integer string.
This string must be freed by the caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="summary_header_load">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="fir"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="_CamelFIRecord*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="summary_header_save" throws="1">
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="_CamelFIRecord*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add" c:identifier="camel_folder_summary_add">
        <doc xml:space="preserve">Adds a new @info record to the summary. If the @force_keep_uid is %FALSE,
then a new uid is automatically re-assigned by calling
camel_folder_summary_next_uid_string(). It's an error to to use
@force_keep_uid whe nthe @info has none set.

The @summary adds its own reference to @info, if needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
          <parameter name="force_keep_uid" transfer-ownership="none">
            <doc xml:space="preserve">whether to keep set UID of the @info</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_uid"
              c:identifier="camel_folder_summary_check_uid"
              version="2.24">
        <doc xml:space="preserve">Check if the uid is valid. This isn't very efficient, so it shouldn't be called iteratively.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if the uid is present in the summary or not  (%TRUE or %FALSE)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="camel_folder_summary_clear"
              throws="1">
        <doc xml:space="preserve">Empty the summary contents.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="count" c:identifier="camel_folder_summary_count">
        <doc xml:space="preserve">Get the number of summary items stored in this summary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items in the summary</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="camel_folder_summary_get" version="3.4">
        <doc xml:space="preserve">Retrieve a summary item by uid.

A referenced to the summary item is returned, which may be
ref'd or free'd as appropriate.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the summary item, or %NULL if the uid @uid is not available

See camel_folder_summary_get_info_flags().</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array"
              c:identifier="camel_folder_summary_get_array"
              version="3.4">
        <doc xml:space="preserve">Obtain a copy of the summary array.  This is done atomically,
so cannot contain empty entries.

Free with camel_folder_summary_free_array()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GPtrArray of uids</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_changed"
              c:identifier="camel_folder_summary_get_changed"
              version="2.24">
        <doc xml:space="preserve">Returns an array of changed UID-s. A UID is considered changed
when its corresponding CamelMesageInfo is 'dirty' or when it has
set the #CAMEL_MESSAGE_FOLDER_FLAGGED flag.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GPtrArray with changed UID-s.
   Free it with camel_folder_summary_free_array() when no longer needed.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_deleted_count"
              c:identifier="camel_folder_summary_get_deleted_count"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Count of deleted infos.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="camel_folder_summary_get_flags"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">flags of the @summary, a bit-or of #CamelFolderSummaryFlags</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder"
              c:identifier="camel_folder_summary_get_folder"
              version="3.4">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelFolder to which the summary if associated.</doc>
          <type name="gpointer" c:type="_CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hash"
              c:identifier="camel_folder_summary_get_hash"
              version="3.6">
        <doc xml:space="preserve">Returns hash of current stored 'uids' in summary, where key is 'uid'
from the string pool, and value is 1. The returned pointer should
be freed with g_hash_table_destroy().

Note: When searching for values always use uids from the string pool.</doc>
        <return-value transfer-ownership="container">
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="gint"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_index"
              c:identifier="camel_folder_summary_get_index"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelIndex used to index body content.</doc>
          <type name="Index" c:type="CamelIndex*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_info_flags"
              c:identifier="camel_folder_summary_get_info_flags"
              version="3.12">
        <doc xml:space="preserve">Retrieve CamelMessageInfo::flags for a message info with UID @uid.
This is much quicker than camel_folder_summary_get(), because it
doesn't require reading the message info from a disk.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the flags currently stored for message info with UID @uid,
         or (~0) on error</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_junk_count"
              c:identifier="camel_folder_summary_get_junk_count"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Count of junk infos.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_junk_not_deleted_count"
              c:identifier="camel_folder_summary_get_junk_not_deleted_count"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Count of junk and not deleted infos.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next_uid"
              c:identifier="camel_folder_summary_get_next_uid"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Next uid currently awaiting for assignment. The difference from
   camel_folder_summary_next_uid() is that this function returns actual
   value and doesn't increment it before returning.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_saved_count"
              c:identifier="camel_folder_summary_get_saved_count"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Count of saved infos.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timestamp"
              c:identifier="camel_folder_summary_get_timestamp"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">timestamp of the @summary, as set by the descendants</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_unread_count"
              c:identifier="camel_folder_summary_get_unread_count"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Count of unread infos.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_version"
              c:identifier="camel_folder_summary_get_version"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">version of the @summary</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_visible_count"
              c:identifier="camel_folder_summary_get_visible_count"
              version="3.4">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Count of visible (not junk and not deleted) infos.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="header_load"
              c:identifier="camel_folder_summary_header_load"
              version="3.24"
              throws="1">
        <doc xml:space="preserve">Loads a summary header for the @summary, which corresponds to @folder_name
provided by @store.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="store"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="gpointer" c:type="_CamelStore*"/>
          </parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">a folder name corresponding to @summary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="header_save"
              c:identifier="camel_folder_summary_header_save"
              version="3.24"
              throws="1">
        <doc xml:space="preserve">Saves summary header information into the disk. The function does
nothing, if the summary doesn't support save to disk.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="info_new_from_headers"
              c:identifier="camel_folder_summary_info_new_from_headers"
              version="3.24">
        <doc xml:space="preserve">Create a new info record from a header.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #CamelMessageInfo. Unref it
  with g_object_unref(), when done with it.</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="headers" transfer-ownership="none">
            <doc xml:space="preserve">rfc822 headers as #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="info_new_from_message"
              c:identifier="camel_folder_summary_info_new_from_message">
        <doc xml:space="preserve">Create a summary item from a message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #CamelMessageInfo. Unref it
  with g_object_unref(), when done with it.</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="info_new_from_parser"
              c:identifier="camel_folder_summary_info_new_from_parser">
        <doc xml:space="preserve">Create a new info record from a parser.  If the parser cannot
determine a uid, then none will be assigned.

If indexing is enabled, and the parser cannot determine a new uid, then
one is automatically assigned.

If indexing is enabled, then the content will be indexed based
on this new uid.  In this case, the message info MUST be
added using :add().

Once complete, the parser will be positioned at the end of
the message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #CamelMessageInfo. Unref it
  with g_object_unref(), when done with it.</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load"
              c:identifier="camel_folder_summary_load"
              version="3.24"
              throws="1">
        <doc xml:space="preserve">Loads the summary from the disk. It also saves any pending
changes first.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lock"
              c:identifier="camel_folder_summary_lock"
              version="2.32">
        <doc xml:space="preserve">Locks @summary. Unlock it with camel_folder_summary_unlock().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next_uid" c:identifier="camel_folder_summary_next_uid">
        <doc xml:space="preserve">Generate a new unique uid value as an integer.  This
may be used to create a unique sequence of numbers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the next unique uid value</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next_uid_string"
              c:identifier="camel_folder_summary_next_uid_string">
        <doc xml:space="preserve">Retrieve the next uid, but as a formatted string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the next uid as an unsigned integer string.
This string must be freed by the caller.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_loaded"
              c:identifier="camel_folder_summary_peek_loaded"
              version="2.26">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #CamelMessageInfo for the given @uid,
   if it's currently loaded in memoru, or %NULL otherwise. Unref the non-NULL
   info with g_object_unref() when done with it.</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID to look for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_fetch_all"
              c:identifier="camel_folder_summary_prepare_fetch_all"
              version="2.32"
              throws="1">
        <doc xml:space="preserve">Loads all infos into memory, if they are not yet and ensures
they will not be freed in next couple minutes. Call this function
before any mass operation or when all message infos will be needed,
for better performance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">#CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="camel_folder_summary_remove">
        <doc xml:space="preserve">Remove a specific @info record from the summary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @info was found and removed from the @summary.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_uid" c:identifier="camel_folder_summary_remove_uid">
        <doc xml:space="preserve">Remove a specific info record from the summary, by @uid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @uid was found and removed from the @summary.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_uids"
              c:identifier="camel_folder_summary_remove_uids"
              version="3.6">
        <doc xml:space="preserve">Remove a specific info record from the summary, by @uid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @uid was found and removed from the @summary.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">a GList of uids</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="replace_flags"
              c:identifier="camel_folder_summary_replace_flags"
              version="3.6">
        <doc xml:space="preserve">Updates internal counts based on the flags in @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether any count changed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save"
              c:identifier="camel_folder_summary_save"
              version="3.24"
              throws="1">
        <doc xml:space="preserve">Saves the content of the @summary to disk. It does nothing,
when the summary is not changed or when it doesn't support
permanent save.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_flags"
              c:identifier="camel_folder_summary_set_flags"
              version="3.24">
        <doc xml:space="preserve">Sets flags of the @summary, a bit-or of #CamelFolderSummaryFlags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags to set</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_index" c:identifier="camel_folder_summary_set_index">
        <doc xml:space="preserve">Set the index used to index body content.  If the index is %NULL, or
not set (the default), no indexing of body content will take place.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next_uid"
              c:identifier="camel_folder_summary_set_next_uid">
        <doc xml:space="preserve">Set the next minimum uid available.  This can be used to
ensure new uid's do not clash with existing uid's.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">The next minimum uid to assign.  To avoid clashing
uid's, set this to the uid of a given messages + 1.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timestamp"
              c:identifier="camel_folder_summary_set_timestamp"
              version="3.24">
        <doc xml:space="preserve">Sets timestamp of the @summary, provided by the descendants. This doesn't
change the 'dirty' flag of the @summary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:space="preserve">a timestamp to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_version"
              c:identifier="camel_folder_summary_set_version"
              version="3.24">
        <doc xml:space="preserve">Sets version of the @summary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">version to set</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="touch" c:identifier="camel_folder_summary_touch">
        <doc xml:space="preserve">Mark the summary as changed, so that a save will force it to be
written back to disk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unlock"
              c:identifier="camel_folder_summary_unlock"
              version="2.32">
        <doc xml:space="preserve">Unlocks @summary, previously locked with camel_folder_summary_lock().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="deleted-count" transfer-ownership="none">
        <doc xml:space="preserve">How many deleted infos is saved in a summary.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="folder"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #CamelFolder to which the folder summary belongs.</doc>
        <type name="Folder"/>
      </property>
      <property name="junk-count" transfer-ownership="none">
        <doc xml:space="preserve">How many junk infos is saved in a summary.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="junk-not-deleted-count" transfer-ownership="none">
        <doc xml:space="preserve">How many junk and not deleted infos is saved in a summary.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="saved-count" transfer-ownership="none">
        <doc xml:space="preserve">How many infos is saved in a summary.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="unread-count" transfer-ownership="none">
        <doc xml:space="preserve">How many unread infos is saved in a summary.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="visible-count" transfer-ownership="none">
        <doc xml:space="preserve">How many visible (not deleted and not junk) infos is saved in a summary.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="FolderSummaryPrivate" c:type="CamelFolderSummaryPrivate*"/>
      </field>
    </class>
    <record name="FolderSummaryClass"
            c:type="CamelFolderSummaryClass"
            glib:is-gtype-struct-for="FolderSummary">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="message_info_type">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="collate">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="sort_by">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="summary_header_load">
        <callback name="summary_header_load">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="FolderSummary" c:type="CamelFolderSummary*"/>
            </parameter>
            <parameter name="fir"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="_CamelFIRecord*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary_header_save">
        <callback name="summary_header_save" throws="1">
          <return-value transfer-ownership="none" nullable="1">
            <type name="gpointer" c:type="_CamelFIRecord*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="FolderSummary" c:type="CamelFolderSummary*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="message_info_new_from_headers" introspectable="0">
        <callback name="message_info_new_from_headers" introspectable="0">
          <return-value>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="FolderSummary" c:type="CamelFolderSummary*"/>
            </parameter>
            <parameter name="headers" transfer-ownership="none">
              <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="message_info_new_from_parser" introspectable="0">
        <callback name="message_info_new_from_parser" introspectable="0">
          <return-value>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="FolderSummary" c:type="CamelFolderSummary*"/>
            </parameter>
            <parameter name="parser" transfer-ownership="none">
              <type name="MimeParser" c:type="CamelMimeParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="message_info_new_from_message" introspectable="0">
        <callback name="message_info_new_from_message" introspectable="0">
          <return-value>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="FolderSummary" c:type="CamelFolderSummary*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="MimeMessage" c:type="CamelMimeMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="message_info_from_uid" introspectable="0">
        <callback name="message_info_from_uid" introspectable="0">
          <return-value>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="FolderSummary" c:type="CamelFolderSummary*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_uid_string">
        <callback name="next_uid_string">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the next uid as an unsigned integer string.
This string must be freed by the caller.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolderSummary object</doc>
              <type name="FolderSummary" c:type="CamelFolderSummary*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="FolderSummaryFlags" c:type="CamelFolderSummaryFlags">
      <member name="dirty" value="1" c:identifier="CAMEL_FOLDER_SUMMARY_DIRTY">
        <doc xml:space="preserve">There are changes in summary, which should be saved.</doc>
      </member>
      <member name="in_memory_only"
              value="2"
              c:identifier="CAMEL_FOLDER_SUMMARY_IN_MEMORY_ONLY">
        <doc xml:space="preserve">Summary with this flag doesn't use DB for storing its content,
   it is always created on the fly.</doc>
      </member>
    </bitfield>
    <record name="FolderSummaryPrivate"
            c:type="CamelFolderSummaryPrivate"
            disguised="1">
    </record>
    <record name="FolderThread"
            c:type="CamelFolderThread"
            glib:type-name="CamelFolderThread"
            glib:get-type="camel_folder_thread_messages_get_type"
            c:symbol-prefix="folder_thread_messages">
      <field name="refcount" writable="1" bits="31">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="subject" writable="1" bits="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="tree" writable="1">
        <type name="gpointer" c:type="_CamelFolderThreadNode*"/>
      </field>
      <field name="node_chunks" writable="1">
        <type name="MemChunk" c:type="CamelMemChunk*"/>
      </field>
      <field name="folder" writable="1">
        <type name="Folder" c:type="CamelFolder*"/>
      </field>
      <field name="summary" writable="1">
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="camel_folder_thread_messages_new">
        <doc xml:space="preserve">Thread a (subset) of the messages in a folder.  And sort the result
in summary order.

If @thread_subject is %TRUE, messages with
related subjects will also be threaded. The default behaviour is to
only thread based on message-id.

This function is probably to be removed soon.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A CamelFolderThread contianing a tree of CamelFolderThreadNode's
which represent the threaded structure of the messages.</doc>
          <type name="FolderThread" c:type="CamelFolderThread*"/>
        </return-value>
        <parameters>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">The subset of uid's to thread. If %NULL, then thread
   all UID-s in the @folder</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="thread_subject" transfer-ownership="none">
            <doc xml:space="preserve">thread based on subject also</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="apply" c:identifier="camel_folder_thread_messages_apply">
        <doc xml:space="preserve">Adds new @uids into the threaded tree.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderThread</doc>
            <type name="FolderThread" c:type="CamelFolderThread*"/>
          </instance-parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">a #GPtrArray array of UID-s</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="camel_folder_thread_messages_ref">
        <doc xml:space="preserve">Increase the reference of @thread</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the referenced @thread</doc>
          <type name="FolderThread" c:type="CamelFolderThread*"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderThread</doc>
            <type name="FolderThread" c:type="CamelFolderThread*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="camel_folder_thread_messages_unref">
        <doc xml:space="preserve">Free all memory associated with the thread descriptor @thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="thread" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderThread</doc>
            <type name="FolderThread" c:type="CamelFolderThread*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="FolderThreadNode" c:type="CamelFolderThreadNode">
      <field name="next" writable="1">
        <type name="gpointer" c:type="_CamelFolderThreadNode*"/>
      </field>
      <field name="parent" writable="1">
        <type name="gpointer" c:type="_CamelFolderThreadNode*"/>
      </field>
      <field name="child" writable="1">
        <type name="gpointer" c:type="_CamelFolderThreadNode*"/>
      </field>
      <field name="message" writable="1">
        <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
      </field>
      <field name="root_subject" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="order" writable="1" bits="31">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="re" writable="1" bits="1">
        <type name="guint32" c:type="guint32"/>
      </field>
    </record>
    <callback name="ForeachInfoData" c:type="CamelForeachInfoData">
      <doc xml:space="preserve">A callback prototype for camel_vee_data_cache_foreach_message_info_data()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mi_data" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelVeeMessageInfoData</doc>
          <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
        </parameter>
        <parameter name="subfolder" transfer-ownership="none">
          <doc xml:space="preserve">a #CameFolder which @mi_data references</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">custom user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="GpgContext"
           c:symbol-prefix="gpg_context"
           c:type="CamelGpgContext"
           parent="CipherContext"
           glib:type-name="CamelGpgContext"
           glib:get-type="camel_gpg_context_get_type"
           glib:type-struct="GpgContextClass">
      <constructor name="new" c:identifier="camel_gpg_context_new">
        <doc xml:space="preserve">Creates a new gpg cipher context object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new gpg cipher context object.</doc>
          <type name="CipherContext" c:type="CamelCipherContext*"/>
        </return-value>
        <parameters>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">session</doc>
            <type name="Session" c:type="CamelSession*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_always_trust"
              c:identifier="camel_gpg_context_get_always_trust"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelGpgContext</doc>
            <type name="GpgContext" c:type="CamelGpgContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prefer_inline"
              c:identifier="camel_gpg_context_get_prefer_inline"
              version="3.20">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether prefer inline sign/encrypt (%TRUE), or as multiparts (%FALSE)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelGpgContext</doc>
            <type name="GpgContext" c:type="CamelGpgContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_always_trust"
              c:identifier="camel_gpg_context_set_always_trust">
        <doc xml:space="preserve">Sets the @always_trust flag on the gpg context which is used for
encryption.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">gpg context</doc>
            <type name="GpgContext" c:type="CamelGpgContext*"/>
          </instance-parameter>
          <parameter name="always_trust" transfer-ownership="none">
            <doc xml:space="preserve">always trust flag</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefer_inline"
              c:identifier="camel_gpg_context_set_prefer_inline"
              version="3.20">
        <doc xml:space="preserve">Sets the @prefer_inline flag on the gpg context.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">gpg context</doc>
            <type name="GpgContext" c:type="CamelGpgContext*"/>
          </instance-parameter>
          <parameter name="prefer_inline" transfer-ownership="none">
            <doc xml:space="preserve">whether prefer inline sign/encrypt</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="always-trust"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="prefer-inline"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="CipherContext" c:type="CamelCipherContext"/>
      </field>
      <field name="priv">
        <type name="GpgContextPrivate" c:type="CamelGpgContextPrivate*"/>
      </field>
    </class>
    <record name="GpgContextClass"
            c:type="CamelGpgContextClass"
            glib:is-gtype-struct-for="GpgContext">
      <field name="parent_class">
        <type name="CipherContextClass" c:type="CamelCipherContextClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GpgContextPrivate"
            c:type="CamelGpgContextPrivate"
            disguised="1">
    </record>
    <class name="HTMLParser"
           c:symbol-prefix="html_parser"
           c:type="CamelHTMLParser"
           parent="GObject.Object"
           glib:type-name="CamelHTMLParser"
           glib:get-type="camel_html_parser_get_type"
           glib:type-struct="HTMLParserClass">
      <constructor name="new" c:identifier="camel_html_parser_new">
        <doc xml:space="preserve">Create a new CamelHTMLParser object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelHTMLParser object</doc>
          <type name="HTMLParser" c:type="CamelHTMLParser*"/>
        </return-value>
      </constructor>
      <method name="attr" c:identifier="camel_html_parser_attr">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hp" transfer-ownership="none">
            <type name="HTMLParser" c:type="CamelHTMLParser*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="attr_list" c:identifier="camel_html_parser_attr_list">
        <doc xml:space="preserve">Provides parsed array of values and attributes. Both arrays are
owned by the @hp.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GPtrArray of parsed attributes</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="hp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelHTMLParser</doc>
            <type name="HTMLParser" c:type="CamelHTMLParser*"/>
          </instance-parameter>
          <parameter name="values"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an output #GPtrArray with values, or %NULL</doc>
            <array name="GLib.PtrArray" c:type="const GPtrArray**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="left" c:identifier="camel_html_parser_left">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hp" transfer-ownership="none">
            <type name="HTMLParser" c:type="CamelHTMLParser*"/>
          </instance-parameter>
          <parameter name="lenp" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="camel_html_parser_set_data">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="hp" transfer-ownership="none">
            <type name="HTMLParser" c:type="CamelHTMLParser*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="last" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="step" c:identifier="camel_html_parser_step">
        <return-value transfer-ownership="none">
          <type name="HTMLParserState" c:type="CamelHTMLParserState"/>
        </return-value>
        <parameters>
          <instance-parameter name="hp" transfer-ownership="none">
            <type name="HTMLParser" c:type="CamelHTMLParser*"/>
          </instance-parameter>
          <parameter name="datap" transfer-ownership="none">
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="lenp" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="tag" c:identifier="camel_html_parser_tag">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="hp" transfer-ownership="none">
            <type name="HTMLParser" c:type="CamelHTMLParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="HTMLParserPrivate" c:type="CamelHTMLParserPrivate*"/>
      </field>
    </class>
    <record name="HTMLParserClass"
            c:type="CamelHTMLParserClass"
            glib:is-gtype-struct-for="HTMLParser">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="HTMLParserPrivate"
            c:type="CamelHTMLParserPrivate"
            disguised="1">
    </record>
    <enumeration name="HTMLParserState" c:type="CamelHTMLParserState">
      <member name="data" value="0" c:identifier="CAMEL_HTML_PARSER_DATA">
      </member>
      <member name="ent" value="1" c:identifier="CAMEL_HTML_PARSER_ENT">
      </member>
      <member name="element"
              value="2"
              c:identifier="CAMEL_HTML_PARSER_ELEMENT">
      </member>
      <member name="tag" value="3" c:identifier="CAMEL_HTML_PARSER_TAG">
      </member>
      <member name="dtdent" value="4" c:identifier="CAMEL_HTML_PARSER_DTDENT">
      </member>
      <member name="comment0"
              value="5"
              c:identifier="CAMEL_HTML_PARSER_COMMENT0">
      </member>
      <member name="comment"
              value="6"
              c:identifier="CAMEL_HTML_PARSER_COMMENT">
      </member>
      <member name="attr0" value="7" c:identifier="CAMEL_HTML_PARSER_ATTR0">
      </member>
      <member name="attr" value="8" c:identifier="CAMEL_HTML_PARSER_ATTR">
      </member>
      <member name="val0" value="9" c:identifier="CAMEL_HTML_PARSER_VAL0">
      </member>
      <member name="val" value="10" c:identifier="CAMEL_HTML_PARSER_VAL">
      </member>
      <member name="val_ent"
              value="11"
              c:identifier="CAMEL_HTML_PARSER_VAL_ENT">
      </member>
      <member name="eod" value="12" c:identifier="CAMEL_HTML_PARSER_EOD">
      </member>
      <member name="eof" value="13" c:identifier="CAMEL_HTML_PARSER_EOF">
      </member>
    </enumeration>
    <record name="HeaderAddress"
            c:type="CamelHeaderAddress"
            glib:type-name="CamelHeaderAddress"
            glib:get-type="camel_header_address_get_type"
            c:symbol-prefix="header_address">
      <field name="next" writable="1">
        <type name="gpointer" c:type="_camel_header_address*"/>
      </field>
      <field name="type" writable="1">
        <type name="HeaderAddressType" c:type="CamelHeaderAddressType"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <union name="v" c:type="v">
        <field name="addr" writable="1">
          <type name="utf8" c:type="gchar*"/>
        </field>
        <field name="members" writable="1">
          <type name="gpointer" c:type="_camel_header_address*"/>
        </field>
      </union>
      <field name="refcount" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="camel_header_address_new">
        <return-value transfer-ownership="full">
          <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
        </return-value>
      </constructor>
      <constructor name="new_group"
                   c:identifier="camel_header_address_new_group">
        <return-value transfer-ownership="full">
          <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_name"
                   c:identifier="camel_header_address_new_name">
        <return-value transfer-ownership="full">
          <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="addr" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_member" c:identifier="camel_header_address_add_member">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addrlist" transfer-ownership="none">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </instance-parameter>
          <parameter name="member" transfer-ownership="none">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="camel_header_address_ref">
        <return-value transfer-ownership="full">
          <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addrlist" transfer-ownership="none">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_addr" c:identifier="camel_header_address_set_addr">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addrlist" transfer-ownership="none">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </instance-parameter>
          <parameter name="addr" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_members"
              c:identifier="camel_header_address_set_members">
        <doc xml:space="preserve">TODO: Document me.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addrlist" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelHeaderAddress object</doc>
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress</doc>
            <array c:type="CamelHeaderAddress*">
              <type name="HeaderAddress" c:type="CamelHeaderAddress"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="camel_header_address_set_name">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addrlist" transfer-ownership="none">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="camel_header_address_unref">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addrlist" transfer-ownership="none">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="decode" c:identifier="camel_header_address_decode">
        <return-value transfer-ownership="full">
          <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="charset" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="fold" c:identifier="camel_header_address_fold">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="headerlen" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_append"
                c:identifier="camel_header_address_list_append">
        <doc xml:space="preserve">TODO: Document me.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="addrlistp" transfer-ownership="none">
            <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
            <array c:type="CamelHeaderAddress**">
              <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
            </array>
          </parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelHeaderAddress to add</doc>
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_append_list"
                c:identifier="camel_header_address_list_append_list">
        <doc xml:space="preserve">TODO: Document me.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="addrlistp" transfer-ownership="none">
            <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
            <array c:type="CamelHeaderAddress**">
              <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
            </array>
          </parameter>
          <parameter name="addrs" transfer-ownership="none">
            <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress to add</doc>
            <array c:type="CamelHeaderAddress**">
              <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="list_clear"
                c:identifier="camel_header_address_list_clear">
        <doc xml:space="preserve">TODO: Document me.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="addrlistp" transfer-ownership="none">
            <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
            <array c:type="CamelHeaderAddress**">
              <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="list_encode"
                c:identifier="camel_header_address_list_encode">
        <doc xml:space="preserve">TODO: Document me.</doc>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="addrlist" transfer-ownership="none">
            <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
            <array c:type="CamelHeaderAddress*">
              <type name="HeaderAddress" c:type="CamelHeaderAddress"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="list_format"
                c:identifier="camel_header_address_list_format">
        <doc xml:space="preserve">TODO: Document me.</doc>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="addrlist" transfer-ownership="none">
            <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
            <array c:type="CamelHeaderAddress*">
              <type name="HeaderAddress" c:type="CamelHeaderAddress"/>
            </array>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="HeaderAddressType" c:type="CamelHeaderAddressType">
      <member name="none" value="0" c:identifier="CAMEL_HEADER_ADDRESS_NONE">
      </member>
      <member name="name" value="1" c:identifier="CAMEL_HEADER_ADDRESS_NAME">
      </member>
      <member name="group" value="2" c:identifier="CAMEL_HEADER_ADDRESS_GROUP">
      </member>
    </enumeration>
    <record name="HeaderParam" c:type="CamelHeaderParam">
      <field name="next" writable="1">
        <type name="gpointer" c:type="_camel_header_param*"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <function name="list_decode"
                c:identifier="camel_header_param_list_decode">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">Decode list of parameters.
   Free with camel_header_param_list_free() when done with it.</doc>
          <type name="gpointer" c:type="_camel_header_param*"/>
        </return-value>
        <parameters>
          <parameter name="in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a header param value to decode</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_format"
                c:identifier="camel_header_param_list_format">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="_camel_header_param*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_format_append"
                c:identifier="camel_header_param_list_format_append">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="out" transfer-ownership="none">
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
          <parameter name="params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="_camel_header_param*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_free" c:identifier="camel_header_param_list_free">
        <doc xml:space="preserve">Free the list of params.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a list of params</doc>
            <type name="gpointer" c:type="_camel_header_param*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="INDEX_DELETED" value="1" c:type="CAMEL_INDEX_DELETED">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Index"
           c:symbol-prefix="index"
           c:type="CamelIndex"
           parent="GObject.Object"
           glib:type-name="CamelIndex"
           glib:get-type="camel_index_get_type"
           glib:type-struct="IndexClass">
      <virtual-method name="add_name" invoker="add_name">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexName with
   added given @name, or %NULL, when the @name could not be
   added.</doc>
          <type name="IndexName" c:type="CamelIndexName*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="compress" invoker="compress">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_name" invoker="delete_name">
        <doc xml:space="preserve">Deletes the given @name from @index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find" invoker="find">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexCursor object with
   the given @word, or %NULL, when not found</doc>
          <type name="IndexCursor" c:type="CamelIndexCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="word" transfer-ownership="none">
            <doc xml:space="preserve">a word to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="find_name" invoker="find_name">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexCursor with
   the given @name, or %NULL&lt; when not found.</doc>
          <type name="IndexCursor" c:type="CamelIndexCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_name" invoker="has_name">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rename" invoker="rename">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sync" invoker="sync">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="words" invoker="words">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexCursor containing
   all words of the @index, or %NULL, when there are none</doc>
          <type name="IndexCursor" c:type="CamelIndexCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write_name" invoker="write_name">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="idn" transfer-ownership="none">
            <type name="IndexName" c:type="CamelIndexName*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_name" c:identifier="camel_index_add_name">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexName with
   added given @name, or %NULL, when the @name could not be
   added.</doc>
          <type name="IndexName" c:type="CamelIndexName*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="compress" c:identifier="camel_index_compress">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="construct" c:identifier="camel_index_construct">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete" c:identifier="camel_index_delete">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="delete_name" c:identifier="camel_index_delete_name">
        <doc xml:space="preserve">Deletes the given @name from @index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find" c:identifier="camel_index_find">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexCursor object with
   the given @word, or %NULL, when not found</doc>
          <type name="IndexCursor" c:type="CamelIndexCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="word" transfer-ownership="none">
            <doc xml:space="preserve">a word to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_name" c:identifier="camel_index_find_name">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexCursor with
   the given @name, or %NULL&lt; when not found.</doc>
          <type name="IndexCursor" c:type="CamelIndexCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_name" c:identifier="camel_index_has_name">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename" c:identifier="camel_index_rename">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_normalize"
              c:identifier="camel_index_set_normalize"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">normalization function</doc>
            <type name="IndexNorm" c:type="CamelIndexNorm"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync" c:identifier="camel_index_sync">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="words" c:identifier="camel_index_words">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelIndexCursor containing
   all words of the @index, or %NULL, when there are none</doc>
          <type name="IndexCursor" c:type="CamelIndexCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_name" c:identifier="camel_index_write_name">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="index" transfer-ownership="none">
            <type name="Index" c:type="CamelIndex*"/>
          </instance-parameter>
          <parameter name="idn" transfer-ownership="none">
            <type name="IndexName" c:type="CamelIndexName*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="IndexPrivate" c:type="CamelIndexPrivate*"/>
      </field>
      <field name="path">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="version">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="flags">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="state">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="normalize">
        <type name="IndexNorm" c:type="CamelIndexNorm"/>
      </field>
      <field name="normalize_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="IndexClass"
            c:type="CamelIndexClass"
            glib:is-gtype-struct-for="Index">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="sync">
        <callback name="sync">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="compress">
        <callback name="compress">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_">
        <callback name="delete_">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rename">
        <callback name="rename">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_name">
        <callback name="has_name">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_name">
        <callback name="add_name">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">a #CamelIndexName with
   added given @name, or %NULL, when the @name could not be
   added.</doc>
            <type name="IndexName" c:type="CamelIndexName*"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelIndex</doc>
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">a name to add</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write_name">
        <callback name="write_name">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
            <parameter name="idn" transfer-ownership="none">
              <type name="IndexName" c:type="CamelIndexName*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find_name">
        <callback name="find_name">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">a #CamelIndexCursor with
   the given @name, or %NULL&lt; when not found.</doc>
            <type name="IndexCursor" c:type="CamelIndexCursor*"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelIndex</doc>
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">a name to find</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_name">
        <callback name="delete_name">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelIndex</doc>
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">a name to delete</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="find">
        <callback name="find">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">a #CamelIndexCursor object with
   the given @word, or %NULL, when not found</doc>
            <type name="IndexCursor" c:type="CamelIndexCursor*"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelIndex</doc>
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
            <parameter name="word" transfer-ownership="none">
              <doc xml:space="preserve">a word to find</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="words">
        <callback name="words">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">a #CamelIndexCursor containing
   all words of the @index, or %NULL, when there are none</doc>
            <type name="IndexCursor" c:type="CamelIndexCursor*"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelIndex</doc>
              <type name="Index" c:type="CamelIndex*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="IndexCursor"
           c:symbol-prefix="index_cursor"
           c:type="CamelIndexCursor"
           parent="GObject.Object"
           glib:type-name="CamelIndexCursor"
           glib:get-type="camel_index_cursor_get_type"
           glib:type-struct="IndexCursorClass">
      <virtual-method name="next" invoker="next">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="idc" transfer-ownership="none">
            <type name="IndexCursor" c:type="CamelIndexCursor*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="next" c:identifier="camel_index_cursor_next">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="idc" transfer-ownership="none">
            <type name="IndexCursor" c:type="CamelIndexCursor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="IndexCursorPrivate" c:type="CamelIndexCursorPrivate*"/>
      </field>
      <field name="index">
        <type name="Index" c:type="CamelIndex*"/>
      </field>
    </class>
    <record name="IndexCursorClass"
            c:type="CamelIndexCursorClass"
            glib:is-gtype-struct-for="IndexCursor">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="next">
        <callback name="next">
          <return-value transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="idc" transfer-ownership="none">
              <type name="IndexCursor" c:type="CamelIndexCursor*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="IndexCursorPrivate"
            c:type="CamelIndexCursorPrivate"
            disguised="1">
    </record>
    <class name="IndexName"
           c:symbol-prefix="index_name"
           c:type="CamelIndexName"
           parent="GObject.Object"
           glib:type-name="CamelIndexName"
           glib:get-type="camel_index_name_get_type"
           glib:type-struct="IndexNameClass">
      <virtual-method name="add_buffer" invoker="add_buffer">
        <return-value transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="name" transfer-ownership="none">
            <type name="IndexName" c:type="CamelIndexName*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_word" invoker="add_word">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="name" transfer-ownership="none">
            <type name="IndexName" c:type="CamelIndexName*"/>
          </instance-parameter>
          <parameter name="word" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_buffer" c:identifier="camel_index_name_add_buffer">
        <return-value transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="name" transfer-ownership="none">
            <type name="IndexName" c:type="CamelIndexName*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_word" c:identifier="camel_index_name_add_word">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="name" transfer-ownership="none">
            <type name="IndexName" c:type="CamelIndexName*"/>
          </instance-parameter>
          <parameter name="word" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="IndexNamePrivate" c:type="CamelIndexNamePrivate*"/>
      </field>
      <field name="index">
        <type name="Index" c:type="CamelIndex*"/>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="buffer">
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="words">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
    </class>
    <record name="IndexNameClass"
            c:type="CamelIndexNameClass"
            glib:is-gtype-struct-for="IndexName">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_word">
        <callback name="add_word">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="name" transfer-ownership="none">
              <type name="IndexName" c:type="CamelIndexName*"/>
            </parameter>
            <parameter name="word" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_buffer">
        <callback name="add_buffer">
          <return-value transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </return-value>
          <parameters>
            <parameter name="name" transfer-ownership="none">
              <type name="IndexName" c:type="CamelIndexName*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="IndexNamePrivate"
            c:type="CamelIndexNamePrivate"
            disguised="1">
    </record>
    <callback name="IndexNorm" c:type="CamelIndexNorm">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="index" transfer-ownership="none">
          <type name="Index" c:type="CamelIndex*"/>
        </parameter>
        <parameter name="word" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="IndexPrivate" c:type="CamelIndexPrivate" disguised="1">
    </record>
    <class name="InternetAddress"
           c:symbol-prefix="internet_address"
           c:type="CamelInternetAddress"
           parent="Address"
           glib:type-name="CamelInternetAddress"
           glib:get-type="camel_internet_address_get_type"
           glib:type-struct="InternetAddressClass">
      <constructor name="new" c:identifier="camel_internet_address_new">
        <doc xml:space="preserve">Create a new #CamelInternetAddress object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelInternetAddress object</doc>
          <type name="InternetAddress" c:type="CamelInternetAddress*"/>
        </return-value>
      </constructor>
      <function name="encode_address"
                c:identifier="camel_internet_address_encode_address">
        <doc xml:space="preserve">Encode a single address ready for internet usage.  Header folding
as per rfc822 is also performed, based on the length *@len.  If @len
is %NULL, then no folding will occur.

Note: The value at *@in will be updated based on any linewrapping done</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded address</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the line the address is being appended to</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the unencoded real name associated with the address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">the routing address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="format_address"
                c:identifier="camel_internet_address_format_address">
        <doc xml:space="preserve">Function to format a single address, suitable for display.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a nicely formatted string containing the rfc822 address</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name, quotes may be stripped from it</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">an rfc822 routing address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add" c:identifier="camel_internet_address_add">
        <doc xml:space="preserve">Add a new internet address to @addr.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index of added entry</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress object</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name associated with the new address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">routing address associated with the new address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_ascii_domains"
              c:identifier="camel_internet_address_ensure_ascii_domains"
              version="3.16">
        <doc xml:space="preserve">Ensures that all email address' domains will be ASCII encoded,
which means that any non-ASCII letters will be properly encoded.
This includes IDN (Internationalized Domain Names).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="find_address"
              c:identifier="camel_internet_address_find_address">
        <doc xml:space="preserve">Find an address by address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index of the address, or %-1 if not found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress object</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">address to lookup</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="namep"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve">holder for the matching name, or %NULL, if not required.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_name" c:identifier="camel_internet_address_find_name">
        <doc xml:space="preserve">Find address by real name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the index of the address matching the name, or %-1 if no
match was found</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress object</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name to lookup</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="addressp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve">holder for address part, or %NULL, if not required.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="camel_internet_address_get">
        <doc xml:space="preserve">Get the address at @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if such an address exists, or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress object</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">address's array index</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="namep"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve">holder for the returned name, or %NULL, if not required.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="addressp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve">holder for the returned address, or %NULL, if not required.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Address" c:type="CamelAddress"/>
      </field>
      <field name="priv">
        <type name="InternetAddressPrivate"
              c:type="CamelInternetAddressPrivate*"/>
      </field>
    </class>
    <record name="InternetAddressClass"
            c:type="CamelInternetAddressClass"
            glib:is-gtype-struct-for="InternetAddress">
      <field name="parent_class">
        <type name="AddressClass" c:type="CamelAddressClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="InternetAddressPrivate"
            c:type="CamelInternetAddressPrivate"
            disguised="1">
    </record>
    <interface name="JunkFilter"
               c:symbol-prefix="junk_filter"
               c:type="CamelJunkFilter"
               version="3.2"
               glib:type-name="CamelJunkFilter"
               glib:get-type="camel_junk_filter_get_type"
               glib:type-struct="JunkFilterInterface">
      <virtual-method name="classify"
                      invoker="classify"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Classifies @message as junk, not junk or inconclusive.

If an error occurs, the function sets @error and returns
%CAMEL_JUNK_STATUS_ERROR.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the junk status determined by @junk_filter</doc>
          <type name="JunkStatus" c:type="CamelJunkStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="learn_junk"
                      invoker="learn_junk"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Instructs @junk_filter to classify @message as junk.  If using an
adaptive junk filtering algorithm, explicitly marking @message as
junk will influence the classification of future messages.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @message was successfully classified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="learn_not_junk"
                      invoker="learn_not_junk"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Instructs @junk_filter to classify @message as not junk.  If using an
adaptive junk filtering algorithm, explicitly marking @message as not
junk will influence the classification of future messages.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @message was successfully classified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronize"
                      invoker="synchronize"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Instructs @junk_filter to flush any in-memory caches to disk, if
applicable.  When filtering many messages, delaying this step until
all messages have been classified can improve performance.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @junk_filter was successfully synchronized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="classify"
              c:identifier="camel_junk_filter_classify"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Classifies @message as junk, not junk or inconclusive.

If an error occurs, the function sets @error and returns
%CAMEL_JUNK_STATUS_ERROR.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the junk status determined by @junk_filter</doc>
          <type name="JunkStatus" c:type="CamelJunkStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="learn_junk"
              c:identifier="camel_junk_filter_learn_junk"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Instructs @junk_filter to classify @message as junk.  If using an
adaptive junk filtering algorithm, explicitly marking @message as
junk will influence the classification of future messages.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @message was successfully classified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="learn_not_junk"
              c:identifier="camel_junk_filter_learn_not_junk"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Instructs @junk_filter to classify @message as not junk.  If using an
adaptive junk filtering algorithm, explicitly marking @message as not
junk will influence the classification of future messages.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @message was successfully classified</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize"
              c:identifier="camel_junk_filter_synchronize"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Instructs @junk_filter to flush any in-memory caches to disk, if
applicable.  When filtering many messages, delaying this step until
all messages have been classified can improve performance.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @junk_filter was successfully synchronized</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="JunkFilterInterface"
            c:type="CamelJunkFilterInterface"
            glib:is-gtype-struct-for="JunkFilter">
      <field name="parent_interface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="classify">
        <callback name="classify" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the junk status determined by @junk_filter</doc>
            <type name="JunkStatus" c:type="CamelJunkStatus"/>
          </return-value>
          <parameters>
            <parameter name="junk_filter" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelJunkFilter</doc>
              <type name="JunkFilter" c:type="CamelJunkFilter*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeMessage</doc>
              <type name="MimeMessage" c:type="CamelMimeMessage*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="learn_junk">
        <callback name="learn_junk" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @message was successfully classified</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="junk_filter" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelJunkFilter</doc>
              <type name="JunkFilter" c:type="CamelJunkFilter*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeMessage</doc>
              <type name="MimeMessage" c:type="CamelMimeMessage*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="learn_not_junk">
        <callback name="learn_not_junk" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @message was successfully classified</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="junk_filter" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelJunkFilter</doc>
              <type name="JunkFilter" c:type="CamelJunkFilter*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeMessage</doc>
              <type name="MimeMessage" c:type="CamelMimeMessage*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronize">
        <callback name="synchronize" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @junk_filter was successfully synchronized</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="junk_filter" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelJunkFilter</doc>
              <type name="JunkFilter" c:type="CamelJunkFilter*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="JunkStatus"
                 glib:type-name="CamelJunkStatus"
                 glib:get-type="camel_junk_status_get_type"
                 c:type="CamelJunkStatus">
      <doc xml:space="preserve">These are result codes used when passing messages through a junk filter.</doc>
      <member name="error"
              value="0"
              c:identifier="CAMEL_JUNK_STATUS_ERROR"
              glib:nick="error">
        <doc xml:space="preserve">An error occurred while invoking the junk filter.</doc>
      </member>
      <member name="inconclusive"
              value="1"
              c:identifier="CAMEL_JUNK_STATUS_INCONCLUSIVE"
              glib:nick="inconclusive">
        <doc xml:space="preserve">The junk filter could not determine whether the message is junk.</doc>
      </member>
      <member name="message_is_junk"
              value="2"
              c:identifier="CAMEL_JUNK_STATUS_MESSAGE_IS_JUNK"
              glib:nick="message-is-junk">
        <doc xml:space="preserve">The junk filter believes the message is junk.</doc>
      </member>
      <member name="message_is_not_junk"
              value="3"
              c:identifier="CAMEL_JUNK_STATUS_MESSAGE_IS_NOT_JUNK"
              glib:nick="message-is-not-junk">
        <doc xml:space="preserve">The junk filter believes the message is not junk.</doc>
      </member>
    </enumeration>
    <constant name="KEY_TABLE_MAX_KEY"
              value="128"
              c:type="CAMEL_KEY_TABLE_MAX_KEY">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="KeyBlock" c:type="CamelKeyBlock">
      <field name="next" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
      <field name="used" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <union name="u" c:type="u">
        <field name="keys" writable="1">
          <array zero-terminated="0" c:type="_CamelKeyKey" fixed-size="0">
            <type name="gpointer" c:type="_CamelKeyKey"/>
          </array>
        </field>
        <field name="keydata" writable="1">
          <array zero-terminated="0" c:type="gchar" fixed-size="1016">
            <type name="gchar" c:type="gchar"/>
          </array>
        </field>
      </union>
    </record>
    <class name="KeyFile"
           c:symbol-prefix="key_file"
           c:type="CamelKeyFile"
           parent="GObject.Object"
           glib:type-name="CamelKeyFile"
           glib:get-type="camel_key_file_get_type"
           glib:type-struct="KeyFileClass">
      <constructor name="new" c:identifier="camel_key_file_new">
        <doc xml:space="preserve">Create a new key file.  A linked list of record blocks.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new key file, or NULL if the file could not
be opened/created/initialised.</doc>
          <type name="KeyFile" c:type="CamelKeyFile*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a filename with path of the #CamelKeyFile to create</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">open flags</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:space="preserve">Version string (header) of file.  Currently
written but not checked.</doc>
            <type name="gchar" c:type="const gchar"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="delete" c:identifier="camel_key_file_delete">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="kf" transfer-ownership="none">
            <type name="KeyFile" c:type="CamelKeyFile*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="camel_key_file_read">
        <doc xml:space="preserve">Read the next block of data from the key file.  Returns the number of
records.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on io error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="kf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelKeyFile</doc>
            <type name="KeyFile" c:type="CamelKeyFile*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">The record pointer.  This will be set to the next record pointer on success.</doc>
            <type name="_block_t" c:type="camel_block_t*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">Number of records read, if != NULL.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="records"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Records, allocated, must be freed with g_free, if != NULL.</doc>
            <array length="1" zero-terminated="0" c:type="camel_key_t**">
              <type name="_key_t" c:type="camel_key_t*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="rename" c:identifier="camel_key_file_rename">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="kf" transfer-ownership="none">
            <type name="KeyFile" c:type="CamelKeyFile*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="camel_key_file_write">
        <doc xml:space="preserve">Write a new list of records to the key file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on io error.  The key file will remain unchanged.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="kf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelKeyFile</doc>
            <type name="KeyFile" c:type="CamelKeyFile*"/>
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">a #camel_block_t</doc>
            <type name="_block_t" c:type="camel_block_t*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">how many @records to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="records" transfer-ownership="none">
            <doc xml:space="preserve">an array of #camel_key_t to write</doc>
            <array length="1" zero-terminated="0" c:type="camel_key_t*">
              <type name="_key_t" c:type="camel_key_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="KeyFilePrivate" c:type="CamelKeyFilePrivate*"/>
      </field>
    </class>
    <record name="KeyFileClass"
            c:type="CamelKeyFileClass"
            glib:is-gtype-struct-for="KeyFile">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="KeyFilePrivate" c:type="CamelKeyFilePrivate" disguised="1">
    </record>
    <record name="KeyRootBlock" c:type="CamelKeyRootBlock">
      <field name="first" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
      <field name="last" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
      <field name="free" writable="1">
        <type name="_key_t" c:type="camel_key_t"/>
      </field>
    </record>
    <class name="KeyTable"
           c:symbol-prefix="key_table"
           c:type="CamelKeyTable"
           parent="GObject.Object"
           glib:type-name="CamelKeyTable"
           glib:get-type="camel_key_table_get_type"
           glib:type-struct="KeyTableClass">
      <constructor name="new" c:identifier="camel_key_table_new">
        <return-value transfer-ownership="full">
          <type name="KeyTable" c:type="CamelKeyTable*"/>
        </return-value>
        <parameters>
          <parameter name="bs" transfer-ownership="none">
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </parameter>
          <parameter name="root" transfer-ownership="none">
            <type name="_block_t" c:type="camel_block_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="camel_key_table_add">
        <return-value transfer-ownership="none">
          <type name="_key_t" c:type="camel_key_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="ki" transfer-ownership="none">
            <type name="KeyTable" c:type="CamelKeyTable*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="_block_t" c:type="camel_block_t"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="camel_key_table_lookup">
        <return-value transfer-ownership="none">
          <type name="_block_t" c:type="camel_block_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="ki" transfer-ownership="none">
            <type name="KeyTable" c:type="CamelKeyTable*"/>
          </instance-parameter>
          <parameter name="keyid" transfer-ownership="none">
            <type name="_key_t" c:type="camel_key_t"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="camel_key_table_next">
        <return-value transfer-ownership="none">
          <type name="_key_t" c:type="camel_key_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="ki" transfer-ownership="none">
            <type name="KeyTable" c:type="CamelKeyTable*"/>
          </instance-parameter>
          <parameter name="next" transfer-ownership="none">
            <type name="_key_t" c:type="camel_key_t"/>
          </parameter>
          <parameter name="keyp" transfer-ownership="none">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="flagsp" transfer-ownership="none">
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="datap" transfer-ownership="none">
            <type name="_block_t" c:type="camel_block_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="camel_key_table_set_data">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="ki" transfer-ownership="none">
            <type name="KeyTable" c:type="CamelKeyTable*"/>
          </instance-parameter>
          <parameter name="keyid" transfer-ownership="none">
            <type name="_key_t" c:type="camel_key_t"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="_block_t" c:type="camel_block_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags" c:identifier="camel_key_table_set_flags">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="ki" transfer-ownership="none">
            <type name="KeyTable" c:type="CamelKeyTable*"/>
          </instance-parameter>
          <parameter name="keyid" transfer-ownership="none">
            <type name="_key_t" c:type="camel_key_t"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync" c:identifier="camel_key_table_sync">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="ki" transfer-ownership="none">
            <type name="KeyTable" c:type="CamelKeyTable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="KeyTablePrivate" c:type="CamelKeyTablePrivate*"/>
      </field>
    </class>
    <record name="KeyTableClass"
            c:type="CamelKeyTableClass"
            glib:is-gtype-struct-for="KeyTable">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="KeyTablePrivate" c:type="CamelKeyTablePrivate" disguised="1">
    </record>
    <constant name="LOCK_DELAY" value="2" c:type="CAMEL_LOCK_DELAY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LOCK_DOT_DELAY" value="2" c:type="CAMEL_LOCK_DOT_DELAY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LOCK_DOT_RETRY" value="5" c:type="CAMEL_LOCK_DOT_RETRY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LOCK_DOT_STALE" value="60" c:type="CAMEL_LOCK_DOT_STALE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="LOCK_RETRY" value="5" c:type="CAMEL_LOCK_RETRY">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="LocalSettings"
           c:symbol-prefix="local_settings"
           c:type="CamelLocalSettings"
           version="3.4"
           parent="StoreSettings"
           glib:type-name="CamelLocalSettings"
           glib:get-type="camel_local_settings_get_type"
           glib:type-struct="LocalSettingsClass">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <method name="dup_path"
              c:identifier="camel_local_settings_dup_path"
              version="3.4">
        <doc xml:space="preserve">Thread-safe variation of camel_local_settings_get_path().
Use this function when accessing @settings from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelLocalSettings:path</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelLocalSettings</doc>
            <type name="LocalSettings" c:type="CamelLocalSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filter_all"
              c:identifier="camel_local_settings_get_filter_all"
              version="3.24">
        <doc xml:space="preserve">Returns whether apply filters in all folders.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether to apply filters in all folders</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelLocalSettings</doc>
            <type name="LocalSettings" c:type="CamelLocalSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filter_junk"
              c:identifier="camel_local_settings_get_filter_junk"
              version="3.24">
        <doc xml:space="preserve">Returns whether to check new messages for junk.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether to check new messages for junk</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelLocalSettings</doc>
            <type name="LocalSettings" c:type="CamelLocalSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path"
              c:identifier="camel_local_settings_get_path"
              version="3.4">
        <doc xml:space="preserve">Returns the file path to the root of the local mail store.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the file path to the local store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelLocalSettings</doc>
            <type name="LocalSettings" c:type="CamelLocalSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_filter_all"
              c:identifier="camel_local_settings_set_filter_all"
              version="3.24">
        <doc xml:space="preserve">Sets whether to apply filters in all folders.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelLocalSettings</doc>
            <type name="LocalSettings" c:type="CamelLocalSettings*"/>
          </instance-parameter>
          <parameter name="filter_all" transfer-ownership="none">
            <doc xml:space="preserve">whether to apply filters in all folders</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filter_junk"
              c:identifier="camel_local_settings_set_filter_junk"
              version="3.24">
        <doc xml:space="preserve">Sets whether to check new messages for junk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelLocalSettings</doc>
            <type name="LocalSettings" c:type="CamelLocalSettings*"/>
          </instance-parameter>
          <parameter name="filter_junk" transfer-ownership="none">
            <doc xml:space="preserve">whether to check new messages for junk</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path"
              c:identifier="camel_local_settings_set_path"
              version="3.4">
        <doc xml:space="preserve">Sets the file path to the root of the local mail store.  Any
trailing directory separator characters will be stripped off
of the #CamelLocalSettings:path property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelLocalSettings</doc>
            <type name="LocalSettings" c:type="CamelLocalSettings*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the file path to the local store</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="filter-all"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="filter-junk"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="path"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="StoreSettings" c:type="CamelStoreSettings"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="LocalSettingsPrivate" c:type="CamelLocalSettingsPrivate*"/>
      </field>
    </class>
    <record name="LocalSettingsClass"
            c:type="CamelLocalSettingsClass"
            glib:is-gtype-struct-for="LocalSettings">
      <field name="parent_class" readable="0" private="1">
        <type name="StoreSettingsClass" c:type="CamelStoreSettingsClass"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="LocalSettingsPrivate"
            c:type="CamelLocalSettingsPrivate"
            disguised="1">
    </record>
    <enumeration name="LockType" c:type="CamelLockType">
      <member name="read" value="0" c:identifier="CAMEL_LOCK_READ">
      </member>
      <member name="write" value="1" c:identifier="CAMEL_LOCK_WRITE">
      </member>
    </enumeration>
    <constant name="MESSAGE_DATE_CURRENT"
              value="-1"
              c:type="CAMEL_MESSAGE_DATE_CURRENT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MESSAGE_SYSTEM_MASK"
              value="4294901760"
              c:type="CAMEL_MESSAGE_SYSTEM_MASK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_FILTER_ENRICHED_IS_RICHTEXT"
              value="1"
              c:type="CAMEL_MIME_FILTER_ENRICHED_IS_RICHTEXT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YDECODE_STATE_BEGIN"
              value="4096"
              c:type="CAMEL_MIME_YDECODE_STATE_BEGIN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YDECODE_STATE_DECODE"
              value="16384"
              c:type="CAMEL_MIME_YDECODE_STATE_DECODE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YDECODE_STATE_END"
              value="32768"
              c:type="CAMEL_MIME_YDECODE_STATE_END">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YDECODE_STATE_EOLN"
              value="256"
              c:type="CAMEL_MIME_YDECODE_STATE_EOLN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YDECODE_STATE_ESCAPE"
              value="512"
              c:type="CAMEL_MIME_YDECODE_STATE_ESCAPE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YDECODE_STATE_INIT"
              value="0"
              c:type="CAMEL_MIME_YDECODE_STATE_INIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YDECODE_STATE_PART"
              value="8192"
              c:type="CAMEL_MIME_YDECODE_STATE_PART">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YENCODE_CRC_INIT"
              value="-1"
              c:type="CAMEL_MIME_YENCODE_CRC_INIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MIME_YENCODE_STATE_INIT"
              value="0"
              c:type="CAMEL_MIME_YENCODE_STATE_INIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="MIRecord" c:type="CamelMIRecord" version="2.24">
      <doc xml:space="preserve">The extensive DB format, supporting basic searching and sorting.</doc>
      <field name="uid" writable="1">
        <doc xml:space="preserve">Message UID</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">Camel Message info flags</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="msg_type" writable="1">
        <doc xml:space="preserve">unused</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="dirty" writable="1">
        <doc xml:space="preserve">whether the message info requires upload to the server; it corresponds to #CAMEL_MESSAGE_FOLDER_FLAGGED</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="read" writable="1">
        <doc xml:space="preserve">boolean read status</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="deleted" writable="1">
        <doc xml:space="preserve">boolean deleted status</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="replied" writable="1">
        <doc xml:space="preserve">boolean replied status</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="important" writable="1">
        <doc xml:space="preserve">boolean important status</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="junk" writable="1">
        <doc xml:space="preserve">boolean junk status</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="attachment" writable="1">
        <doc xml:space="preserve">boolean attachment status</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve">size of the mail</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="dsent" writable="1">
        <doc xml:space="preserve">date sent</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="dreceived" writable="1">
        <doc xml:space="preserve">date received</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="subject" writable="1">
        <doc xml:space="preserve">subject of the mail</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="from" writable="1">
        <doc xml:space="preserve">sender</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="to" writable="1">
        <doc xml:space="preserve">recipient</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cc" writable="1">
        <doc xml:space="preserve">CC members</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="mlist" writable="1">
        <doc xml:space="preserve">message list headers</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="followup_flag" writable="1">
        <doc xml:space="preserve">followup flag / also can be queried to see for followup or not</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="followup_completed_on" writable="1">
        <doc xml:space="preserve">completed date, can be used to see if completed</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="followup_due_by" writable="1">
        <doc xml:space="preserve">to see the due by date</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="part" writable="1">
        <doc xml:space="preserve">part / references / thread id</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="labels" writable="1">
        <doc xml:space="preserve">labels of mails also called as userflags</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="usertags" writable="1">
        <doc xml:space="preserve">composite string of user tags</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="cinfo" writable="1">
        <doc xml:space="preserve">content info string - composite string</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="bdata" writable="1">
        <doc xml:space="preserve">provider specific data</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
    </record>
    <class name="Medium"
           c:symbol-prefix="medium"
           c:type="CamelMedium"
           parent="DataWrapper"
           abstract="1"
           glib:type-name="CamelMedium"
           glib:get-type="camel_medium_get_type"
           glib:type-struct="MediumClass">
      <virtual-method name="add_header" invoker="add_header">
        <doc xml:space="preserve">Adds a header to a #CamelMedium.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_headers" invoker="dup_headers" version="3.24">
        <doc xml:space="preserve">Gets an array of all header name/value pairs. The values will be
decoded to UTF-8 for any headers that are recognized by Camel.
See also camel_medium_get_headers().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the array of headers, which must be freed with camel_name_value_array_free().</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_content" invoker="get_content">
        <doc xml:space="preserve">Gets a data wrapper that represents the content of the medium,
without its headers.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelDataWrapper containing
@medium's content. Can return NULL.</doc>
          <type name="DataWrapper" c:type="CamelDataWrapper*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_header" invoker="get_header">
        <doc xml:space="preserve">Gets the value of the named header in the medium, or %NULL if
it is unset. The caller should not modify or free the data.

If the header occurs more than once, only retrieve the first
instance of the header.  For multi-occuring headers, use
camel_medium_dup_headers() or camel_medium_get_headers().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value of the named header, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_headers" invoker="get_headers" version="3.24">
        <doc xml:space="preserve">Gets an array of all header name/value pairs. The values will be
decoded to UTF-8 for any headers that are recognized by Camel.
See also camel_medium_dup_headers().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the array of headers, owned by @medium.</doc>
          <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_header" invoker="remove_header">
        <doc xml:space="preserve">Removes the named header from the medium.  All occurances of the
header are removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_content" invoker="set_content">
        <doc xml:space="preserve">Sets the content of @medium to be @content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="content" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper object</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_header" invoker="set_header">
        <doc xml:space="preserve">Sets the value of a header.  Any other occurances of the header
will be removed.  Setting a %NULL header can be used to remove
the header also.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_header" c:identifier="camel_medium_add_header">
        <doc xml:space="preserve">Adds a header to a #CamelMedium.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_headers"
              c:identifier="camel_medium_dup_headers"
              version="3.24">
        <doc xml:space="preserve">Gets an array of all header name/value pairs. The values will be
decoded to UTF-8 for any headers that are recognized by Camel.
See also camel_medium_get_headers().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the array of headers, which must be freed with camel_name_value_array_free().</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content" c:identifier="camel_medium_get_content">
        <doc xml:space="preserve">Gets a data wrapper that represents the content of the medium,
without its headers.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelDataWrapper containing
@medium's content. Can return NULL.</doc>
          <type name="DataWrapper" c:type="CamelDataWrapper*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_header" c:identifier="camel_medium_get_header">
        <doc xml:space="preserve">Gets the value of the named header in the medium, or %NULL if
it is unset. The caller should not modify or free the data.

If the header occurs more than once, only retrieve the first
instance of the header.  For multi-occuring headers, use
camel_medium_dup_headers() or camel_medium_get_headers().</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the value of the named header, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_headers"
              c:identifier="camel_medium_get_headers"
              version="3.24">
        <doc xml:space="preserve">Gets an array of all header name/value pairs. The values will be
decoded to UTF-8 for any headers that are recognized by Camel.
See also camel_medium_dup_headers().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the array of headers, owned by @medium.</doc>
          <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_header" c:identifier="camel_medium_remove_header">
        <doc xml:space="preserve">Removes the named header from the medium.  All occurances of the
header are removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content" c:identifier="camel_medium_set_content">
        <doc xml:space="preserve">Sets the content of @medium to be @content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="content" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelDataWrapper object</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_header" c:identifier="camel_medium_set_header">
        <doc xml:space="preserve">Sets the value of a header.  Any other occurances of the header
will be removed.  Setting a %NULL header can be used to remove
the header also.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="medium" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMedium object</doc>
            <type name="Medium" c:type="CamelMedium*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value of the header</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="content" writable="1" transfer-ownership="none">
        <type name="DataWrapper"/>
      </property>
      <field name="parent">
        <type name="DataWrapper" c:type="CamelDataWrapper"/>
      </field>
      <field name="priv">
        <type name="MediumPrivate" c:type="CamelMediumPrivate*"/>
      </field>
    </class>
    <record name="MediumClass"
            c:type="CamelMediumClass"
            glib:is-gtype-struct-for="Medium">
      <field name="parent_class">
        <type name="DataWrapperClass" c:type="CamelDataWrapperClass"/>
      </field>
      <field name="add_header">
        <callback name="add_header">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium object</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">name of the header</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">value of the header</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_header">
        <callback name="set_header">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium object</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">name of the header</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve">value of the header</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_header">
        <callback name="remove_header">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the header</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_header">
        <callback name="get_header">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">the value of the named header, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">the name of the header</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_headers">
        <callback name="dup_headers">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the array of headers, which must be freed with camel_name_value_array_free().</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium object</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_headers">
        <callback name="get_headers">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the array of headers, owned by @medium.</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium object</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_content">
        <callback name="get_content">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">a #CamelDataWrapper containing
@medium's content. Can return NULL.</doc>
            <type name="DataWrapper" c:type="CamelDataWrapper*"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium object</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_content">
        <callback name="set_content">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="medium" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMedium object</doc>
              <type name="Medium" c:type="CamelMedium*"/>
            </parameter>
            <parameter name="content" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelDataWrapper object</doc>
              <type name="DataWrapper" c:type="CamelDataWrapper*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MediumPrivate" c:type="CamelMediumPrivate" disguised="1">
    </record>
    <record name="MemChunk" c:type="CamelMemChunk" disguised="1" version="3.4">
    </record>
    <record name="MemPool" c:type="CamelMemPool" disguised="1" version="2.32">
    </record>
    <enumeration name="MemPoolFlags" version="2.32" c:type="CamelMemPoolFlags">
      <member name="struct"
              value="0"
              c:identifier="CAMEL_MEMPOOL_ALIGN_STRUCT">
        <doc xml:space="preserve">Allocate to native structure alignment</doc>
      </member>
      <member name="word" value="1" c:identifier="CAMEL_MEMPOOL_ALIGN_WORD">
        <doc xml:space="preserve">Allocate to words - 16 bit alignment</doc>
      </member>
      <member name="byte" value="2" c:identifier="CAMEL_MEMPOOL_ALIGN_BYTE">
        <doc xml:space="preserve">Allocate to bytes - 8 bit alignment</doc>
      </member>
      <member name="mask" value="3" c:identifier="CAMEL_MEMPOOL_ALIGN_MASK">
        <doc xml:space="preserve">Which bits determine the alignment information</doc>
      </member>
    </enumeration>
    <record name="MessageContentInfo"
            c:type="CamelMessageContentInfo"
            glib:type-name="CamelMessageContentInfo"
            glib:get-type="camel_message_content_info_get_type"
            c:symbol-prefix="message_content_info">
      <field name="next" writable="1">
        <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
      </field>
      <field name="childs" writable="1">
        <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
      </field>
      <field name="parent" writable="1">
        <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
      </field>
      <field name="type" writable="1">
        <type name="ContentType" c:type="CamelContentType*"/>
      </field>
      <field name="id" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="encoding" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <constructor name="new" c:identifier="camel_message_content_info_new">
        <doc xml:space="preserve">Allocate a new #CamelMessageContentInfo.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #CamelMessageContentInfo</doc>
          <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_headers"
                   c:identifier="camel_message_content_info_new_from_headers">
        <return-value transfer-ownership="full">
          <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
        </return-value>
        <parameters>
          <parameter name="headers" transfer-ownership="none">
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_message"
                   c:identifier="camel_message_content_info_new_from_message">
        <return-value transfer-ownership="full">
          <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
        </return-value>
        <parameters>
          <parameter name="mime_part" transfer-ownership="none">
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_parser"
                   c:identifier="camel_message_content_info_new_from_parser">
        <return-value transfer-ownership="full">
          <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
        </return-value>
        <parameters>
          <parameter name="parser" transfer-ownership="none">
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="camel_message_content_info_copy"
              version="3.24">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of @src, or %NULL, if @src was %NULL</doc>
          <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a source #CamelMessageContentInfo to copy</doc>
            <type name="MessageContentInfo"
                  c:type="const CamelMessageContentInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="camel_message_content_info_dump">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ci" transfer-ownership="none">
            <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
          </instance-parameter>
          <parameter name="depth" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="camel_message_content_info_free">
        <doc xml:space="preserve">Recursively frees the content info @ci, and all associated memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="ci" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageContentInfo</doc>
            <type name="MessageContentInfo" c:type="CamelMessageContentInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="MessageFlags" c:type="CamelMessageFlags">
      <member name="answered" value="1" c:identifier="CAMEL_MESSAGE_ANSWERED">
      </member>
      <member name="deleted" value="2" c:identifier="CAMEL_MESSAGE_DELETED">
      </member>
      <member name="draft" value="4" c:identifier="CAMEL_MESSAGE_DRAFT">
      </member>
      <member name="flagged" value="8" c:identifier="CAMEL_MESSAGE_FLAGGED">
      </member>
      <member name="seen" value="16" c:identifier="CAMEL_MESSAGE_SEEN">
      </member>
      <member name="attachments"
              value="32"
              c:identifier="CAMEL_MESSAGE_ATTACHMENTS">
      </member>
      <member name="answered_all"
              value="64"
              c:identifier="CAMEL_MESSAGE_ANSWERED_ALL">
      </member>
      <member name="junk" value="128" c:identifier="CAMEL_MESSAGE_JUNK">
      </member>
      <member name="secure" value="256" c:identifier="CAMEL_MESSAGE_SECURE">
      </member>
      <member name="notjunk" value="512" c:identifier="CAMEL_MESSAGE_NOTJUNK">
      </member>
      <member name="forwarded"
              value="1024"
              c:identifier="CAMEL_MESSAGE_FORWARDED">
      </member>
      <member name="folder_flagged"
              value="65536"
              c:identifier="CAMEL_MESSAGE_FOLDER_FLAGGED">
      </member>
      <member name="junk_learn"
              value="1073741824"
              c:identifier="CAMEL_MESSAGE_JUNK_LEARN">
      </member>
      <member name="user" value="2147483648" c:identifier="CAMEL_MESSAGE_USER">
      </member>
    </bitfield>
    <class name="MessageInfo"
           c:symbol-prefix="message_info"
           c:type="CamelMessageInfo"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CamelMessageInfo"
           glib:get-type="camel_message_info_get_type"
           glib:type-struct="MessageInfoClass">
      <constructor name="new"
                   c:identifier="camel_message_info_new"
                   version="3.24">
        <doc xml:space="preserve">Create a new #CamelMessageInfo object, optionally for given @summary.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMessageInfo object</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <parameter name="summary"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">parent #CamelFolderSummary object, or %NULL</doc>
            <type name="FolderSummary" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_headers"
                   c:identifier="camel_message_info_new_from_headers"
                   version="3.24">
        <doc xml:space="preserve">Create a new #CamelMessageInfo pre-populated with info from
@headers.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMessageInfo</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object or %NULL</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </parameter>
          <parameter name="headers" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="clone" invoker="clone" version="3.24">
        <doc xml:space="preserve">Clones the @mi as a new #CamelMessageInfo and eventually assigns
a new #CamelFolderSummary to it. If it's not set, then the same
summary as the one with @mi is used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMessageInfo object, clone of the @mi</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo to clone</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="assign_summary"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">parent #CamelFolderSummary object, or %NULL, to set on the clone</doc>
            <type name="FolderSummary" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_user_flags"
                      invoker="dup_user_flags"
                      version="3.24">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #CamelNamedFlags with all the currently set
  user flags on the @mi. Free the returned structure with camel_named_flags_free()
  when no londer needed.</doc>
          <type name="NamedFlags" c:type="CamelNamedFlags*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_user_tags"
                      invoker="dup_user_tags"
                      version="3.24">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated #CamelNameValueArray containing all set
  user tags of the @mi. Free it with camel_name_value_array_free() when no longer needed.</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_cc" invoker="get_cc" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">CC address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_date_received"
                      invoker="get_date_received"
                      version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">time_t of the Received header of the message, encoded as gint64.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_date_sent"
                      invoker="get_date_sent"
                      version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">time_t of the Date header of the message, encoded as gint64.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_flags" invoker="get_flags" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Bit-or of #CamelMessageFlags set on the @mi.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_from" invoker="get_from" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">From address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_headers" invoker="get_headers" version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">All the message headers of the associated
  message, or %NULL, when none are available.</doc>
          <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_message_id"
                      invoker="get_message_id"
                      version="3.24">
        <doc xml:space="preserve">Encoded Message-ID of the associated message as a guint64 number,
partial MD5 sum. The value can be cast to #CamelSummaryMessageID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Partial MD5 hash of the Message-ID header of the associated message.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_mlist" invoker="get_mlist" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Mailing list address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_references"
                      invoker="get_references"
                      version="3.24">
        <doc xml:space="preserve">Gets encoded In-Reply-To and References headers of the associated
message as an array of guint64 numbers, partial MD5 sums. Each value
can be cast to #CamelSummaryMessageID.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">A #GArray of
  guint64 encoded Message-ID-s; or %NULL when none are available.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint64"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_size" invoker="get_size" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Size of the associated message.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_subject" invoker="get_subject" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Subject of the #mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_to" invoker="get_to" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">To address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_user_flag"
                      invoker="get_user_flag"
                      version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whther the user flag named @name is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user flag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_user_flags"
                      invoker="get_user_flags"
                      version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">A #CamelNamedFlags with all the currently set
  user flags on the @mi. Do not modify it.</doc>
          <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_user_tag"
                      invoker="get_user_tag"
                      version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Value of the user tag, or %NULL when
  it is not set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user tag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_user_tags"
                      invoker="get_user_tags"
                      version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelNameValueArray containing all set
  user tags of the @mi. Do not modify it.</doc>
          <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="load" invoker="load" version="3.24">
        <doc xml:space="preserve">Load content of @mi from the data stored in @record. The @bdata_ptr points
to the current position of the record-&gt;bdata, where the read can continue.
Use helper functions camel_util_bdata_get_number() and camel_util_bdata_get_string()
to read data from it and also move forward the *bdata_ptr.

After successful load of the @mi, the 'dirty' flag is unset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the load was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo to load</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="record"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelMIRecord to load the @mi from</doc>
            <type name="MIRecord" c:type="gpointer*"/>
          </parameter>
          <parameter name="bdata_ptr" transfer-ownership="none">
            <doc xml:space="preserve">a backend specific data (bdata) pointer</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save" invoker="save" version="3.24">
        <doc xml:space="preserve">Save the @mi content to the message info record @record. It can populate all
but the record-&gt;bdata value, which is set fro mthe @bdata_str. Use helper functions
camel_util_bdata_put_number() and camel_util_bdata_put_string() to put data into the @bdata_str.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the save succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="record"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelMIRecord to populate</doc>
            <type name="MIRecord" c:type="gpointer*"/>
          </parameter>
          <parameter name="bdata_str" transfer-ownership="none">
            <doc xml:space="preserve">a #GString with a string to save as backend specific data (bdata)</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_cc" invoker="set_cc" version="3.24">
        <doc xml:space="preserve">Sets CC from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="cc"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a CC to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_date_received"
                      invoker="set_date_received"
                      version="3.24">
        <doc xml:space="preserve">Sets received date (the Received header) of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="date_received" transfer-ownership="none">
            <doc xml:space="preserve">a received date to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_date_sent"
                      invoker="set_date_sent"
                      version="3.24">
        <doc xml:space="preserve">Sets sent date (the Date header) of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="date_sent" transfer-ownership="none">
            <doc xml:space="preserve">a sent date to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_flags" invoker="set_flags" version="3.24">
        <doc xml:space="preserve">Change the state of the flags on the @mi. Both @mask and @set are bit-or
of #CamelMessageFlags.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary. In case
the CAMEL_MESSAGE_FOLDER_FLAGGED flag would be set and the @mi is
not aborting notifications, the 'folder-flagged-stamp' changes too.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the flags changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">mask of flags to change</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">state the flags should be changed to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_from" invoker="set_from" version="3.24">
        <doc xml:space="preserve">Sets From from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="from"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a From to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_message_id"
                      invoker="set_message_id"
                      version="3.24">
        <doc xml:space="preserve">Sets encoded Message-ID of the associated message as a guint64 number,
partial MD5 sum. The value can be cast to #CamelSummaryMessageID.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="message_id" transfer-ownership="none">
            <doc xml:space="preserve">a message id to set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_mlist" invoker="set_mlist" version="3.24">
        <doc xml:space="preserve">Sets mesage list address from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="mlist"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a message list address to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_size" invoker="set_size" version="3.24">
        <doc xml:space="preserve">Sets size of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">a size to set</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_subject" invoker="set_subject" version="3.24">
        <doc xml:space="preserve">Sets Subject from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="subject"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a Subject to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_to" invoker="set_to" version="3.24">
        <doc xml:space="preserve">Sets To from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="to"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a To to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_user_flag"
                      invoker="set_user_flag"
                      version="3.24">
        <doc xml:space="preserve">Change @state of the flag named @name. Unlike user tags, user flags
can only be set or unset, while the user tags can contain certain values.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the message info changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user flag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">state to set for the flag</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_user_tag"
                      invoker="set_user_tag"
                      version="3.24">
        <doc xml:space="preserve">Set user tag @name to @value, or remove it, if @value is %NULL.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @mi changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user tag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user tag value, or %NULL to remove the user tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="take_headers"
                      invoker="take_headers"
                      version="3.24">
        <doc xml:space="preserve">Takes headers of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.

Note that it's not safe to use the @headers after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="headers"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">headers to set, as #CamelNameValueArray, or %NULL</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="take_references"
                      invoker="take_references"
                      version="3.24">
        <doc xml:space="preserve">Takes encoded In-Reply-To and References headers of the associated message
as an array of guint64 numbers, partial MD5 sums. Each value can be
cast to #CamelSummaryMessageID.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.

Note that it's not safe to use the @references after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="references"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a references to set</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="guint64"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="take_user_flags"
                      invoker="take_user_flags"
                      version="3.24">
        <doc xml:space="preserve">Takes all the @user_flags, which replaces any current user flags on the @mi.
The passed-in @user_flags is consumed by the @mi, which becomes an owner
of it. The caller should not change @user_flags afterwards.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.

Note that it's not safe to use the @user_flags after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the message info changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="user_flags"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user flags to set</doc>
            <type name="NamedFlags" c:type="CamelNamedFlags*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="take_user_tags"
                      invoker="take_user_tags"
                      version="3.24">
        <doc xml:space="preserve">Takes all the @user_tags, which replaces any current user tags on the @mi.
The passed-in @user_tags is consumed by the @mi, which becomes an owner
of it. The caller should not change @user_tags afterwards.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.

Note that it's not safe to use the @user_tags after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @mi changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="user_tags"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user tags to set</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clone"
              c:identifier="camel_message_info_clone"
              version="3.24">
        <doc xml:space="preserve">Clones the @mi as a new #CamelMessageInfo and eventually assigns
a new #CamelFolderSummary to it. If it's not set, then the same
summary as the one with @mi is used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMessageInfo object, clone of the @mi</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo to clone</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="assign_summary"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">parent #CamelFolderSummary object, or %NULL, to set on the clone</doc>
            <type name="FolderSummary" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump"
              c:identifier="camel_message_info_dump"
              version="3.24">
        <doc xml:space="preserve">Dumps the mesasge info @mi to stdout. This is meand for debugging
purposes only.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_headers"
              c:identifier="camel_message_info_dup_headers"
              version="3.24">
        <doc xml:space="preserve">Duplicates array of headers for the @mi.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">All the message headers of the associated
  message, or %NULL, when none are available. Free returned array with
  camel_name_value_array_free() when no longer needed.</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_references"
              c:identifier="camel_message_info_dup_references"
              version="3.24">
        <doc xml:space="preserve">Duplicates encoded In-Reply-To and References headers of the associated
message as an array of guint64 numbers, partial MD5 sums. Each value
can be cast to #CamelSummaryMessageID.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">A #GArray of
  guint64 encoded Message-ID-s; or %NULL when none are available. Free returned
  array with g_array_unref() when no longer needed.</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint64"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_user_flags"
              c:identifier="camel_message_info_dup_user_flags"
              version="3.24">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #CamelNamedFlags with all the currently set
  user flags on the @mi. Free the returned structure with camel_named_flags_free()
  when no londer needed.</doc>
          <type name="NamedFlags" c:type="CamelNamedFlags*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_user_tag"
              c:identifier="camel_message_info_dup_user_tag"
              version="3.24">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">Value of the user tag as newly allocated
  string, or %NULL when it is not set. Free it with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user tag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_user_tags"
              c:identifier="camel_message_info_dup_user_tags"
              version="3.24">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a newly allocated #CamelNameValueArray containing all set
  user tags of the @mi. Free it with camel_name_value_array_free() when no longer needed.</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="freeze_notifications"
              c:identifier="camel_message_info_freeze_notifications"
              version="3.24">
        <doc xml:space="preserve">Freezes all the notifications until the camel_message_info_thaw_notifications() is called.
This function can be called multiple times, where the last thaw will do the notifications.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_abort_notifications"
              c:identifier="camel_message_info_get_abort_notifications"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @mi is aborting notifications, which means
  that it will not influence 'dirty' and 'folder-flagged' flags
  in the set/take functions, neither it will emit any GObject::notify
  signals on change, nor associated folder's "changed" signal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cc"
              c:identifier="camel_message_info_get_cc"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">CC address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_date_received"
              c:identifier="camel_message_info_get_date_received"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">time_t of the Received header of the message, encoded as gint64.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_date_sent"
              c:identifier="camel_message_info_get_date_sent"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">time_t of the Date header of the message, encoded as gint64.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dirty"
              c:identifier="camel_message_info_get_dirty"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @mi is dirty, which means that it had been
  changed and a save to the local summary is required.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="camel_message_info_get_flags"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Bit-or of #CamelMessageFlags set on the @mi.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder_flagged"
              c:identifier="camel_message_info_get_folder_flagged"
              version="3.24">
        <doc xml:space="preserve">The folder flagged flag is used to mark the message infor as being changed
and this change should be propagated to the remote store (server). This is
different from the 'dirty' flag, which is set for local changes only. It
can happen that the 'folder-flagged' flag is set, but the 'dirty' flag not.

This is only a convenient wrapper around CAMEL_MESSAGE_FOLDER_FLAGGED flag,
for better readiness of the code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether requires save of the local changes into the remote store.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder_flagged_stamp"
              c:identifier="camel_message_info_get_folder_flagged_stamp"
              version="3.24">
        <doc xml:space="preserve">The 'folder-flagged-stamp' is a stamp of the 'folder-flagged' flag. This stamp
changes whenever anything would mark the @mi as 'folder-flagged', regardless
the @mi being already 'folder-flagged'. It can be used to recognize changes
on the 'folder-flagged' flag during the time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Stamp of the 'folder-flagged' flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_from"
              c:identifier="camel_message_info_get_from"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">From address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_headers"
              c:identifier="camel_message_info_get_headers"
              version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">All the message headers of the associated
  message, or %NULL, when none are available.</doc>
          <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message_id"
              c:identifier="camel_message_info_get_message_id"
              version="3.24">
        <doc xml:space="preserve">Encoded Message-ID of the associated message as a guint64 number,
partial MD5 sum. The value can be cast to #CamelSummaryMessageID.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Partial MD5 hash of the Message-ID header of the associated message.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mlist"
              c:identifier="camel_message_info_get_mlist"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Mailing list address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_notifications_frozen"
              c:identifier="camel_message_info_get_notifications_frozen"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the notifications are frozen.

See: camel_message_info_freeze_notifications()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_references"
              c:identifier="camel_message_info_get_references"
              version="3.24">
        <doc xml:space="preserve">Gets encoded In-Reply-To and References headers of the associated
message as an array of guint64 numbers, partial MD5 sums. Each value
can be cast to #CamelSummaryMessageID.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">A #GArray of
  guint64 encoded Message-ID-s; or %NULL when none are available.</doc>
          <array name="GLib.Array" c:type="const GArray*">
            <type name="guint64"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size"
              c:identifier="camel_message_info_get_size"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Size of the associated message.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject"
              c:identifier="camel_message_info_get_subject"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Subject of the #mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_to"
              c:identifier="camel_message_info_get_to"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">To address of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uid"
              c:identifier="camel_message_info_get_uid"
              version="3.24">
        <doc xml:space="preserve">Get the UID of the #mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The UID of the @mi.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_flag"
              c:identifier="camel_message_info_get_user_flag"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whther the user flag named @name is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user flag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_flags"
              c:identifier="camel_message_info_get_user_flags"
              version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">A #CamelNamedFlags with all the currently set
  user flags on the @mi. Do not modify it.</doc>
          <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_tag"
              c:identifier="camel_message_info_get_user_tag"
              version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Value of the user tag, or %NULL when
  it is not set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user tag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_tags"
              c:identifier="camel_message_info_get_user_tags"
              version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelNameValueArray containing all set
  user tags of the @mi. Do not modify it.</doc>
          <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load"
              c:identifier="camel_message_info_load"
              version="3.24">
        <doc xml:space="preserve">Load content of @mi from the data stored in @record. The @bdata_ptr points
to the current position of the record-&gt;bdata, where the read can continue.
Use helper functions camel_util_bdata_get_number() and camel_util_bdata_get_string()
to read data from it and also move forward the *bdata_ptr.

After successful load of the @mi, the 'dirty' flag is unset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the load was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo to load</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="record" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMIRecord to load the @mi from</doc>
            <type name="MIRecord" c:type="gpointer*"/>
          </parameter>
          <parameter name="bdata_ptr" transfer-ownership="none">
            <doc xml:space="preserve">a backend specific data (bdata) pointer</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="pooldup_uid"
              c:identifier="camel_message_info_pooldup_uid"
              version="3.24">
        <doc xml:space="preserve">Get the UID of the #mi, duplicated on the Camel's string pool.
This is good for thread safety, though the UID should not change once set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A newly references string in the string pool, the #mi UID.
  Free it with camel_pstring_free() when no longer needed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="property_lock"
              c:identifier="camel_message_info_property_lock"
              version="3.24">
        <doc xml:space="preserve">Acquires a property lock, which is used to ensure thread safety
when properties are changing. Release the lock with
camel_message_info_property_unlock().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="property_unlock"
              c:identifier="camel_message_info_property_unlock"
              version="3.24">
        <doc xml:space="preserve">Releases a property lock, previously acquired with
camel_message_info_property_lock().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_summary"
              c:identifier="camel_message_info_ref_summary"
              version="3.24">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">Referenced #CamelFolderSummary to which the @mi belongs, or %NULL,
if there is none. Use g_object_unref() for non-NULL returned values when done with it.</doc>
          <type name="gpointer" c:type="_CamelFolderSummary*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save"
              c:identifier="camel_message_info_save"
              version="3.24">
        <doc xml:space="preserve">Save the @mi content to the message info record @record. It can populate all
but the record-&gt;bdata value, which is set fro mthe @bdata_str. Use helper functions
camel_util_bdata_put_number() and camel_util_bdata_put_string() to put data into the @bdata_str.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the save succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="record" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMIRecord to populate</doc>
            <type name="MIRecord" c:type="gpointer*"/>
          </parameter>
          <parameter name="bdata_str" transfer-ownership="none">
            <doc xml:space="preserve">a #GString with a string to save as backend specific data (bdata)</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_abort_notifications"
              c:identifier="camel_message_info_set_abort_notifications"
              version="3.24">
        <doc xml:space="preserve">Marks the @mi to abort any notifications, which means that it
will not influence 'dirty' and 'folder-flagged' flags in
the set/take functions, neither it will emit any GObject::notify
signals on change, nor associated folder's "changed" signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="abort_notifications" transfer-ownership="none">
            <doc xml:space="preserve">a state to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cc"
              c:identifier="camel_message_info_set_cc"
              version="3.24">
        <doc xml:space="preserve">Sets CC from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="cc"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a CC to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_date_received"
              c:identifier="camel_message_info_set_date_received"
              version="3.24">
        <doc xml:space="preserve">Sets received date (the Received header) of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="date_received" transfer-ownership="none">
            <doc xml:space="preserve">a received date to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_date_sent"
              c:identifier="camel_message_info_set_date_sent"
              version="3.24">
        <doc xml:space="preserve">Sets sent date (the Date header) of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="date_sent" transfer-ownership="none">
            <doc xml:space="preserve">a sent date to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dirty"
              c:identifier="camel_message_info_set_dirty"
              version="3.24">
        <doc xml:space="preserve">Marks the @mi as dirty, which means a save to the local summary
is required.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="dirty" transfer-ownership="none">
            <doc xml:space="preserve">a dirty state to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags"
              c:identifier="camel_message_info_set_flags"
              version="3.24">
        <doc xml:space="preserve">Change the state of the flags on the @mi. Both @mask and @set are bit-or
of #CamelMessageFlags.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary. In case
the CAMEL_MESSAGE_FOLDER_FLAGGED flag would be set and the @mi is
not aborting notifications, the 'folder-flagged-stamp' changes too.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the flags changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve">mask of flags to change</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">state the flags should be changed to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_folder_flagged"
              c:identifier="camel_message_info_set_folder_flagged"
              version="3.24">
        <doc xml:space="preserve">Changes the folder-flagged flag to the @folder_flagged value. See
camel_message_info_get_folder_flagged() for more information about
the use of this flag.

This is only a convenient wrapper around CAMEL_MESSAGE_FOLDER_FLAGGED flag,
for better readiness of the code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the flag had been changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="folder_flagged" transfer-ownership="none">
            <doc xml:space="preserve">a value to set to</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from"
              c:identifier="camel_message_info_set_from"
              version="3.24">
        <doc xml:space="preserve">Sets From from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="from"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a From to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message_id"
              c:identifier="camel_message_info_set_message_id"
              version="3.24">
        <doc xml:space="preserve">Sets encoded Message-ID of the associated message as a guint64 number,
partial MD5 sum. The value can be cast to #CamelSummaryMessageID.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="message_id" transfer-ownership="none">
            <doc xml:space="preserve">a message id to set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mlist"
              c:identifier="camel_message_info_set_mlist"
              version="3.24">
        <doc xml:space="preserve">Sets mesage list address from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="mlist"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a message list address to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size"
              c:identifier="camel_message_info_set_size"
              version="3.24">
        <doc xml:space="preserve">Sets size of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">a size to set</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_subject"
              c:identifier="camel_message_info_set_subject"
              version="3.24">
        <doc xml:space="preserve">Sets Subject from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="subject"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a Subject to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_to"
              c:identifier="camel_message_info_set_to"
              version="3.24">
        <doc xml:space="preserve">Sets To from the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="to"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a To to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uid"
              c:identifier="camel_message_info_set_uid"
              version="3.24">
        <doc xml:space="preserve">Changes UID of the @mi to @uid. If it changes, the 'dirty' flag
of the @mi is set too, unless the @mi is aborting notifications. This change
does not influence the 'folder-flagged' flag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the UID changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a UID to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_flag"
              c:identifier="camel_message_info_set_user_flag"
              version="3.24">
        <doc xml:space="preserve">Change @state of the flag named @name. Unlike user tags, user flags
can only be set or unset, while the user tags can contain certain values.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the message info changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user flag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">state to set for the flag</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_tag"
              c:identifier="camel_message_info_set_user_tag"
              version="3.24">
        <doc xml:space="preserve">Set user tag @name to @value, or remove it, if @value is %NULL.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @mi changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">user tag name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user tag value, or %NULL to remove the user tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_headers"
              c:identifier="camel_message_info_take_headers"
              version="3.24">
        <doc xml:space="preserve">Takes headers of the associated message.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.

Note that it's not safe to use the @headers after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="headers"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">headers to set, as #CamelNameValueArray, or %NULL</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_references"
              c:identifier="camel_message_info_take_references"
              version="3.24">
        <doc xml:space="preserve">Takes encoded In-Reply-To and References headers of the associated message
as an array of guint64 numbers, partial MD5 sums. Each value can be
cast to #CamelSummaryMessageID.

This property is considered static, in a meaning that it should
not change during the life-time of the @mi, the same as it doesn't
change in the associated message.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is not emitted
folder's "changed" signal for this @mi.

Note that it's not safe to use the @references after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the value changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="references"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a references to set</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="guint64"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="take_user_flags"
              c:identifier="camel_message_info_take_user_flags"
              version="3.24">
        <doc xml:space="preserve">Takes all the @user_flags, which replaces any current user flags on the @mi.
The passed-in @user_flags is consumed by the @mi, which becomes an owner
of it. The caller should not change @user_flags afterwards.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.

Note that it's not safe to use the @user_flags after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the message info changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="user_flags"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user flags to set</doc>
            <type name="NamedFlags" c:type="CamelNamedFlags*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_user_tags"
              c:identifier="camel_message_info_take_user_tags"
              version="3.24">
        <doc xml:space="preserve">Takes all the @user_tags, which replaces any current user tags on the @mi.
The passed-in @user_tags is consumed by the @mi, which becomes an owner
of it. The caller should not change @user_tags afterwards.

If the @mi changed, the 'dirty' flag and the 'folder-flagged' flag are
set automatically, unless the @mi is aborting notifications. There is also emitted
folder's "changed" signal for this @mi, if necessary.

Note that it's not safe to use the @user_tags after the call to this function,
because it can be freed due to no change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @mi changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
          <parameter name="user_tags"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user tags to set</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </parameter>
        </parameters>
      </method>
      <method name="thaw_notifications"
              c:identifier="camel_message_info_thaw_notifications"
              version="3.24">
        <doc xml:space="preserve">Reverses the call of the camel_message_info_freeze_notifications().
If this is the last freeze, then the associated folder is also notified
about the change, if any happened during the freeze.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMessageInfo</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="abort-notifications"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flag, whether the info is currently aborting notifications. It is used to avoid
unnecessary 'folder-flagged' and 'dirty' flags changes and also to avoid
associated folder's "changed" signal.
f</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="cc"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">CC address of the associated message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="date-received"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Received date of the associated message.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="date-sent"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Sent Date of the associated message.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="dirty"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flag, whether the info is changed and requires save to disk.
Compare with CamelMessageInfo:folder-flagged</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="flags"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Bit-or of #CamelMessageFlags.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="folder-flagged"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flag, whether the info is changed and requires save to
the destination store/server. This is different from
the CamelMessageInfo:dirty, which takes care of the local
information only.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="folder-flagged-stamp"
                version="3.24"
                transfer-ownership="none">
        <doc xml:space="preserve">The 'folder-flagged-stamp' is a stamp of the 'folder-flagged' flag. This stamp
changes whenever anything would mark the @mi 'folder-flagged', regardless the @mi
being already 'folder-flagged'. It can be used to recognize changes
on the 'folder-flagged' flag during the time.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="from"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">From address of the associated message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="headers"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Headers of the associated message. Can be %NULL.</doc>
        <type name="NameValueArray"/>
      </property>
      <property name="message-id"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Encoded Message-ID of the associated message as a guint64 number,
partial MD5 sum. The value can be cast to #CamelSummaryMessageID.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="mlist"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Mailing list address of the associated message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="references"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Encoded In-Reply-To and References headers of the associated message
as an array of guint64 numbers, partial MD5 sums. Each value can be
cast to #CamelSummaryMessageID.</doc>
        <array name="GLib.Array">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="size"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Size of the associated message.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="subject"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Subject of the associated message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="summary"
                version="3.24"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #CamelFolderSummary to which the message info belongs, or %NULL.
It can be set only during construction of the object.</doc>
        <type name="FolderSummary"/>
      </property>
      <property name="to"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">To address of the associated message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uid"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A unique ID of the message in its folder.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="user-flags"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">User flags for the associated message. Can be %NULL.
Unlike user-tags, which can contain various values, the user-flags
can only be set or not.</doc>
        <type name="NamedFlags"/>
      </property>
      <property name="user-tags"
                version="3.24"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">User tags for the associated message. Can be %NULL.
Unlike user-flags, which can be set or not, the user-tags
can contain various values.</doc>
        <type name="NameValueArray"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MessageInfoPrivate" c:type="CamelMessageInfoPrivate*"/>
      </field>
    </class>
    <class name="MessageInfoBase"
           c:symbol-prefix="message_info_base"
           c:type="CamelMessageInfoBase"
           parent="MessageInfo"
           glib:type-name="CamelMessageInfoBase"
           glib:get-type="camel_message_info_base_get_type"
           glib:type-struct="MessageInfoBaseClass">
      <field name="parent">
        <type name="MessageInfo" c:type="CamelMessageInfo"/>
      </field>
      <field name="priv">
        <type name="MessageInfoBasePrivate"
              c:type="CamelMessageInfoBasePrivate*"/>
      </field>
    </class>
    <record name="MessageInfoBaseClass"
            c:type="CamelMessageInfoBaseClass"
            glib:is-gtype-struct-for="MessageInfoBase">
      <field name="parent_class">
        <type name="MessageInfoClass" c:type="CamelMessageInfoClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MessageInfoBasePrivate"
            c:type="CamelMessageInfoBasePrivate"
            disguised="1">
    </record>
    <record name="MessageInfoClass"
            c:type="CamelMessageInfoClass"
            glib:is-gtype-struct-for="MessageInfo">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="clone">
        <callback name="clone">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #CamelMessageInfo object, clone of the @mi</doc>
            <type name="MessageInfo" c:type="CamelMessageInfo*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo to clone</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
            <parameter name="assign_summary"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">parent #CamelFolderSummary object, or %NULL, to set on the clone</doc>
              <type name="FolderSummary" c:type="gpointer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load">
        <callback name="load">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the load was successful.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo to load</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="record"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #CamelMIRecord to load the @mi from</doc>
              <type name="MIRecord" c:type="gpointer*"/>
            </parameter>
            <parameter name="bdata_ptr" transfer-ownership="none">
              <doc xml:space="preserve">a backend specific data (bdata) pointer</doc>
              <type name="utf8" c:type="gchar**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="save">
        <callback name="save">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the save succeeded.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
            <parameter name="record"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #CamelMIRecord to populate</doc>
              <type name="MIRecord" c:type="gpointer*"/>
            </parameter>
            <parameter name="bdata_str" transfer-ownership="none">
              <doc xml:space="preserve">a #GString with a string to save as backend specific data (bdata)</doc>
              <type name="GLib.String" c:type="GString*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_flags">
        <callback name="get_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Bit-or of #CamelMessageFlags set on the @mi.</doc>
            <type name="guint32" c:type="guint32"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_flags">
        <callback name="set_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the flags changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="mask" transfer-ownership="none">
              <doc xml:space="preserve">mask of flags to change</doc>
              <type name="guint32" c:type="guint32"/>
            </parameter>
            <parameter name="set" transfer-ownership="none">
              <doc xml:space="preserve">state the flags should be changed to</doc>
              <type name="guint32" c:type="guint32"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_user_flag">
        <callback name="get_user_flag">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whther the user flag named @name is set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">user flag name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_user_flag">
        <callback name="set_user_flag">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the message info changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">user flag name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <doc xml:space="preserve">state to set for the flag</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_user_flags">
        <callback name="get_user_flags">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">A #CamelNamedFlags with all the currently set
  user flags on the @mi. Do not modify it.</doc>
            <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_user_flags">
        <callback name="dup_user_flags">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A newly allocated #CamelNamedFlags with all the currently set
  user flags on the @mi. Free the returned structure with camel_named_flags_free()
  when no londer needed.</doc>
            <type name="NamedFlags" c:type="CamelNamedFlags*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="take_user_flags">
        <callback name="take_user_flags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the message info changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="user_flags"
                       transfer-ownership="full"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">user flags to set</doc>
              <type name="NamedFlags" c:type="CamelNamedFlags*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_user_tag">
        <callback name="get_user_tag">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">Value of the user tag, or %NULL when
  it is not set.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">user tag name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_user_tag">
        <callback name="set_user_tag">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the @mi changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">user tag name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">user tag value, or %NULL to remove the user tag</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_user_tags">
        <callback name="get_user_tags">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">a #CamelNameValueArray containing all set
  user tags of the @mi. Do not modify it.</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_user_tags">
        <callback name="dup_user_tags">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a newly allocated #CamelNameValueArray containing all set
  user tags of the @mi. Free it with camel_name_value_array_free() when no longer needed.</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="take_user_tags">
        <callback name="take_user_tags">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the @mi changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="user_tags"
                       transfer-ownership="full"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">user tags to set</doc>
              <type name="NameValueArray" c:type="CamelNameValueArray*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_subject">
        <callback name="get_subject">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Subject of the #mi.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_subject">
        <callback name="set_subject">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="subject"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a Subject to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_from">
        <callback name="get_from">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">From address of the @mi.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_from">
        <callback name="set_from">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="from"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a From to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_to">
        <callback name="get_to">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">To address of the @mi.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_to">
        <callback name="set_to">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="to"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a To to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_cc">
        <callback name="get_cc">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">CC address of the @mi.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_cc">
        <callback name="set_cc">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="cc"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a CC to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_mlist">
        <callback name="get_mlist">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Mailing list address of the @mi.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_mlist">
        <callback name="set_mlist">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="mlist"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a message list address to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_size">
        <callback name="get_size">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Size of the associated message.</doc>
            <type name="guint32" c:type="guint32"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_size">
        <callback name="set_size">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <doc xml:space="preserve">a size to set</doc>
              <type name="guint32" c:type="guint32"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_date_sent">
        <callback name="get_date_sent">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">time_t of the Date header of the message, encoded as gint64.</doc>
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_date_sent">
        <callback name="set_date_sent">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="date_sent" transfer-ownership="none">
              <doc xml:space="preserve">a sent date to set</doc>
              <type name="gint64" c:type="gint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_date_received">
        <callback name="get_date_received">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">time_t of the Received header of the message, encoded as gint64.</doc>
            <type name="gint64" c:type="gint64"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_date_received">
        <callback name="set_date_received">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="date_received" transfer-ownership="none">
              <doc xml:space="preserve">a received date to set</doc>
              <type name="gint64" c:type="gint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_message_id">
        <callback name="get_message_id">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Partial MD5 hash of the Message-ID header of the associated message.</doc>
            <type name="guint64" c:type="guint64"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_message_id">
        <callback name="set_message_id">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="message_id" transfer-ownership="none">
              <doc xml:space="preserve">a message id to set</doc>
              <type name="guint64" c:type="guint64"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_references">
        <callback name="get_references">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">A #GArray of
  guint64 encoded Message-ID-s; or %NULL when none are available.</doc>
            <array name="GLib.Array" c:type="const GArray*">
              <type name="guint64"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="take_references">
        <callback name="take_references">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="references"
                       transfer-ownership="full"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a references to set</doc>
              <array name="GLib.Array" c:type="GArray*">
                <type name="guint64"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_headers">
        <callback name="get_headers">
          <return-value transfer-ownership="none" nullable="1">
            <doc xml:space="preserve">All the message headers of the associated
  message, or %NULL, when none are available.</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="const CamelMessageInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="take_headers">
        <callback name="take_headers">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Whether the value changed.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mi" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMessageInfo</doc>
              <type name="MessageInfo" c:type="CamelMessageInfo*"/>
            </parameter>
            <parameter name="headers"
                       transfer-ownership="full"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">headers to set, as #CamelNameValueArray, or %NULL</doc>
              <type name="NameValueArray" c:type="CamelNameValueArray*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MessageInfoPrivate"
            c:type="CamelMessageInfoPrivate"
            disguised="1">
    </record>
    <class name="MimeFilter"
           c:symbol-prefix="mime_filter"
           c:type="CamelMimeFilter"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CamelMimeFilter"
           glib:get-type="camel_mime_filter_get_type"
           glib:type-struct="MimeFilterClass">
      <constructor name="new" c:identifier="camel_mime_filter_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilter object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilter</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
      </constructor>
      <virtual-method name="complete" invoker="complete">
        <doc xml:space="preserve">Passes the input buffer, @in, through @filter and generates an
output buffer, @out and makes sure that all data is flushed to the
output buffer. This must be the last filtering call made, no
further calls to camel_mime_filter_filter() may be called on @filter
until @filter has been reset using camel_mime_filter_reset().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">input buffer</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of @in</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="prespace" transfer-ownership="none">
            <doc xml:space="preserve">amount of prespace</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output buffer (to be set)</doc>
            <array length="4" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="outlen"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the length of the output buffer (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="outprespace"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output prespace length (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="filter" invoker="filter">
        <doc xml:space="preserve">Passes the input buffer, @in, through @filter and generates an
output buffer, @out.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">input buffer</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of @in</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="prespace" transfer-ownership="none">
            <doc xml:space="preserve">amount of prespace</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output buffer (to be set)</doc>
            <array length="4" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="outlen"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the length of the output buffer (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="outprespace"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output prespace length (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset" invoker="reset">
        <doc xml:space="preserve">Resets the state on @filter so that it may be used again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="backup" c:identifier="camel_mime_filter_backup">
        <doc xml:space="preserve">Saves @data to be used as prespace input data to the next call to
camel_mime_filter_filter() or camel_mime_filter_complete().

Note: New calls replace old data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">data buffer to backup</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete" c:identifier="camel_mime_filter_complete">
        <doc xml:space="preserve">Passes the input buffer, @in, through @filter and generates an
output buffer, @out and makes sure that all data is flushed to the
output buffer. This must be the last filtering call made, no
further calls to camel_mime_filter_filter() may be called on @filter
until @filter has been reset using camel_mime_filter_reset().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">input buffer</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of @in</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="prespace" transfer-ownership="none">
            <doc xml:space="preserve">amount of prespace</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output buffer (to be set)</doc>
            <array length="4" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="outlen"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the length of the output buffer (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="outprespace"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output prespace length (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter" c:identifier="camel_mime_filter_filter">
        <doc xml:space="preserve">Passes the input buffer, @in, through @filter and generates an
output buffer, @out.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">input buffer</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of @in</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="prespace" transfer-ownership="none">
            <doc xml:space="preserve">amount of prespace</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output buffer (to be set)</doc>
            <array length="4" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="outlen"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the length of the output buffer (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="outprespace"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to the output prespace length (to be set)</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="camel_mime_filter_reset">
        <doc xml:space="preserve">Resets the state on @filter so that it may be used again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_size" c:identifier="camel_mime_filter_set_size">
        <doc xml:space="preserve">Ensure that @filter has enough storage space to store @size bytes
for filter output.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">requested amount of storage space</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="keep" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to keep existing buffered data or %FALSE otherwise</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MimeFilterPrivate" c:type="CamelMimeFilterPrivate*"/>
      </field>
      <field name="outreal">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="outbuf">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="outptr">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="outsize">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="outpre">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="backbuf">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="backsize">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="backlen">
        <type name="gsize" c:type="gsize"/>
      </field>
    </class>
    <class name="MimeFilterBasic"
           c:symbol-prefix="mime_filter_basic"
           c:type="CamelMimeFilterBasic"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterBasic"
           glib:get-type="camel_mime_filter_basic_get_type"
           glib:type-struct="MimeFilterBasicClass">
      <constructor name="new" c:identifier="camel_mime_filter_basic_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterBasic object of type @type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterBasic object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterBasicType type</doc>
            <type name="MimeFilterBasicType"
                  c:type="CamelMimeFilterBasicType"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterBasicPrivate"
              c:type="CamelMimeFilterBasicPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterBasicClass"
            c:type="CamelMimeFilterBasicClass"
            glib:is-gtype-struct-for="MimeFilterBasic">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterBasicPrivate"
            c:type="CamelMimeFilterBasicPrivate"
            disguised="1">
    </record>
    <enumeration name="MimeFilterBasicType"
                 glib:type-name="CamelMimeFilterBasicType"
                 glib:get-type="camel_mime_filter_basic_type_get_type"
                 c:type="CamelMimeFilterBasicType">
      <member name="invalid"
              value="0"
              c:identifier="CAMEL_MIME_FILTER_BASIC_INVALID"
              glib:nick="invalid">
      </member>
      <member name="base64_enc"
              value="1"
              c:identifier="CAMEL_MIME_FILTER_BASIC_BASE64_ENC"
              glib:nick="base64-enc">
      </member>
      <member name="base64_dec"
              value="2"
              c:identifier="CAMEL_MIME_FILTER_BASIC_BASE64_DEC"
              glib:nick="base64-dec">
      </member>
      <member name="qp_enc"
              value="3"
              c:identifier="CAMEL_MIME_FILTER_BASIC_QP_ENC"
              glib:nick="qp-enc">
      </member>
      <member name="qp_dec"
              value="4"
              c:identifier="CAMEL_MIME_FILTER_BASIC_QP_DEC"
              glib:nick="qp-dec">
      </member>
      <member name="uu_enc"
              value="5"
              c:identifier="CAMEL_MIME_FILTER_BASIC_UU_ENC"
              glib:nick="uu-enc">
      </member>
      <member name="uu_dec"
              value="6"
              c:identifier="CAMEL_MIME_FILTER_BASIC_UU_DEC"
              glib:nick="uu-dec">
      </member>
    </enumeration>
    <class name="MimeFilterBestenc"
           c:symbol-prefix="mime_filter_bestenc"
           c:type="CamelMimeFilterBestenc"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterBestenc"
           glib:get-type="camel_mime_filter_bestenc_get_type"
           glib:type-struct="MimeFilterBestencClass">
      <constructor name="new" c:identifier="camel_mime_filter_bestenc_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterBestenc object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterBestenc object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a bitmask of data required.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_best_charset"
              c:identifier="camel_mime_filter_bestenc_get_best_charset">
        <doc xml:space="preserve">Gets the best charset that can be used to contain this content.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the best charset to use to encode the input
text filtered by @filter</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterBestenc object</doc>
            <type name="MimeFilterBestenc" c:type="CamelMimeFilterBestenc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_best_encoding"
              c:identifier="camel_mime_filter_bestenc_get_best_encoding">
        <doc xml:space="preserve">Get the best encoding, given specific constraints, that can be used to
encode a stream of bytes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the best encoding to use</doc>
          <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterBestenc object</doc>
            <type name="MimeFilterBestenc" c:type="CamelMimeFilterBestenc*"/>
          </instance-parameter>
          <parameter name="required" transfer-ownership="none">
            <doc xml:space="preserve">maximum level of output encoding allowed.</doc>
            <type name="BestencEncoding" c:type="CamelBestencEncoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags"
              c:identifier="camel_mime_filter_bestenc_set_flags">
        <doc xml:space="preserve">Set the flags for subsequent operations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterBestenc object</doc>
            <type name="MimeFilterBestenc" c:type="CamelMimeFilterBestenc*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">bestenc filter flags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterBestencPrivate"
              c:type="CamelMimeFilterBestencPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterBestencClass"
            c:type="CamelMimeFilterBestencClass"
            glib:is-gtype-struct-for="MimeFilterBestenc">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterBestencPrivate"
            c:type="CamelMimeFilterBestencPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterCRLF"
           c:symbol-prefix="mime_filter_crlf"
           c:type="CamelMimeFilterCRLF"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterCRLF"
           glib:get-type="camel_mime_filter_crlf_get_type"
           glib:type-struct="MimeFilterCRLFClass">
      <constructor name="new" c:identifier="camel_mime_filter_crlf_new">
        <doc xml:space="preserve">Create a new #CamelMimeFiletrCRLF object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterCRLF object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">encode vs decode</doc>
            <type name="MimeFilterCRLFDirection"
                  c:type="CamelMimeFilterCRLFDirection"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to perform SMTP dot-escaping</doc>
            <type name="MimeFilterCRLFMode" c:type="CamelMimeFilterCRLFMode"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterCRLFPrivate"
              c:type="CamelMimeFilterCRLFPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterCRLFClass"
            c:type="CamelMimeFilterCRLFClass"
            glib:is-gtype-struct-for="MimeFilterCRLF">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="MimeFilterCRLFDirection"
                 glib:type-name="CamelMimeFilterCRLFDirection"
                 glib:get-type="camel_mime_filter_crlf_direction_get_type"
                 c:type="CamelMimeFilterCRLFDirection">
      <member name="encode"
              value="0"
              c:identifier="CAMEL_MIME_FILTER_CRLF_ENCODE"
              glib:nick="encode">
      </member>
      <member name="decode"
              value="1"
              c:identifier="CAMEL_MIME_FILTER_CRLF_DECODE"
              glib:nick="decode">
      </member>
    </enumeration>
    <enumeration name="MimeFilterCRLFMode"
                 glib:type-name="CamelMimeFilterCRLFMode"
                 glib:get-type="camel_mime_filter_crlf_mode_get_type"
                 c:type="CamelMimeFilterCRLFMode">
      <member name="dots"
              value="0"
              c:identifier="CAMEL_MIME_FILTER_CRLF_MODE_CRLF_DOTS"
              glib:nick="dots">
      </member>
      <member name="only"
              value="1"
              c:identifier="CAMEL_MIME_FILTER_CRLF_MODE_CRLF_ONLY"
              glib:nick="only">
      </member>
    </enumeration>
    <record name="MimeFilterCRLFPrivate"
            c:type="CamelMimeFilterCRLFPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterCanon"
           c:symbol-prefix="mime_filter_canon"
           c:type="CamelMimeFilterCanon"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterCanon"
           glib:get-type="camel_mime_filter_canon_get_type"
           glib:type-struct="MimeFilterCanonClass">
      <constructor name="new" c:identifier="camel_mime_filter_canon_new">
        <doc xml:space="preserve">Create a new filter to canonicalise an input stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterCanon</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">bitwise flags defining the behaviour of the filter</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterCanonPrivate"
              c:type="CamelMimeFilterCanonPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterCanonClass"
            c:type="CamelMimeFilterCanonClass"
            glib:is-gtype-struct-for="MimeFilterCanon">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterCanonPrivate"
            c:type="CamelMimeFilterCanonPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterCharset"
           c:symbol-prefix="mime_filter_charset"
           c:type="CamelMimeFilterCharset"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterCharset"
           glib:get-type="camel_mime_filter_charset_get_type"
           glib:type-struct="MimeFilterCharsetClass">
      <constructor name="new" c:identifier="camel_mime_filter_charset_new">
        <doc xml:space="preserve">Create a new #CamelMimeFiletrCharset object to convert text from
@from_charset to @to_charset.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterCharset object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="from_charset" transfer-ownership="none">
            <doc xml:space="preserve">charset to convert from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="to_charset" transfer-ownership="none">
            <doc xml:space="preserve">charset to convert to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterCharsetPrivate"
              c:type="CamelMimeFilterCharsetPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterCharsetClass"
            c:type="CamelMimeFilterCharsetClass"
            glib:is-gtype-struct-for="MimeFilterCharset">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterCharsetPrivate"
            c:type="CamelMimeFilterCharsetPrivate"
            disguised="1">
    </record>
    <record name="MimeFilterClass"
            c:type="CamelMimeFilterClass"
            glib:is-gtype-struct-for="MimeFilter">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="filter">
        <callback name="filter">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeFilter object</doc>
              <type name="MimeFilter" c:type="CamelMimeFilter*"/>
            </parameter>
            <parameter name="in" transfer-ownership="none">
              <doc xml:space="preserve">input buffer</doc>
              <array length="2" zero-terminated="0" c:type="gchar*">
                <type name="utf8" c:type="gchar"/>
              </array>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <doc xml:space="preserve">length of @in</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="prespace" transfer-ownership="none">
              <doc xml:space="preserve">amount of prespace</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="out"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">pointer to the output buffer (to be set)</doc>
              <array length="5" zero-terminated="0" c:type="gchar**">
                <type name="utf8" c:type="gchar*"/>
              </array>
            </parameter>
            <parameter name="outlen"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">pointer to the length of the output buffer (to be set)</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
            <parameter name="outprespace"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">pointer to the output prespace length (to be set)</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="complete">
        <callback name="complete">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeFilter object</doc>
              <type name="MimeFilter" c:type="CamelMimeFilter*"/>
            </parameter>
            <parameter name="in" transfer-ownership="none">
              <doc xml:space="preserve">input buffer</doc>
              <array length="2" zero-terminated="0" c:type="gchar*">
                <type name="utf8" c:type="gchar"/>
              </array>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <doc xml:space="preserve">length of @in</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="prespace" transfer-ownership="none">
              <doc xml:space="preserve">amount of prespace</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="out"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">pointer to the output buffer (to be set)</doc>
              <array length="5" zero-terminated="0" c:type="gchar**">
                <type name="utf8" c:type="gchar*"/>
              </array>
            </parameter>
            <parameter name="outlen"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">pointer to the length of the output buffer (to be set)</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
            <parameter name="outprespace"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">pointer to the output prespace length (to be set)</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeFilter object</doc>
              <type name="MimeFilter" c:type="CamelMimeFilter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="MimeFilterEnriched"
           c:symbol-prefix="mime_filter_enriched"
           c:type="CamelMimeFilterEnriched"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterEnriched"
           glib:get-type="camel_mime_filter_enriched_get_type"
           glib:type-struct="MimeFilterEnrichedClass">
      <constructor name="new" c:identifier="camel_mime_filter_enriched_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterEnriched object to convert input text
streams from text/plain into text/enriched or text/richtext.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterEnriched object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">bitwise set of flags to specify filter behaviour</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterEnrichedPrivate"
              c:type="CamelMimeFilterEnrichedPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterEnrichedClass"
            c:type="CamelMimeFilterEnrichedClass"
            glib:is-gtype-struct-for="MimeFilterEnriched">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterEnrichedPrivate"
            c:type="CamelMimeFilterEnrichedPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterFrom"
           c:symbol-prefix="mime_filter_from"
           c:type="CamelMimeFilterFrom"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterFrom"
           glib:get-type="camel_mime_filter_from_get_type"
           glib:type-struct="MimeFilterFromClass">
      <constructor name="new" c:identifier="camel_mime_filter_from_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterFrom object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterFrom object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterFromPrivate"
              c:type="CamelMimeFilterFromPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterFromClass"
            c:type="CamelMimeFilterFromClass"
            glib:is-gtype-struct-for="MimeFilterFrom">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterFromPrivate"
            c:type="CamelMimeFilterFromPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterGZip"
           c:symbol-prefix="mime_filter_gzip"
           c:type="CamelMimeFilterGZip"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterGZip"
           glib:get-type="camel_mime_filter_gzip_get_type"
           glib:type-struct="MimeFilterGZipClass">
      <constructor name="new" c:identifier="camel_mime_filter_gzip_new">
        <doc xml:space="preserve">Creates a new gzip (or gunzip) filter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new gzip (or gunzip) filter.</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">zip or unzip</doc>
            <type name="MimeFilterGZipMode" c:type="CamelMimeFilterGZipMode"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">compression level</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterGZipPrivate"
              c:type="CamelMimeFilterGZipPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterGZipClass"
            c:type="CamelMimeFilterGZipClass"
            glib:is-gtype-struct-for="MimeFilterGZip">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="MimeFilterGZipMode"
                 glib:type-name="CamelMimeFilterGZipMode"
                 glib:get-type="camel_mime_filter_gzip_mode_get_type"
                 c:type="CamelMimeFilterGZipMode">
      <member name="zip"
              value="0"
              c:identifier="CAMEL_MIME_FILTER_GZIP_MODE_ZIP"
              glib:nick="zip">
      </member>
      <member name="unzip"
              value="1"
              c:identifier="CAMEL_MIME_FILTER_GZIP_MODE_UNZIP"
              glib:nick="unzip">
      </member>
    </enumeration>
    <record name="MimeFilterGZipPrivate"
            c:type="CamelMimeFilterGZipPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterHTML"
           c:symbol-prefix="mime_filter_html"
           c:type="CamelMimeFilterHTML"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterHTML"
           glib:get-type="camel_mime_filter_html_get_type"
           glib:type-struct="MimeFilterHTMLClass">
      <constructor name="new" c:identifier="camel_mime_filter_html_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterHTML object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterHTML object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterHTMLPrivate"
              c:type="CamelMimeFilterHTMLPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterHTMLClass"
            c:type="CamelMimeFilterHTMLClass"
            glib:is-gtype-struct-for="MimeFilterHTML">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterHTMLPrivate"
            c:type="CamelMimeFilterHTMLPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterIndex"
           c:symbol-prefix="mime_filter_index"
           c:type="CamelMimeFilterIndex"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterIndex"
           glib:get-type="camel_mime_filter_index_get_type"
           glib:type-struct="MimeFilterIndexClass">
      <constructor name="new" c:identifier="camel_mime_filter_index_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterIndex based on @index.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterIndex object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex object</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="set_index"
              c:identifier="camel_mime_filter_index_set_index">
        <doc xml:space="preserve">Set @index on @filter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterIndex object</doc>
            <type name="MimeFilterIndex" c:type="CamelMimeFilterIndex*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndex object</doc>
            <type name="Index" c:type="CamelIndex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="camel_mime_filter_index_set_name">
        <doc xml:space="preserve">Set the match name for any indexed words.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterIndex object</doc>
            <type name="MimeFilterIndex" c:type="CamelMimeFilterIndex*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelIndexName object</doc>
            <type name="IndexName" c:type="CamelIndexName*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterIndexPrivate"
              c:type="CamelMimeFilterIndexPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterIndexClass"
            c:type="CamelMimeFilterIndexClass"
            glib:is-gtype-struct-for="MimeFilterIndex">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterIndexPrivate"
            c:type="CamelMimeFilterIndexPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterLinewrap"
           c:symbol-prefix="mime_filter_linewrap"
           c:type="CamelMimeFilterLinewrap"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterLinewrap"
           glib:get-type="camel_mime_filter_linewrap_get_type"
           glib:type-struct="MimeFilterLinewrapClass">
      <constructor name="new" c:identifier="camel_mime_filter_linewrap_new">
        <return-value transfer-ownership="full">
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="preferred_len" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_len" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="indent_char" transfer-ownership="none">
            <type name="gchar" c:type="gchar"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterLinewrapPrivate"
              c:type="CamelMimeFilterLinewrapPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterLinewrapClass"
            c:type="CamelMimeFilterLinewrapClass"
            glib:is-gtype-struct-for="MimeFilterLinewrap">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterLinewrapPrivate"
            c:type="CamelMimeFilterLinewrapPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterPgp"
           c:symbol-prefix="mime_filter_pgp"
           c:type="CamelMimeFilterPgp"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterPgp"
           glib:get-type="camel_mime_filter_pgp_get_type"
           glib:type-struct="MimeFilterPgpClass">
      <constructor name="new" c:identifier="camel_mime_filter_pgp_new">
        <return-value transfer-ownership="full">
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterPgpPrivate" c:type="CamelMimeFilterPgpPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterPgpClass"
            c:type="CamelMimeFilterPgpClass"
            glib:is-gtype-struct-for="MimeFilterPgp">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterPgpPrivate"
            c:type="CamelMimeFilterPgpPrivate"
            disguised="1">
    </record>
    <record name="MimeFilterPrivate"
            c:type="CamelMimeFilterPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterProgress"
           c:symbol-prefix="mime_filter_progress"
           c:type="CamelMimeFilterProgress"
           version="2.24"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterProgress"
           glib:get-type="camel_mime_filter_progress_get_type"
           glib:type-struct="MimeFilterProgressClass">
      <constructor name="new"
                   c:identifier="camel_mime_filter_progress_new"
                   version="2.24">
        <doc xml:space="preserve">Create a new #CamelMimeFilterProgress object that will report streaming
progress.  While the function will silently accept @cancellable being
%NULL or a plain #GCancellable for convenience sake, no progress will be
reported unless @cancellable is a #CamelOperation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilter object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelOperation cast as a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="total" transfer-ownership="none">
            <doc xml:space="preserve">total number of bytes to report progress on</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="MimeFilterProgressPrivate"
              c:type="CamelMimeFilterProgressPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterProgressClass"
            c:type="CamelMimeFilterProgressClass"
            glib:is-gtype-struct-for="MimeFilterProgress">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterProgressPrivate"
            c:type="CamelMimeFilterProgressPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterToHTML"
           c:symbol-prefix="mime_filter_tohtml"
           c:type="CamelMimeFilterToHTML"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterToHTML"
           glib:get-type="camel_mime_filter_tohtml_get_type"
           glib:type-struct="MimeFilterToHTMLClass">
      <constructor name="new" c:identifier="camel_mime_filter_tohtml_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterToHTML object to convert plain text
into HTML.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterToHTML object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">bitwise flags defining the behaviour</doc>
            <type name="MimeFilterToHTMLFlags"
                  c:type="CamelMimeFilterToHTMLFlags"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">color to use when highlighting quoted text</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterToHTMLPrivate"
              c:type="CamelMimeFilterToHTMLPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterToHTMLClass"
            c:type="CamelMimeFilterToHTMLClass"
            glib:is-gtype-struct-for="MimeFilterToHTML">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="MimeFilterToHTMLFlags"
              glib:type-name="CamelMimeFilterToHTMLFlags"
              glib:get-type="camel_mime_filter_to_html_flags_get_type"
              c:type="CamelMimeFilterToHTMLFlags">
      <doc xml:space="preserve">Flags for converting text/plain content into text/html.</doc>
      <member name="pre"
              value="1"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_PRE"
              glib:nick="pre">
        <doc xml:space="preserve">Enclose the content in &amp;lt;pre&amp;gt; ... &amp;lt;/pre&amp;gt; tags.</doc>
      </member>
      <member name="convert_nl"
              value="2"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_CONVERT_NL"
              glib:nick="convert-nl">
        <doc xml:space="preserve">Convert newline characters to &amp;lt;br&amp;gt; tags.</doc>
      </member>
      <member name="convert_spaces"
              value="4"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_CONVERT_SPACES"
              glib:nick="convert-spaces">
        <doc xml:space="preserve">Convert space and tab characters to a non-breaking space (&amp;amp;nbsp;).</doc>
      </member>
      <member name="convert_urls"
              value="8"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_CONVERT_URLS"
              glib:nick="convert-urls">
        <doc xml:space="preserve">Convert recognized URLs to &amp;lt;a href="foo"&amp;gt;foo&amp;lt;/a&amp;gt;.</doc>
      </member>
      <member name="mark_citation"
              value="16"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_MARK_CITATION"
              glib:nick="mark-citation">
        <doc xml:space="preserve">Color quoted lines (lines beginning with '&amp;gt;').</doc>
      </member>
      <member name="convert_addresses"
              value="32"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_CONVERT_ADDRESSES"
              glib:nick="convert-addresses">
        <doc xml:space="preserve">Convert mailto: URLs to &amp;lt;a href="mailto:foo"&amp;gt;mailto:foo&amp;lt;/a&amp;gt;.</doc>
      </member>
      <member name="escape_8bit"
              value="64"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_ESCAPE_8BIT"
              glib:nick="escape-8bit">
        <doc xml:space="preserve">Convert 8-bit characters to escaped hexdecimal (&amp;amp;#nnn;).</doc>
      </member>
      <member name="cite"
              value="128"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_CITE"
              glib:nick="cite">
        <doc xml:space="preserve">Prefix each line with "&amp;gt; ".</doc>
      </member>
      <member name="preserve_8bit"
              value="256"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_PRESERVE_8BIT"
              glib:nick="preserve-8bit">
        <doc xml:space="preserve">This flag is not used by #CamelMimeFilterToHTML.</doc>
      </member>
      <member name="format_flowed"
              value="512"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_FORMAT_FLOWED"
              glib:nick="format-flowed">
        <doc xml:space="preserve">This flag is not used by #CamelMimeFilterToHTML.</doc>
      </member>
      <member name="quote_citation"
              value="1024"
              c:identifier="CAMEL_MIME_FILTER_TOHTML_QUOTE_CITATION"
              glib:nick="quote-citation">
        <doc xml:space="preserve">Group lines beginning with one or more '&amp;gt;' characters in
    &amp;lt;blockquote type="cite"&amp;gt; ... &amp;lt;/blockquote&amp;gt; tags. The tags
    are nested according to the number of '&amp;gt;' characters.</doc>
      </member>
    </bitfield>
    <record name="MimeFilterToHTMLPrivate"
            c:type="CamelMimeFilterToHTMLPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterWindows"
           c:symbol-prefix="mime_filter_windows"
           c:type="CamelMimeFilterWindows"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterWindows"
           glib:get-type="camel_mime_filter_windows_get_type"
           glib:type-struct="MimeFilterWindowsClass">
      <constructor name="new" c:identifier="camel_mime_filter_windows_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterWindows object that will analyse
whether or not the text is really encoded in @claimed_charset.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilter object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="claimed_charset" transfer-ownership="none">
            <doc xml:space="preserve">ISO charset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="is_windows_charset"
              c:identifier="camel_mime_filter_windows_is_windows_charset">
        <doc xml:space="preserve">Get whether or not the textual content filtered by @filter is
really in a Microsoft Windows charset rather than the claimed ISO
charset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the text was found to be in a Microsoft Windows
CP125x charset or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterWindows object</doc>
            <type name="MimeFilterWindows" c:type="CamelMimeFilterWindows*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="real_charset"
              c:identifier="camel_mime_filter_windows_real_charset">
        <doc xml:space="preserve">Get the name of the actual charset used to encode the textual
content filtered by @filter (it will either be the original
claimed_charset passed in at creation time or the Windows-CP125x
equivalent).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the actual charset</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterWindows object</doc>
            <type name="MimeFilterWindows" c:type="CamelMimeFilterWindows*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterWindowsPrivate"
              c:type="CamelMimeFilterWindowsPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterWindowsClass"
            c:type="CamelMimeFilterWindowsClass"
            glib:is-gtype-struct-for="MimeFilterWindows">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeFilterWindowsPrivate"
            c:type="CamelMimeFilterWindowsPrivate"
            disguised="1">
    </record>
    <class name="MimeFilterYenc"
           c:symbol-prefix="mime_filter_yenc"
           c:type="CamelMimeFilterYenc"
           parent="MimeFilter"
           glib:type-name="CamelMimeFilterYenc"
           glib:get-type="camel_mime_filter_yenc_get_type"
           glib:type-struct="MimeFilterYencClass">
      <constructor name="new" c:identifier="camel_mime_filter_yenc_new">
        <doc xml:space="preserve">Create a new #CamelMimeFilterYenc filter object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeFilterYenc object</doc>
          <type name="MimeFilter" c:type="CamelMimeFilter*"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">encode direction</doc>
            <type name="MimeFilterYencDirection"
                  c:type="CamelMimeFilterYencDirection"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_crc" c:identifier="camel_mime_filter_yenc_get_crc">
        <doc xml:space="preserve">Get the computed crc or (#guint32) -1 on fail.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the computed crc or (#guint32) -1 on fail.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="yenc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFiletrYenc object</doc>
            <type name="MimeFilterYenc" c:type="CamelMimeFilterYenc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pcrc" c:identifier="camel_mime_filter_yenc_get_pcrc">
        <doc xml:space="preserve">Get the computed part crc or (#guint32) %-1 on fail.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the computed part crc or (#guint32) %-1 on fail.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="yenc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterYenc object</doc>
            <type name="MimeFilterYenc" c:type="CamelMimeFilterYenc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_crc" c:identifier="camel_mime_filter_yenc_set_crc">
        <doc xml:space="preserve">Sets the current crc32 value on the yEnc filter @yenc to @crc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="yenc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterYenc object</doc>
            <type name="MimeFilterYenc" c:type="CamelMimeFilterYenc*"/>
          </instance-parameter>
          <parameter name="crc" transfer-ownership="none">
            <doc xml:space="preserve">crc32 value</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state" c:identifier="camel_mime_filter_yenc_set_state">
        <doc xml:space="preserve">Sets the current state of the yencoder/ydecoder</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="yenc" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilterYenc object</doc>
            <type name="MimeFilterYenc" c:type="CamelMimeFilterYenc*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">encode/decode state</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="MimeFilter" c:type="CamelMimeFilter"/>
      </field>
      <field name="priv">
        <type name="MimeFilterYencPrivate"
              c:type="CamelMimeFilterYencPrivate*"/>
      </field>
    </class>
    <record name="MimeFilterYencClass"
            c:type="CamelMimeFilterYencClass"
            glib:is-gtype-struct-for="MimeFilterYenc">
      <field name="parent_class">
        <type name="MimeFilterClass" c:type="CamelMimeFilterClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="MimeFilterYencDirection"
                 glib:type-name="CamelMimeFilterYencDirection"
                 glib:get-type="camel_mime_filter_yenc_direction_get_type"
                 c:type="CamelMimeFilterYencDirection">
      <member name="encode"
              value="0"
              c:identifier="CAMEL_MIME_FILTER_YENC_DIRECTION_ENCODE"
              glib:nick="encode">
      </member>
      <member name="decode"
              value="1"
              c:identifier="CAMEL_MIME_FILTER_YENC_DIRECTION_DECODE"
              glib:nick="decode">
      </member>
    </enumeration>
    <record name="MimeFilterYencPrivate"
            c:type="CamelMimeFilterYencPrivate"
            disguised="1">
    </record>
    <class name="MimeMessage"
           c:symbol-prefix="mime_message"
           c:type="CamelMimeMessage"
           parent="MimePart"
           glib:type-name="CamelMimeMessage"
           glib:get-type="camel_mime_message_get_type"
           glib:type-struct="MimeMessageClass">
      <constructor name="new" c:identifier="camel_mime_message_new">
        <doc xml:space="preserve">Create a new #CamelMimeMessage object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimeMessage object</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </return-value>
      </constructor>
      <method name="build_mbox_from"
              c:identifier="camel_mime_message_build_mbox_from">
        <doc xml:space="preserve">Build an MBox from-line from @message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an MBox from-line suitable for use in an mbox file</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="camel_mime_message_dump">
        <doc xml:space="preserve">Dump information about the mime message to stdout.

If body is TRUE, then dump body content of the message as well.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="body" transfer-ownership="none">
            <doc xml:space="preserve">whether to dump also message body</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="encode_8bit_parts"
              c:identifier="camel_mime_message_encode_8bit_parts">
        <doc xml:space="preserve">Encode all message parts to a suitable transfer encoding for transport (7bit clean).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_date" c:identifier="camel_mime_message_get_date">
        <doc xml:space="preserve">Get the date and GMT offset of a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the date of the message</doc>
          <type name="glong" c:type="time_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">output for the GMT offset</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_received"
              c:identifier="camel_mime_message_get_date_received">
        <doc xml:space="preserve">Get the received date and GMT offset of a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the received date of the message</doc>
          <type name="glong" c:type="time_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">output for the GMT offset</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_from" c:identifier="camel_mime_message_get_from">
        <doc xml:space="preserve">Get the from address of a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the from address of the message</doc>
          <type name="InternetAddress" c:type="CamelInternetAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message_id"
              c:identifier="camel_mime_message_get_message_id">
        <doc xml:space="preserve">Get the message-id of a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the message-id of a message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_part_by_content_id"
              c:identifier="camel_mime_message_get_part_by_content_id">
        <doc xml:space="preserve">Get a MIME part by id from a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MIME part with the requested id or %NULL if not found</doc>
          <type name="MimePart" c:type="CamelMimePart*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="content_id" transfer-ownership="none">
            <doc xml:space="preserve">content-id to search for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_recipients"
              c:identifier="camel_mime_message_get_recipients">
        <doc xml:space="preserve">Get the message recipients of a specified type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the requested recipients</doc>
          <type name="InternetAddress" c:type="CamelInternetAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">recipient type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_reply_to"
              c:identifier="camel_mime_message_get_reply_to">
        <doc xml:space="preserve">Get the Reply-To of a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Reply-To address of the message</doc>
          <type name="InternetAddress" c:type="CamelInternetAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source" c:identifier="camel_mime_message_get_source">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject" c:identifier="camel_mime_message_get_subject">
        <doc xml:space="preserve">Get the UTF-8 subject text of a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the message subject</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_8bit_parts"
              c:identifier="camel_mime_message_has_8bit_parts">
        <doc xml:space="preserve">Find out if a message contains 8bit or binary encoded parts.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message contains 8bit parts or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_attachment"
              c:identifier="camel_mime_message_has_attachment"
              version="2.28">
        <doc xml:space="preserve">Returns whether message contains at least one attachment part.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_best_encoding"
              c:identifier="camel_mime_message_set_best_encoding">
        <doc xml:space="preserve">Re-encode all message parts to conform with the required encoding rules.

If @enctype is #CAMEL_BESTENC_7BIT, then all parts will be re-encoded into
one of the 7bit transfer encodings. If @enctype is #CAMEL_BESTENC_8bit, all
parts will be re-encoded to either a 7bit encoding or, if the part is 8bit
text, allowed to stay 8bit. If @enctype is #CAMEL_BESTENC_BINARY, then binary
parts will be encoded as binary and 8bit textual parts will be encoded as 8bit.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="required" transfer-ownership="none">
            <doc xml:space="preserve">a bitwise ORing of #CAMEL_BESTENC_GET_ENCODING and #CAMEL_BESTENC_GET_CHARSET</doc>
            <type name="BestencRequired" c:type="CamelBestencRequired"/>
          </parameter>
          <parameter name="enctype" transfer-ownership="none">
            <doc xml:space="preserve">an encoding to enforce</doc>
            <type name="BestencEncoding" c:type="CamelBestencEncoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_date" c:identifier="camel_mime_message_set_date">
        <doc xml:space="preserve">Set the date on a message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="date" transfer-ownership="none">
            <doc xml:space="preserve">a time_t date</doc>
            <type name="glong" c:type="time_t"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">an offset from GMT</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from" c:identifier="camel_mime_message_set_from">
        <doc xml:space="preserve">Set the from address of a message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress object</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message_id"
              c:identifier="camel_mime_message_set_message_id">
        <doc xml:space="preserve">Set the message-id on a message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="message_id" transfer-ownership="none">
            <doc xml:space="preserve">id of the message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_recipients"
              c:identifier="camel_mime_message_set_recipients">
        <doc xml:space="preserve">Set the recipients of a message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">recipient type (one of #CAMEL_RECIPIENT_TYPE_TO, #CAMEL_RECIPIENT_TYPE_CC, or #CAMEL_RECIPIENT_TYPE_BCC)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="recipients" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress with the recipient addresses set</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_reply_to"
              c:identifier="camel_mime_message_set_reply_to">
        <doc xml:space="preserve">Set the Reply-To of a message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="reply_to" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelInternetAddress object</doc>
            <type name="InternetAddress" c:type="CamelInternetAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source" c:identifier="camel_mime_message_set_source">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="source_uid" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_subject" c:identifier="camel_mime_message_set_subject">
        <doc xml:space="preserve">Set the subject text of a message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage object</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </instance-parameter>
          <parameter name="subject" transfer-ownership="none">
            <doc xml:space="preserve">UTF-8 message subject</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="MimePart" c:type="CamelMimePart"/>
      </field>
      <field name="priv">
        <type name="MimeMessagePrivate" c:type="CamelMimeMessagePrivate*"/>
      </field>
    </class>
    <record name="MimeMessageClass"
            c:type="CamelMimeMessageClass"
            glib:is-gtype-struct-for="MimeMessage">
      <field name="parent_class">
        <type name="MimePartClass" c:type="CamelMimePartClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeMessagePrivate"
            c:type="CamelMimeMessagePrivate"
            disguised="1">
    </record>
    <class name="MimeParser"
           c:symbol-prefix="mime_parser"
           c:type="CamelMimeParser"
           parent="GObject.Object"
           glib:type-name="CamelMimeParser"
           glib:get-type="camel_mime_parser_get_type"
           glib:type-struct="MimeParserClass">
      <constructor name="new" c:identifier="camel_mime_parser_new">
        <doc xml:space="preserve">Create a new CamelMimeParser object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelMimeParser object</doc>
          <type name="MimeParser" c:type="CamelMimeParser*"/>
        </return-value>
      </constructor>
      <virtual-method name="content">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="headers"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="part">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="content_type"
              c:identifier="camel_mime_parser_content_type">
        <doc xml:space="preserve">Get the content type defined in the current part.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A content_type structure, or NULL if there
is no content-type defined for this part of state of the
parser.</doc>
          <type name="ContentType" c:type="CamelContentType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="drop_step" c:identifier="camel_mime_parser_drop_step">
        <doc xml:space="preserve">Drop the last step call.  This should only be used
in conjunction with seeking of the stream as the
stream may be in an undefined state relative to the
state of the parser.

Use this call with care.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_headers"
              c:identifier="camel_mime_parser_dup_headers"
              version="3.24">
        <doc xml:space="preserve">Get the list of the raw headers which are defined for the
current state of the parser.  These headers are valid
until the next call to parser_step(), or parser_drop_step().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The headers, or %NULL, if there are no headers
defined for the current part or state. Free it with camel_name_value_array_free().</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="errno" c:identifier="camel_mime_parser_errno">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="filter_add"
              c:identifier="camel_mime_parser_filter_add"
              version="2.22">
        <doc xml:space="preserve">Add a filter that will be applied to any body content before it is passed
to the caller.  Filters may be pipelined to perform multi-pass operations
on the content, and are applied in the order they were added.

Note that filters are only applied to the body content of messages, and once
a filter has been set, all content returned by a filter_step() with a state
of CAMEL_MIME_PARSER_STATE_BODY will have passed through the filter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">An id that may be passed to filter_remove() to remove
the filter, or -1 if the operation failed.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="mf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="filter_remove"
              c:identifier="camel_mime_parser_filter_remove"
              version="2.22">
        <doc xml:space="preserve">Remove a processing filter from the pipeline.  There is no
restriction on the order the filters can be removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">id of the filter to remove, as returned from camel_mime_parser_filter_add()</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="from_line"
              c:identifier="camel_mime_parser_from_line"
              version="2.22">
        <doc xml:space="preserve">Get the last scanned "From " line, from a recently scanned from.
This should only be called in the CAMEL_MIME_PARSER_STATE_FROM state.  The
from line will include the closing \n found (if there was one).

The return value will remain valid while in the CAMEL_MIME_PARSER_STATE_FROM
state, or any deeper state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The From line, or NULL if called out of context.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="header" c:identifier="camel_mime_parser_header">
        <doc xml:space="preserve">Lookup a header by name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The header value, or NULL if the header is not
defined.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">Name of header.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">Pointer that can receive the offset of the header in
the stream from the start of parsing.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_bytes"
              c:identifier="camel_mime_parser_init_with_bytes"
              version="3.12">
        <doc xml:space="preserve">Convenience function creates a #GMemoryInputStream from @bytes and hands
it off to camel_mime_parser_init_with_input_stream().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">a #GBytes containing the message content</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_fd"
              c:identifier="camel_mime_parser_init_with_fd">
        <doc xml:space="preserve">Initialise the scanner with an fd.  The scanner's offsets
will be relative to the current file position of the file
descriptor.  As a result, seekable descritors should
be seeked using the parser seek functions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Returns -1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">A valid file descriptor.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_input_stream"
              c:identifier="camel_mime_parser_init_with_input_stream"
              version="3.12">
        <doc xml:space="preserve">Initialize the scanner with @input_stream.  The scanner's offsets will
be relative to the current file position of the stream.  As a result,
seekable streams should only be seeked using the parser seek function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="input_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GInputStream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_stream"
              c:identifier="camel_mime_parser_init_with_stream"
              throws="1">
        <doc xml:space="preserve">Initialise the scanner with a source stream.  The scanner's
offsets will be relative to the current file position of
the stream.  As a result, seekable streams should only
be seeked using the parser seek function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream to init with</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="postface"
              c:identifier="camel_mime_parser_postface"
              version="2.22">
        <doc xml:space="preserve">Retrieve the postface text for the current multipart.
Only returns valid data when the current state if
CAMEL_MIME_PARSER_STATE_MULTIPART_END.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The postface text, or NULL if there wasn't any.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="preface"
              c:identifier="camel_mime_parser_preface"
              version="2.22">
        <doc xml:space="preserve">Retrieve the preface text for the current multipart.
Can only be used when the state is CAMEL_MIME_PARSER_STATE_MULTIPART_END.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The preface text, or NULL if there wasn't any.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="m" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_state" c:identifier="camel_mime_parser_push_state">
        <doc xml:space="preserve">Pre-load a new parser state.  Used to post-parse multipart content
without headers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mp" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="newstate" transfer-ownership="none">
            <doc xml:space="preserve">New state</doc>
            <type name="MimeParserState" c:type="CamelMimeParserState"/>
          </parameter>
          <parameter name="boundary" transfer-ownership="none">
            <doc xml:space="preserve">Boundary marker for state.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="camel_mime_parser_read" throws="1">
        <doc xml:space="preserve">Read at most @len bytes from the internal mime parser buffer.

Returns the address of the internal buffer in @databuffer,
and the length of useful data.

@len may be specified as %G_MAXSSIZE, in which case you will
get the full remainder of the buffer at each call.

Note that no parsing of the data read through this function
occurs, so no state changes occur, but the seek position
is updated appropriately.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes available, or -1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="databuffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The data buffer</doc>
            <array zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of data to read</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="scan_from" c:identifier="camel_mime_parser_scan_from">
        <doc xml:space="preserve">Tell the scanner if it should scan "^From " lines or not.

If the scanner is scanning from lines, two additional
states CAMEL_MIME_PARSER_STATE_FROM and CAMEL_MIME_PARSER_STATE_FROM_END will be returned
to the caller during parsing.

This may also be preceeded by an optional
CAMEL_MIME_PARSER_STATE_PRE_FROM state which contains the scanned data
found before the From line is encountered.  See also
scan_pre_from().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="scan_from" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the scanner should scan From lines.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="scan_pre_from"
              c:identifier="camel_mime_parser_scan_pre_from">
        <doc xml:space="preserve">Tell the scanner whether we want to know abou the pre-from
data during a scan.  If we do, then we may get an additional
state CAMEL_MIME_PARSER_STATE_PRE_FROM which returns the specified data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="scan_pre_from" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if we want to get pre-from data.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="camel_mime_parser_seek" version="2.22">
        <doc xml:space="preserve">Reset the source position to a known value.

Note that if the source stream/descriptor was not
positioned at 0 to begin with, and an absolute seek
is specified (whence != SEEK_CUR), then the seek
position may not match the desired seek position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new seek offset, or -1 on
an error (for example, trying to seek on a non-seekable
stream or file descriptor).</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve">Number of bytes to offset the seek by.</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
          <parameter name="whence" transfer-ownership="none">
            <doc xml:space="preserve">SEEK_SET, SEEK_CUR, SEEK_END</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_header_regex"
              c:identifier="camel_mime_parser_set_header_regex">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="matchstr" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="state" c:identifier="camel_mime_parser_state">
        <doc xml:space="preserve">Get the current parser state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current parser state.</doc>
          <type name="MimeParserState" c:type="CamelMimeParserState"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="step" c:identifier="camel_mime_parser_step">
        <doc xml:space="preserve">Parse the next part of the MIME message.  If _unstep()
has been called, then continue to return the same state
for that many calls.

If the step is CAMEL_MIME_PARSER_STATE_BODY then the databuffer and datalength
pointers will be setup to point to the internal data buffer
of the scanner and may be processed as required.  Any
filters will have already been applied to this data.

Refer to the state diagram elsewhere for a full listing of
the states an application is gauranteed to get from the
scanner.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current new state of the parser
is returned.</doc>
          <type name="MimeParserState" c:type="CamelMimeParserState"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
          <parameter name="databuffer"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Pointer to accept a pointer to the data
associated with this step (if any).  May be %NULL,
in which case datalength is also ingored.</doc>
            <array length="1" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="datalength"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Pointer to accept a pointer to the data
length associated with this step (if any).</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="stream" c:identifier="camel_mime_parser_stream">
        <doc xml:space="preserve">Get the stream, if any, the parser has been initialised
with.  May be used to setup sub-streams, but should not
be read from directly (without saving and restoring
the seek position in between).</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The stream from _init_with_stream(),
or NULL if the parser is reading from a file descriptor or is
uninitialised.</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="tell" c:identifier="camel_mime_parser_tell" version="2.22">
        <doc xml:space="preserve">Return the current scanning offset.  The meaning of this
value will depend on the current state of the parser.

An incomplete listing of the states:

CAMEL_MIME_PARSER_STATE_INITIAL, The start of the current message.
CAMEL_MIME_PARSER_STATE_HEADER, CAMEL_MIME_PARSER_STATE_MESSAGE, CAMEL_MIME_PARSER_STATE_MULTIPART, the character
position immediately after the end of the header.
CAMEL_MIME_PARSER_STATE_BODY, Position within the message of the start
of the current data block.
CAMEL_MIME_PARSER_STATE_*_END, The position of the character starting
the next section of the scan (the last position + 1 of
the respective current state).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">See above.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="tell_start_boundary"
              c:identifier="camel_mime_parser_tell_start_boundary"
              version="2.22">
        <doc xml:space="preserve">When parsing a multipart, this returns the start of the last
boundary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The start of the boundary, or -1 if there
was no boundary encountered yet.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="tell_start_from"
              c:identifier="camel_mime_parser_tell_start_from"
              version="2.22">
        <doc xml:space="preserve">If the parser is scanning From lines, then this returns
the position of the start of the From line.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The start of the from line, or -1 if there
was no From line, or From lines are not being scanned.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="tell_start_headers"
              c:identifier="camel_mime_parser_tell_start_headers"
              version="2.22">
        <doc xml:space="preserve">Find out the position within the file of where the
headers started, this is cached by the parser
at the time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The header start position, or -1 if
no headers were scanned in the current state.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unstep" c:identifier="camel_mime_parser_unstep">
        <doc xml:space="preserve">Cause the last step operation to repeat itself.  If this is
called repeated times, then the same step will be repeated
that many times.

Note that it is not possible to scan back using this function,
only to have a way of peeking the next state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">MIME parser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MimeParserPrivate" c:type="CamelMimeParserPrivate*"/>
      </field>
    </class>
    <record name="MimeParserClass"
            c:type="CamelMimeParserClass"
            glib:is-gtype-struct-for="MimeParser">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="message">
        <callback name="message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="MimeParser" c:type="CamelMimeParser*"/>
            </parameter>
            <parameter name="headers"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="part">
        <callback name="part">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="MimeParser" c:type="CamelMimeParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="content">
        <callback name="content">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parser" transfer-ownership="none">
              <type name="MimeParser" c:type="CamelMimeParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimeParserPrivate"
            c:type="CamelMimeParserPrivate"
            disguised="1">
    </record>
    <enumeration name="MimeParserState" c:type="CamelMimeParserState">
      <member name="initial"
              value="0"
              c:identifier="CAMEL_MIME_PARSER_STATE_INITIAL">
      </member>
      <member name="pre_from"
              value="1"
              c:identifier="CAMEL_MIME_PARSER_STATE_PRE_FROM">
      </member>
      <member name="from"
              value="2"
              c:identifier="CAMEL_MIME_PARSER_STATE_FROM">
      </member>
      <member name="header"
              value="3"
              c:identifier="CAMEL_MIME_PARSER_STATE_HEADER">
      </member>
      <member name="body"
              value="4"
              c:identifier="CAMEL_MIME_PARSER_STATE_BODY">
      </member>
      <member name="multipart"
              value="5"
              c:identifier="CAMEL_MIME_PARSER_STATE_MULTIPART">
      </member>
      <member name="message"
              value="6"
              c:identifier="CAMEL_MIME_PARSER_STATE_MESSAGE">
      </member>
      <member name="part"
              value="7"
              c:identifier="CAMEL_MIME_PARSER_STATE_PART">
      </member>
      <member name="end" value="8" c:identifier="CAMEL_MIME_PARSER_STATE_END">
      </member>
      <member name="eof" value="8" c:identifier="CAMEL_MIME_PARSER_STATE_EOF">
      </member>
      <member name="pre_from_end"
              value="9"
              c:identifier="CAMEL_MIME_PARSER_STATE_PRE_FROM_END">
      </member>
      <member name="from_end"
              value="10"
              c:identifier="CAMEL_MIME_PARSER_STATE_FROM_END">
      </member>
      <member name="header_end"
              value="11"
              c:identifier="CAMEL_MIME_PARSER_STATE_HEADER_END">
      </member>
      <member name="body_end"
              value="12"
              c:identifier="CAMEL_MIME_PARSER_STATE_BODY_END">
      </member>
      <member name="multipart_end"
              value="13"
              c:identifier="CAMEL_MIME_PARSER_STATE_MULTIPART_END">
      </member>
      <member name="message_end"
              value="14"
              c:identifier="CAMEL_MIME_PARSER_STATE_MESSAGE_END">
      </member>
    </enumeration>
    <class name="MimePart"
           c:symbol-prefix="mime_part"
           c:type="CamelMimePart"
           parent="Medium"
           glib:type-name="CamelMimePart"
           glib:get-type="camel_mime_part_get_type"
           glib:type-struct="MimePartClass">
      <constructor name="new" c:identifier="camel_mime_part_new">
        <doc xml:space="preserve">Create a new MIME part.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMimePart</doc>
          <type name="MimePart" c:type="CamelMimePart*"/>
        </return-value>
      </constructor>
      <virtual-method name="construct_from_parser_sync"
                      invoker="construct_from_parser_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Constructs a MIME part from a parser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="construct_content_from_parser"
              c:identifier="camel_mime_part_construct_content_from_parser"
              version="2.24"
              throws="1">
        <doc xml:space="preserve">Constructs the contnet of @mime_part from the given mime parser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="mp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_parser"
              c:identifier="camel_mime_part_construct_from_parser"
              version="3.0">
        <doc xml:space="preserve">Asynchronously constructs a MIME part from a parser.

When the operation is finished, @callback will be called.  You can then
call camel_mime_part_construct_from_parser_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_parser_finish"
              c:identifier="camel_mime_part_construct_from_parser_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_mime_part_construct_from_parser().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_parser_sync"
              c:identifier="camel_mime_part_construct_from_parser_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Constructs a MIME part from a parser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_disposition"
              c:identifier="camel_mime_part_get_content_disposition"
              version="2.30">
        <doc xml:space="preserve">Get the disposition of the MIME part as a structure.
Returned pointer is owned by @mime_part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the disposition structure</doc>
          <type name="ContentDisposition"
                c:type="const CamelContentDisposition*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_id"
              c:identifier="camel_mime_part_get_content_id">
        <doc xml:space="preserve">Get the content-id field of a MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the content-id field of the MIME part</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_languages"
              c:identifier="camel_mime_part_get_content_languages">
        <doc xml:space="preserve">Get the Content-Languages set on the MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GList of languages</doc>
          <type name="GLib.List" c:type="const GList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_location"
              c:identifier="camel_mime_part_get_content_location">
        <doc xml:space="preserve">Get the content-location field of a MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the content-location field of a MIME part</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_md5"
              c:identifier="camel_mime_part_get_content_md5">
        <doc xml:space="preserve">Get the content-md5 field of the MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the content-md5 field of the MIME part</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_content_type"
              c:identifier="camel_mime_part_get_content_type">
        <doc xml:space="preserve">Get the Content-Type of a MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parsed #CamelContentType of the MIME part</doc>
          <type name="ContentType" c:type="CamelContentType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="camel_mime_part_get_description">
        <doc xml:space="preserve">Get the description of the MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the description</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_disposition"
              c:identifier="camel_mime_part_get_disposition">
        <doc xml:space="preserve">Get the disposition of the MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the disposition</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_encoding" c:identifier="camel_mime_part_get_encoding">
        <doc xml:space="preserve">Get the Content-Transfer-Encoding of a MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelTransferEncoding</doc>
          <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename" c:identifier="camel_mime_part_get_filename">
        <doc xml:space="preserve">Get the filename of a MIME part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the filename of the MIME part</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_content" c:identifier="camel_mime_part_set_content">
        <doc xml:space="preserve">Utility function used to set the content of a mime part object to
be the provided data. If @length is 0, this routine can be used as
a way to remove old content (in which case @data and @type are
ignored and may be %NULL).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to put into the part</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">length of @data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Content-Type of the data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_id"
              c:identifier="camel_mime_part_set_content_id">
        <doc xml:space="preserve">Set the content-id field on a MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="contentid" transfer-ownership="none">
            <doc xml:space="preserve">content id</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_languages"
              c:identifier="camel_mime_part_set_content_languages">
        <doc xml:space="preserve">Set the Content-Languages field of a MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="content_languages" transfer-ownership="none">
            <doc xml:space="preserve">list of languages</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_location"
              c:identifier="camel_mime_part_set_content_location">
        <doc xml:space="preserve">Set the content-location field of the MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="location" transfer-ownership="none">
            <doc xml:space="preserve">the content-location value of the MIME part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_md5"
              c:identifier="camel_mime_part_set_content_md5">
        <doc xml:space="preserve">Set the content-md5 field of the MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="md5sum" transfer-ownership="none">
            <doc xml:space="preserve">the md5sum of the MIME part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_content_type"
              c:identifier="camel_mime_part_set_content_type">
        <doc xml:space="preserve">Set the content-type on a MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve">content-type string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_description"
              c:identifier="camel_mime_part_set_description">
        <doc xml:space="preserve">Set a description on the MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">description of the MIME part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_disposition"
              c:identifier="camel_mime_part_set_disposition">
        <doc xml:space="preserve">Set a disposition on the MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="disposition" transfer-ownership="none">
            <doc xml:space="preserve">disposition of the MIME part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_encoding" c:identifier="camel_mime_part_set_encoding">
        <doc xml:space="preserve">Set the Content-Transfer-Encoding to use on a MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="encoding" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelTransferEncoding</doc>
            <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filename" c:identifier="camel_mime_part_set_filename">
        <doc xml:space="preserve">Set the filename on a MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mime_part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">filename given to the MIME part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="content-id" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="content-md5" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="description" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="disposition" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Medium" c:type="CamelMedium"/>
      </field>
      <field name="priv">
        <type name="MimePartPrivate" c:type="CamelMimePartPrivate*"/>
      </field>
    </class>
    <record name="MimePartClass"
            c:type="CamelMimePartClass"
            glib:is-gtype-struct-for="MimePart">
      <field name="parent_class">
        <type name="MediumClass" c:type="CamelMediumClass"/>
      </field>
      <field name="construct_from_parser_sync">
        <callback name="construct_from_parser_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="mime_part" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimePart</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
            <parameter name="parser" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeParser</doc>
              <type name="MimeParser" c:type="CamelMimeParser*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MimePartPrivate" c:type="CamelMimePartPrivate" disguised="1">
    </record>
    <record name="Msg" c:type="CamelMsg" version="2.24">
      <field name="reply_port" writable="1">
        <doc xml:space="preserve">a #CamelMsgPort this #CamelMsg belongs to</doc>
        <type name="MsgPort" c:type="CamelMsgPort*"/>
      </field>
      <field name="flags" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="ort_reply"
              c:identifier="camel_msgport_reply"
              moved-to="msgport_reply"
              version="2.24"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="msg" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMsg</doc>
            <type name="Msg" c:type="CamelMsg*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="MsgPort" c:type="CamelMsgPort" disguised="1" version="2.24">
    </record>
    <class name="Multipart"
           c:symbol-prefix="multipart"
           c:type="CamelMultipart"
           parent="DataWrapper"
           glib:type-name="CamelMultipart"
           glib:get-type="camel_multipart_get_type"
           glib:type-struct="MultipartClass">
      <constructor name="new" c:identifier="camel_multipart_new">
        <doc xml:space="preserve">Create a new #CamelMultipart object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMultipart object</doc>
          <type name="Multipart" c:type="CamelMultipart*"/>
        </return-value>
      </constructor>
      <virtual-method name="add_part" invoker="add_part">
        <doc xml:space="preserve">Appends the part to the multipart object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart to add</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="construct_from_parser"
                      invoker="construct_from_parser">
        <doc xml:space="preserve">Construct a multipart from a parser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on success or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_boundary" invoker="get_boundary">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boundary</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_number" invoker="get_number">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of subparts in @multipart</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_part" invoker="get_part">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the indicated subpart, or %NULL</doc>
          <type name="MimePart" c:type="CamelMimePart*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a zero-based index indicating the part to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_boundary" invoker="set_boundary">
        <doc xml:space="preserve">Sets the message boundary for @multipart to @boundary. This should
be a string which does not occur anywhere in any of @multipart's
subparts. If @boundary is %NULL, a randomly-generated boundary will
be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="boundary" transfer-ownership="none">
            <doc xml:space="preserve">the message boundary, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_part" c:identifier="camel_multipart_add_part">
        <doc xml:space="preserve">Appends the part to the multipart object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart to add</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct_from_parser"
              c:identifier="camel_multipart_construct_from_parser">
        <doc xml:space="preserve">Construct a multipart from a parser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on success or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="parser" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeParser object</doc>
            <type name="MimeParser" c:type="CamelMimeParser*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boundary" c:identifier="camel_multipart_get_boundary">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the boundary</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number" c:identifier="camel_multipart_get_number">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of subparts in @multipart</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_part" c:identifier="camel_multipart_get_part">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the indicated subpart, or %NULL</doc>
          <type name="MimePart" c:type="CamelMimePart*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">a zero-based index indicating the part to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_postface"
              c:identifier="camel_multipart_get_postface"
              version="3.12">
        <doc xml:space="preserve">Returns the postface text for @multipart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the postface text</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_preface"
              c:identifier="camel_multipart_get_preface"
              version="3.12">
        <doc xml:space="preserve">Returns the preface text for @multipart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the preface text</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_boundary" c:identifier="camel_multipart_set_boundary">
        <doc xml:space="preserve">Sets the message boundary for @multipart to @boundary. This should
be a string which does not occur anywhere in any of @multipart's
subparts. If @boundary is %NULL, a randomly-generated boundary will
be used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="boundary" transfer-ownership="none">
            <doc xml:space="preserve">the message boundary, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_postface" c:identifier="camel_multipart_set_postface">
        <doc xml:space="preserve">Set the postface text for this multipart.  Will be written out after
the last boundary of the multipart, and ignored by any MIME mail
client.

Generally postface texts should not be sent with multipart messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="postface" transfer-ownership="none">
            <doc xml:space="preserve">multipat postface</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_preface" c:identifier="camel_multipart_set_preface">
        <doc xml:space="preserve">Set the preface text for this multipart.  Will be written out infront
of the multipart.  This text should only include US-ASCII strings, and
be relatively short, and will be ignored by any MIME mail client.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="multipart" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipart object</doc>
            <type name="Multipart" c:type="CamelMultipart*"/>
          </instance-parameter>
          <parameter name="preface" transfer-ownership="none">
            <doc xml:space="preserve">the multipart preface</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="DataWrapper" c:type="CamelDataWrapper"/>
      </field>
      <field name="priv">
        <type name="MultipartPrivate" c:type="CamelMultipartPrivate*"/>
      </field>
    </class>
    <record name="MultipartClass"
            c:type="CamelMultipartClass"
            glib:is-gtype-struct-for="Multipart">
      <field name="parent_class">
        <type name="DataWrapperClass" c:type="CamelDataWrapperClass"/>
      </field>
      <field name="add_part">
        <callback name="add_part">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="multipart" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMultipart object</doc>
              <type name="Multipart" c:type="CamelMultipart*"/>
            </parameter>
            <parameter name="part" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimePart to add</doc>
              <type name="MimePart" c:type="CamelMimePart*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_part">
        <callback name="get_part">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the indicated subpart, or %NULL</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </return-value>
          <parameters>
            <parameter name="multipart" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMultipart object</doc>
              <type name="Multipart" c:type="CamelMultipart*"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <doc xml:space="preserve">a zero-based index indicating the part to get</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_number">
        <callback name="get_number">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of subparts in @multipart</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="multipart" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMultipart object</doc>
              <type name="Multipart" c:type="CamelMultipart*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_boundary">
        <callback name="get_boundary">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the boundary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="multipart" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMultipart object</doc>
              <type name="Multipart" c:type="CamelMultipart*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_boundary">
        <callback name="set_boundary">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="multipart" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMultipart object</doc>
              <type name="Multipart" c:type="CamelMultipart*"/>
            </parameter>
            <parameter name="boundary" transfer-ownership="none">
              <doc xml:space="preserve">the message boundary, or %NULL</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="construct_from_parser">
        <callback name="construct_from_parser">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%0 on success or %-1 on fail</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="multipart" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMultipart object</doc>
              <type name="Multipart" c:type="CamelMultipart*"/>
            </parameter>
            <parameter name="parser" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeParser object</doc>
              <type name="MimeParser" c:type="CamelMimeParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="MultipartEncrypted"
           c:symbol-prefix="multipart_encrypted"
           c:type="CamelMultipartEncrypted"
           parent="Multipart"
           glib:type-name="CamelMultipartEncrypted"
           glib:get-type="camel_multipart_encrypted_get_type"
           glib:type-struct="MultipartEncryptedClass">
      <constructor name="new" c:identifier="camel_multipart_encrypted_new">
        <doc xml:space="preserve">Create a new #CamelMultipartEncrypted object.

A MultipartEncrypted should be used to store and create parts of
type "multipart/encrypted".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMultipartEncrypted object</doc>
          <type name="MultipartEncrypted" c:type="CamelMultipartEncrypted*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="Multipart" c:type="CamelMultipart"/>
      </field>
      <field name="priv">
        <type name="MultipartEncryptedPrivate"
              c:type="CamelMultipartEncryptedPrivate*"/>
      </field>
    </class>
    <record name="MultipartEncryptedClass"
            c:type="CamelMultipartEncryptedClass"
            glib:is-gtype-struct-for="MultipartEncrypted">
      <field name="parent_class">
        <type name="MultipartClass" c:type="CamelMultipartClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MultipartEncryptedPrivate"
            c:type="CamelMultipartEncryptedPrivate"
            disguised="1">
    </record>
    <record name="MultipartPrivate"
            c:type="CamelMultipartPrivate"
            disguised="1">
    </record>
    <class name="MultipartSigned"
           c:symbol-prefix="multipart_signed"
           c:type="CamelMultipartSigned"
           parent="Multipart"
           glib:type-name="CamelMultipartSigned"
           glib:get-type="camel_multipart_signed_get_type"
           glib:type-struct="MultipartSignedClass">
      <constructor name="new" c:identifier="camel_multipart_signed_new">
        <doc xml:space="preserve">Create a new #CamelMultipartSigned object.

A MultipartSigned should be used to store and create parts of
type "multipart/signed".  This is because multipart/signed is
entirely broken-by-design (tm) and uses completely
different semantics to other mutlipart types.  It must be treated
as opaque data by any transport.  See rfc 3156 for details.

There are 3 ways to create the part:
Use construct_from_stream.  If this is used, then you must
set the mime_type appropriately to match the data uses, so
that the multiple parts my be extracted.

Use construct_from_parser.  The parser MUST be in the #CAMEL_MIME_PARSER_STATE_HEADER
state, and the current content_type MUST be "multipart/signed" with
the appropriate boundary and it SHOULD include the appropriate protocol
and hash specifiers.

Use sign_part.  A signature part will automatically be created
and the whole part may be written using write_to_stream to
create a 'transport-safe' version (as safe as can be expected with
such a broken specification).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelMultipartSigned object</doc>
          <type name="MultipartSigned" c:type="CamelMultipartSigned*"/>
        </return-value>
      </constructor>
      <method name="get_content_stream"
              c:identifier="camel_multipart_signed_get_content_stream"
              throws="1">
        <doc xml:space="preserve">Get the raw signed content stream of the multipart/signed MIME part
suitable for use with verification of the signature.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the signed content stream</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="mps" transfer-ownership="none">
            <doc xml:space="preserve">a #CamlMultipartSigned object</doc>
            <type name="MultipartSigned" c:type="CamelMultipartSigned*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_content_stream"
              c:identifier="camel_multipart_signed_set_content_stream"
              version="3.12">
        <doc xml:space="preserve">Explicits sets the raw signed content stream of the multipart/signed
MIME part.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mps" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipartSigned</doc>
            <type name="MultipartSigned" c:type="CamelMultipartSigned*"/>
          </instance-parameter>
          <parameter name="content_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_signature"
              c:identifier="camel_multipart_signed_set_signature"
              version="3.12">
        <doc xml:space="preserve">Explicitly sets the signature part of @mps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mps" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMultipartSigned</doc>
            <type name="MultipartSigned" c:type="CamelMultipartSigned*"/>
          </instance-parameter>
          <parameter name="signature" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimePart</doc>
            <type name="MimePart" c:type="CamelMimePart*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Multipart" c:type="CamelMultipart"/>
      </field>
      <field name="priv">
        <type name="MultipartSignedPrivate"
              c:type="CamelMultipartSignedPrivate*"/>
      </field>
    </class>
    <record name="MultipartSignedClass"
            c:type="CamelMultipartSignedClass"
            glib:is-gtype-struct-for="MultipartSigned">
      <field name="parent_class">
        <type name="MultipartClass" c:type="CamelMultipartClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MultipartSignedPrivate"
            c:type="CamelMultipartSignedPrivate"
            disguised="1">
    </record>
    <constant name="NI_DGRAM" value="16" c:type="NI_DGRAM">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NI_NAMEREQD" value="8" c:type="NI_NAMEREQD">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NI_NOFQDN" value="4" c:type="NI_NOFQDN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NI_NUMERICHOST" value="1" c:type="NI_NUMERICHOST">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="NI_NUMERICSERV" value="2" c:type="NI_NUMERICSERV">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="NNTPAddress"
           c:symbol-prefix="nntp_address"
           c:type="CamelNNTPAddress"
           parent="Address"
           glib:type-name="CamelNNTPAddress"
           glib:get-type="camel_nntp_address_get_type"
           glib:type-struct="NNTPAddressClass">
      <constructor name="new" c:identifier="camel_nntp_address_new">
        <doc xml:space="preserve">Create a new CamelNNTPAddress object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new CamelNNTPAddress object.</doc>
          <type name="NNTPAddress" c:type="CamelNNTPAddress*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="camel_nntp_address_add">
        <doc xml:space="preserve">Add a new nntp address to the address object.  Duplicates are not added twice.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Index of added entry, or existing matching entry.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">nntp address object</doc>
            <type name="NNTPAddress" c:type="CamelNNTPAddress*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a new NNTP address to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="camel_nntp_address_get">
        <doc xml:space="preserve">Get the address at @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if such an address exists, or FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">nntp address object</doc>
            <type name="NNTPAddress" c:type="CamelNNTPAddress*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">address's array index</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="namep" transfer-ownership="none">
            <doc xml:space="preserve">Holder for the returned address, or NULL, if not required.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Address" c:type="CamelAddress"/>
      </field>
      <field name="priv">
        <type name="NNTPAddressPrivate" c:type="CamelNNTPAddressPrivate*"/>
      </field>
    </class>
    <record name="NNTPAddressClass"
            c:type="CamelNNTPAddressClass"
            glib:is-gtype-struct-for="NNTPAddress">
      <field name="parent_class">
        <type name="AddressClass" c:type="CamelAddressClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="NNTPAddressPrivate"
            c:type="CamelNNTPAddressPrivate"
            disguised="1">
    </record>
    <record name="NameValueArray"
            c:type="CamelNameValueArray"
            version="3.24"
            glib:type-name="CamelNameValueArray"
            glib:get-type="camel_name_value_array_get_type"
            c:symbol-prefix="name_value_array">
      <constructor name="new"
                   c:identifier="camel_name_value_array_new"
                   version="3.24">
        <doc xml:space="preserve">Creates a new #CamelNameValueArray. The returned pointer should be freed
with camel_name_value_array_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelNameValueArray.

See: camel_name_value_array_new_sized, camel_name_value_array_copy</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
      </constructor>
      <constructor name="new_sized"
                   c:identifier="camel_name_value_array_new_sized"
                   version="3.24">
        <doc xml:space="preserve">Creates a new #CamelNameValueArray, which has reserved @reserve_size
elements. This value doesn't influence the camel_name_value_array_get_length(),
which returns zero on the array returned from this function. The returned
pointer should be freed with camel_name_value_array_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelNameValueArray.

See: camel_name_value_array_new, camel_name_value_array_copy</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <parameter name="reserve_size" transfer-ownership="none">
            <doc xml:space="preserve">an array size to reserve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append"
              c:identifier="camel_name_value_array_append"
              version="3.24">
        <doc xml:space="preserve">Appends a new element of the name @name and the value @value
at the end of @array.

See: camel_name_value_array_set_named</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="camel_name_value_array_clear"
              version="3.24">
        <doc xml:space="preserve">Removes all elements of the @array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="camel_name_value_array_copy"
              version="3.24">
        <doc xml:space="preserve">Creates a new copy of the @array. The returned pointer should be freed
with camel_name_value_array_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new copy of the @array.

See: camel_name_value_array_new, camel_name_value_array_new_sized</doc>
          <type name="NameValueArray" c:type="CamelNameValueArray*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal"
              c:identifier="camel_name_value_array_equal"
              version="3.24">
        <doc xml:space="preserve">Compares content of the two #CamelNameValueArray and returns whether
they equal. Note this is an expensive operation for large arrays.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the two #CamelNameValueArray have the same content.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array_a"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">the first #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="array_b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the second #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </parameter>
          <parameter name="compare_type" transfer-ownership="none">
            <doc xml:space="preserve">a compare type, one of #CamelCompareType</doc>
            <type name="CompareType" c:type="CamelCompareType"/>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="camel_name_value_array_free"
              version="3.24">
        <doc xml:space="preserve">Frees the @array, previously allocated by camel_name_value_array_new(),
camel_name_value_array_new_sized() or camel_name_value_array_copy().
If the @array is %NULL, then does nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #CamelNameValueArray, or %NULL</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get"
              c:identifier="camel_name_value_array_get"
              version="3.24">
        <doc xml:space="preserve">Returns the name and the value of the element at index @index. Either
of the @out_name and @out_value can be %NULL, to not return that part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise.

See: camel_name_value_array_get_name, camel_name_value_array_get_value, camel_name_value_array_get_named</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve">A place to store the name of the element, or %NULL</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve">A place to store the value of the element, or %NULL</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length"
              c:identifier="camel_name_value_array_get_length"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Length of the @array, aka how many elements are stored in the @array.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="array"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="camel_name_value_array_get_name"
              version="3.24">
        <doc xml:space="preserve">Returns the name of the element at index @index.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Name of the element at the given @index,
   or %NULL on error.

See: camel_name_value_array_get, camel_name_value_array_get_value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_named"
              c:identifier="camel_name_value_array_get_named"
              version="3.24">
        <doc xml:space="preserve">Returns the value of the first element named @name, or %NULL when there
is no element of such @name in the @array. The @compare_type determines
how to compare the names.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Value of the first element named @name, or %NULL.

See: camel_name_value_array_get, camel_name_value_array_get_name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="compare_type" transfer-ownership="none">
            <doc xml:space="preserve">a compare type, one of #CamelCompareType</doc>
            <type name="CompareType" c:type="CamelCompareType"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value"
              c:identifier="camel_name_value_array_get_value"
              version="3.24">
        <doc xml:space="preserve">Returns the value of the element at index @index.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Value of the element at the given @index,
   or %NULL on error.

See: camel_name_value_array_get, camel_name_value_array_get_name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove"
              c:identifier="camel_name_value_array_remove"
              version="3.24">
        <doc xml:space="preserve">Removes element at index @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the element was removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_named"
              c:identifier="camel_name_value_array_remove_named"
              version="3.24">
        <doc xml:space="preserve">Removes elements of the @array with the given @name.
The @compare_type determines hot to compare the names.
If the @all_occurrences is set to %TRUE, then every elements with the @name
are removed, otherwise only the first occurrence is removed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">How many elements had been removed.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="compare_type" transfer-ownership="none">
            <doc xml:space="preserve">a compare type, one of #CamelCompareType</doc>
            <type name="CompareType" c:type="CamelCompareType"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="all_occurrences" transfer-ownership="none">
            <doc xml:space="preserve">whether to remove all occurrences of the @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set"
              c:identifier="camel_name_value_array_set"
              version="3.24">
        <doc xml:space="preserve">Sets both the @name and the @value of the element at index @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @array changed.

See: camel_name_value_array_append, camel_name_value_array_set_name, camel_name_value_array_set_value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name"
              c:identifier="camel_name_value_array_set_name"
              version="3.24">
        <doc xml:space="preserve">Sets the @name of the element at index @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @array changed.

See: camel_name_value_array_set, camel_name_value_array_set_value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_named"
              c:identifier="camel_name_value_array_set_named"
              version="3.24">
        <doc xml:space="preserve">Finds an element named @name and sets its value to @value, or appends
a new element, in case no such named element exists in the @array yet.
In case there are more elements named with @name only the first
occurrence is changed. The @compare_type determines how to compare
the names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @array changed.

See: camel_name_value_array_append, camel_name_value_array_set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="compare_type" transfer-ownership="none">
            <doc xml:space="preserve">a compare type, one of #CamelCompareType</doc>
            <type name="CompareType" c:type="CamelCompareType"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value"
              c:identifier="camel_name_value_array_set_value"
              version="3.24">
        <doc xml:space="preserve">Sets the @value of the element at index @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @array changed.

See: camel_name_value_array_set, camel_name_value_array_set_name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNameValueArray</doc>
            <type name="NameValueArray" c:type="CamelNameValueArray*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="NamedFlags"
            c:type="CamelNamedFlags"
            version="3.24"
            glib:type-name="CamelNamedFlags"
            glib:get-type="camel_named_flags_get_type"
            c:symbol-prefix="named_flags">
      <constructor name="new"
                   c:identifier="camel_named_flags_new"
                   version="3.24">
        <doc xml:space="preserve">Creates a new #CamelNamedFlags.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #CamelNamedFlags.
   Free it with camel_named_flags_free() when done with it.</doc>
          <type name="NamedFlags" c:type="CamelNamedFlags*"/>
        </return-value>
      </constructor>
      <constructor name="new_sized"
                   c:identifier="camel_named_flags_new_sized"
                   version="3.24">
        <doc xml:space="preserve">Created a new #CamelNamedFlags, which has reserved @reserve_size
elements. This value doesn't influence the camel_named_flags_get_length(),
which returns zero on the array returned from this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #CamelNameValueArray.
   Free it with camel_named_flags_free() when done with it.

See: camel_name_value_array_new, camel_name_value_array_copy</doc>
          <type name="NamedFlags" c:type="CamelNamedFlags*"/>
        </return-value>
        <parameters>
          <parameter name="reserve_size" transfer-ownership="none">
            <doc xml:space="preserve">an array size to reserve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="clear"
              c:identifier="camel_named_flags_clear"
              version="3.24">
        <doc xml:space="preserve">Removes all the elements of the array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="CamelNamedFlags*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="contains"
              c:identifier="camel_named_flags_contains"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the @named_flags contains a flag named @name,
   comparing case sensitively.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the flag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="camel_named_flags_copy" version="3.24">
        <doc xml:space="preserve">Creates a copy of the @named_flags and returns it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #CamelNamedFlags.
   Free it with camel_named_flags_free() when done with it.</doc>
          <type name="NamedFlags" c:type="CamelNamedFlags*"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal"
              c:identifier="camel_named_flags_equal"
              version="3.24">
        <doc xml:space="preserve">Compares content of the two #CamelNamedFlags and returns whether
they equal. Note this is an expensive operation for large sets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the two #CamelNamedFlags have the same content.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags_a"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">the first #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
          </instance-parameter>
          <parameter name="named_flags_b"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the second #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="camel_named_flags_free" version="3.24">
        <doc xml:space="preserve">Frees memory associated iwth the @named_flags. Does nothing,
if @named_flags is %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #CamelNamedFlags, or %NULL</doc>
            <type name="NamedFlags" c:type="CamelNamedFlags*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="camel_named_flags_get" version="3.24">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Name of the flag in at the given @index,
  or %NULL on error.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">an index of an element</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length"
              c:identifier="camel_named_flags_get_length"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Length of the array, aka how many named flags are stored there.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">a #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="const CamelNamedFlags*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert"
              c:identifier="camel_named_flags_insert"
              version="3.24">
        <doc xml:space="preserve">Inserts a flag named @name into the @named_flags, if it is not included
already (comparing case sensitively), or does nothing otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE the flag named @name was inserted; %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="CamelNamedFlags*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the flag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove"
              c:identifier="camel_named_flags_remove"
              version="3.24">
        <doc xml:space="preserve">Removes a flag named @name from the @named_flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE when the @named_flags contained a flag named @name,
   comparing case sensitively, and it was removed; %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="named_flags" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNamedFlags</doc>
            <type name="NamedFlags" c:type="CamelNamedFlags*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the flag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="NetworkSecurityMethod"
                 version="3.2"
                 glib:type-name="CamelNetworkSecurityMethod"
                 glib:get-type="camel_network_security_method_get_type"
                 c:type="CamelNetworkSecurityMethod">
      <doc xml:space="preserve">Methods for establishing an encrypted (or unencrypted) network connection.</doc>
      <member name="none"
              value="0"
              c:identifier="CAMEL_NETWORK_SECURITY_METHOD_NONE"
              glib:nick="none">
        <doc xml:space="preserve">Use an unencrypted network connection.</doc>
      </member>
      <member name="ssl_on_alternate_port"
              value="1"
              c:identifier="CAMEL_NETWORK_SECURITY_METHOD_SSL_ON_ALTERNATE_PORT"
              glib:nick="ssl-on-alternate-port">
        <doc xml:space="preserve">Use SSL by connecting to an alternate port number.</doc>
      </member>
      <member name="starttls_on_standard_port"
              value="2"
              c:identifier="CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT"
              glib:nick="starttls-on-standard-port">
        <doc xml:space="preserve">Use SSL or TLS by connecting to the standard port and invoking
  STARTTLS before authenticating.  This is the recommended method.</doc>
      </member>
    </enumeration>
    <interface name="NetworkService"
               c:symbol-prefix="network_service"
               c:type="CamelNetworkService"
               version="3.2"
               glib:type-name="CamelNetworkService"
               glib:get-type="camel_network_service_get_type"
               glib:type-struct="NetworkServiceInterface">
      <prerequisite name="Service"/>
      <virtual-method name="connect_sync"
                      invoker="connect_sync"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Attempts to establish a network connection to the server described by
@service, using the preferred #CamelNetworkSettings:security-method to
secure the connection.  If a connection cannot be established, or the
connection attempt is cancelled, the function sets @error and returns
%NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream, or %NULL</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_default_port"
                      invoker="get_default_port"
                      version="3.2">
        <doc xml:space="preserve">Returns the default network port number for @service and the security
method @method, as defined in /etc/services.  For example, the default
port for unencrypted IMAP or encrypted IMAP using STARTTLS is 143, but
the default port for IMAP over SSL is 993.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default port number for @service and @method</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSecurityMethod</doc>
            <type name="NetworkSecurityMethod"
                  c:type="CamelNetworkSecurityMethod"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_service_name"
                      invoker="get_service_name"
                      version="3.2">
        <doc xml:space="preserve">Returns the standard network service name for @service and the security
method @method, as defined in /etc/services.  For example, the service
name for unencrypted IMAP or encrypted IMAP using STARTTLS is "imap",
but the service name for IMAP over SSL is "imaps".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the network service name for @service and @method, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSecurityMethod</doc>
            <type name="NetworkSecurityMethod"
                  c:type="CamelNetworkSecurityMethod"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_connectable" introspectable="0">
        <return-value>
          <type name="Gio.SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="can_reach"
              c:identifier="camel_network_service_can_reach"
              version="3.12">
        <doc xml:space="preserve">Asynchronously attempts to determine whether or not the host described by
@service's #CamelNetworkService:connectable property can be reached, without
actually trying to connect to it.

For more details, see camel_network_service_can_reach_sync().

When the operation is finished, @callback will be called.  You can then
call camel_network_service_can_reach_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_reach_finish"
              c:identifier="camel_network_service_can_reach_finish"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_network_service_can_reach().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the host for @service can be reached</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_reach_sync"
              c:identifier="camel_network_service_can_reach_sync"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Attempts to determine whether or not the host described by @service's
#CamelNetworkService:connectable property can be reached, without actually
trying to connect to it.

If @service believes an attempt to connect will succeed, the function
returns %TRUE.  Otherwise the function returns %FALSE and sets @error
to an appropriate error (such as %G_IO_ERROR_HOST_UNREACHABLE).

The function will also update the @service's
#CamelNetworkService:host-reachable property based on the result.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the host for @service can be reached</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_sync"
              c:identifier="camel_network_service_connect_sync"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Attempts to establish a network connection to the server described by
@service, using the preferred #CamelNetworkSettings:security-method to
secure the connection.  If a connection cannot be established, or the
connection attempt is cancelled, the function sets @error and returns
%NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GIOStream, or %NULL</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_default_port"
              c:identifier="camel_network_service_get_default_port"
              version="3.2">
        <doc xml:space="preserve">Returns the default network port number for @service and the security
method @method, as defined in /etc/services.  For example, the default
port for unencrypted IMAP or encrypted IMAP using STARTTLS is 143, but
the default port for IMAP over SSL is 993.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the default port number for @service and @method</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSecurityMethod</doc>
            <type name="NetworkSecurityMethod"
                  c:type="CamelNetworkSecurityMethod"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_host_reachable"
              c:identifier="camel_network_service_get_host_reachable"
              version="3.8">
        <doc xml:space="preserve">Returns %TRUE if @service believes that the host pointed to by
#CamelNetworkService:connectable can be reached.  This property
is updated automatically as network conditions change.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the host is reachable</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service_name"
              c:identifier="camel_network_service_get_service_name"
              version="3.2">
        <doc xml:space="preserve">Returns the standard network service name for @service and the security
method @method, as defined in /etc/services.  For example, the service
name for unencrypted IMAP or encrypted IMAP using STARTTLS is "imap",
but the service name for IMAP over SSL is "imaps".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the network service name for @service and @method, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSecurityMethod</doc>
            <type name="NetworkSecurityMethod"
                  c:type="CamelNetworkSecurityMethod"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_connectable"
              c:identifier="camel_network_service_ref_connectable"
              version="3.8">
        <doc xml:space="preserve">Returns the socket endpoint for the network service to which @service
is a client.

The returned #GSocketConnectable is referenced for thread-safety and
must be unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSocketConnectable</doc>
          <type name="Gio.SocketConnectable" c:type="GSocketConnectable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_connectable"
              c:identifier="camel_network_service_set_connectable"
              version="3.8">
        <doc xml:space="preserve">Sets the socket endpoint for the network service to which @service is
a client.  If @connectable is %NULL, a #GSocketConnectable is derived
from the @service's #CamelNetworkSettings.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="connectable" transfer-ownership="none">
            <doc xml:space="preserve">a #GSocketConnectable, or %NULL</doc>
            <type name="Gio.SocketConnectable" c:type="GSocketConnectable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="starttls"
              c:identifier="camel_network_service_starttls"
              version="3.12"
              throws="1">
        <doc xml:space="preserve">Creates a #GTlsClientConnection wrapping @base_stream, which is
assumed to communicate with the server identified by @service's
#CamelNetworkService:connectable.

This should typically be called after issuing a STARTTLS command
to a server to initiate a Transport Layer Security handshake.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GTlsClientConnection, or %NULL on error</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkService</doc>
            <type name="NetworkService" c:type="CamelNetworkService*"/>
          </instance-parameter>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </parameter>
        </parameters>
      </method>
      <property name="connectable" writable="1" transfer-ownership="none">
        <type name="Gio.SocketConnectable"/>
      </property>
      <property name="host-reachable" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </interface>
    <record name="NetworkServiceInterface"
            c:type="CamelNetworkServiceInterface"
            glib:is-gtype-struct-for="NetworkService">
      <field name="parent_interface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_service_name">
        <callback name="get_service_name">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the network service name for @service and @method, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelNetworkService</doc>
              <type name="NetworkService" c:type="CamelNetworkService*"/>
            </parameter>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelNetworkSecurityMethod</doc>
              <type name="NetworkSecurityMethod"
                    c:type="CamelNetworkSecurityMethod"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_default_port">
        <callback name="get_default_port">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the default port number for @service and @method</doc>
            <type name="guint16" c:type="guint16"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelNetworkService</doc>
              <type name="NetworkService" c:type="CamelNetworkService*"/>
            </parameter>
            <parameter name="method" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelNetworkSecurityMethod</doc>
              <type name="NetworkSecurityMethod"
                    c:type="CamelNetworkSecurityMethod"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_sync">
        <callback name="connect_sync" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #GIOStream, or %NULL</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelNetworkService</doc>
              <type name="NetworkService" c:type="CamelNetworkService*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_connectable" introspectable="0">
        <callback name="new_connectable" introspectable="0">
          <return-value>
            <type name="Gio.SocketConnectable" c:type="GSocketConnectable*"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <type name="NetworkService" c:type="CamelNetworkService*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <interface name="NetworkSettings"
               c:symbol-prefix="network_settings"
               c:type="CamelNetworkSettings"
               version="3.2"
               glib:type-name="CamelNetworkSettings"
               glib:get-type="camel_network_settings_get_type"
               glib:type-struct="NetworkSettingsInterface">
      <prerequisite name="Settings"/>
      <method name="dup_auth_mechanism"
              c:identifier="camel_network_settings_dup_auth_mechanism"
              version="3.4">
        <doc xml:space="preserve">Thread-safe variation of camel_network_settings_get_auth_mechanism().
Use this function when accessing @settings from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelNetworkSettings:auth-mechanism</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_host"
              c:identifier="camel_network_settings_dup_host"
              version="3.4">
        <doc xml:space="preserve">Thread-safe variation of camel_network_settings_get_host().
Use this function when accessing @settings from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelNetworkSettings:host</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_host_ensure_ascii"
              c:identifier="camel_network_settings_dup_host_ensure_ascii"
              version="3.16">
        <doc xml:space="preserve">Just like camel_network_settings_dup_host(), only makes sure that
the returned host name will be converted into its ASCII form in case
of IDNA value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelNetworkSettings:host with
   only ASCII letters.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_user"
              c:identifier="camel_network_settings_dup_user"
              version="3.4">
        <doc xml:space="preserve">Thread-safe variation of camel_network_settings_get_user().
Use this function when accessing @settings from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelNetworkSettings:user</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auth_mechanism"
              c:identifier="camel_network_settings_get_auth_mechanism"
              version="3.4">
        <doc xml:space="preserve">Returns the mechanism name used to authenticate to a network service.
Often this refers to a SASL mechanism such as "LOGIN" or "GSSAPI".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the authentication mechanism name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_host"
              c:identifier="camel_network_settings_get_host"
              version="3.4">
        <doc xml:space="preserve">Returns the host name used to authenticate to a network service.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the host name of a network service</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port"
              c:identifier="camel_network_settings_get_port"
              version="3.4">
        <doc xml:space="preserve">Returns the port number used to authenticate to a network service.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the port number of a network service</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_security_method"
              c:identifier="camel_network_settings_get_security_method"
              version="3.2">
        <doc xml:space="preserve">Returns the method used to establish a secure (or unsecure) network
connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the security method</doc>
          <type name="NetworkSecurityMethod"
                c:type="CamelNetworkSecurityMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user"
              c:identifier="camel_network_settings_get_user"
              version="3.4">
        <doc xml:space="preserve">Returns the user name used to authenticate to a network service.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the user name of a network service</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_auth_mechanism"
              c:identifier="camel_network_settings_set_auth_mechanism"
              version="3.4">
        <doc xml:space="preserve">Sets the mechanism name used to authenticate to a network service.
Often this refers to a SASL mechanism such as "LOGIN" or "GSSAPI".
The #CamelNetworkSettings:auth-mechanism property is automatically
stripped of leading and trailing whitespace.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
          <parameter name="auth_mechanism" transfer-ownership="none">
            <doc xml:space="preserve">an authentication mechanism name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_host"
              c:identifier="camel_network_settings_set_host"
              version="3.4">
        <doc xml:space="preserve">Sets the host name used to authenticate to a network service.  The
#CamelNetworkSettings:host property is automatically stripped of
leading and trailing whitespace.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
          <parameter name="host" transfer-ownership="none">
            <doc xml:space="preserve">a host name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_port"
              c:identifier="camel_network_settings_set_port"
              version="3.4">
        <doc xml:space="preserve">Sets the port number used to authenticate to a network service.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">a port number</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_security_method"
              c:identifier="camel_network_settings_set_security_method"
              version="3.2">
        <doc xml:space="preserve">Sets the method used to establish a secure (or unsecure) network
connection.  Note that changing this setting has no effect on an
already-established network connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the security method</doc>
            <type name="NetworkSecurityMethod"
                  c:type="CamelNetworkSecurityMethod"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user"
              c:identifier="camel_network_settings_set_user"
              version="3.4">
        <doc xml:space="preserve">Sets the user name used to authenticate to a network service.  The
#CamelNetworkSettings:user property is automatically stripped of
leading and trailing whitespace.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNetworkSettings</doc>
            <type name="NetworkSettings" c:type="CamelNetworkSettings*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">a user name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auth-mechanism"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="host"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="port"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="security-method"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="NetworkSecurityMethod"/>
      </property>
      <property name="user"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
    </interface>
    <record name="NetworkSettingsInterface"
            c:type="CamelNetworkSettingsInterface"
            glib:is-gtype-struct-for="NetworkSettings">
      <field name="parent_interface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="NullOutputStream"
           c:symbol-prefix="null_output_stream"
           c:type="CamelNullOutputStream"
           parent="Gio.OutputStream"
           glib:type-name="CamelNullOutputStream"
           glib:get-type="camel_null_output_stream_get_type"
           glib:type-struct="NullOutputStreamClass">
      <constructor name="new"
                   c:identifier="camel_null_output_stream_new"
                   version="3.12">
        <doc xml:space="preserve">Creates a new "null" output stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GOutputStream</doc>
          <type name="Gio.OutputStream" c:type="GOutputStream*"/>
        </return-value>
      </constructor>
      <method name="get_bytes_written"
              c:identifier="camel_null_output_stream_get_bytes_written"
              version="3.12">
        <doc xml:space="preserve">Gets the total number of bytes written to @null_stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">total byte count</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="null_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelNullOutputStream</doc>
            <type name="NullOutputStream" c:type="CamelNullOutputStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Gio.OutputStream" c:type="GOutputStream"/>
      </field>
      <field name="priv">
        <type name="NullOutputStreamPrivate"
              c:type="CamelNullOutputStreamPrivate*"/>
      </field>
    </class>
    <record name="NullOutputStreamClass"
            c:type="CamelNullOutputStreamClass"
            glib:is-gtype-struct-for="NullOutputStream">
      <field name="parent_class">
        <type name="Gio.OutputStreamClass" c:type="GOutputStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="NullOutputStreamPrivate"
            c:type="CamelNullOutputStreamPrivate"
            disguised="1">
    </record>
    <constant name="O_BINARY" value="0" c:type="O_BINARY">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="CamelObject"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CamelObject"
           glib:get-type="camel_object_get_type"
           glib:type-struct="ObjectClass">
      <virtual-method name="state_read">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="CamelObject*"/>
          </instance-parameter>
          <parameter name="fp"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="state_write">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <type name="Object" c:type="CamelObject*"/>
          </instance-parameter>
          <parameter name="fp"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_state_filename"
              c:identifier="camel_object_get_state_filename"
              version="2.32">
        <doc xml:space="preserve">Returns the name of the file in which persistent property values for
@object are stored.  The file is used by camel_object_state_write()
and camel_object_state_read() to save and restore object state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the persistent property file</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObject</doc>
            <type name="Object" c:type="CamelObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_state_filename"
              c:identifier="camel_object_set_state_filename"
              version="2.32">
        <doc xml:space="preserve">Sets the name of the file in which persistent property values for
@object are stored.  The file is used by camel_object_state_write()
and camel_object_state_read() to save and restore object state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObject</doc>
            <type name="Object" c:type="CamelObject*"/>
          </instance-parameter>
          <parameter name="state_filename" transfer-ownership="none">
            <doc xml:space="preserve">path to a local file</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="state_read" c:identifier="camel_object_state_read">
        <doc xml:space="preserve">Read persistent object state from #CamelObject:state-filename.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObject</doc>
            <type name="Object" c:type="CamelObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="state_write" c:identifier="camel_object_state_write">
        <doc xml:space="preserve">Write persistent object state #CamelObject:state-filename.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">-1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObject</doc>
            <type name="Object" c:type="CamelObject*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="state-filename"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The file in which to store persistent property values for this
instance.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ObjectPrivate" c:type="CamelObjectPrivate*"/>
      </field>
    </class>
    <record name="ObjectBag" c:type="CamelObjectBag" disguised="1">
      <method name="abort" c:identifier="camel_object_bag_abort">
        <doc xml:space="preserve">Aborts a key reservation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
          <parameter name="key"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a reserved key</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add" c:identifier="camel_object_bag_add">
        <doc xml:space="preserve">Adds @object to @bag.  The @key MUST have been previously reserved using
camel_object_bag_reserve().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
          <parameter name="key"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a reserved key</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="camel_object_bag_destroy">
        <doc xml:space="preserve">Frees @bag.  As a precaution, the function will emit a warning to standard
error and return without freeing @bag if @bag still has reserved keys.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="camel_object_bag_get">
        <doc xml:space="preserve">Lookup an object by @key.  If the key is currently reserved, the function
will block until another thread commits or aborts the reservation.  The
caller owns the reference to the returned object.  Use g_object_unref ()
to unreference it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the object corresponding to @key, or
%NULL if not found</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
          <parameter name="key"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a key</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="list" c:identifier="camel_object_bag_list">
        <doc xml:space="preserve">Returns a #GPtrArray of all the objects in the bag.  The caller owns
both the array and the object references, so to free the array use:

|[
    g_ptr_array_foreach (array, (GFunc) g_object_unref, NULL);
    g_ptr_array_free (array, TRUE);
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of objects in @bag</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="GObject.Object"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="camel_object_bag_peek">
        <doc xml:space="preserve">Returns the object for @key in @bag, ignoring any reservations.  If it
isn't committed, then it isn't considered.  This should only be used
where reliable transactional-based state is not required.

Unlink other "peek" operations, the caller owns the returned object
reference.  Use g_object_unref () to unreference it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the object for @key, or %NULL if @key
is reserved or not found</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
          <parameter name="key"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an unreserved key</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="rekey" c:identifier="camel_object_bag_rekey">
        <doc xml:space="preserve">Changes the key for @object to @new_key, atomically.

It is considered a programming error if @object is not found in @bag.
In such case the function will emit a terminal warning and return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="new_key"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a new key for @object</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="camel_object_bag_remove">
        <doc xml:space="preserve">Removes @object from @bag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reserve" c:identifier="camel_object_bag_reserve">
        <doc xml:space="preserve">Reserves @key in @bag.  If @key is already reserved in another thread,
then wait until the reservation has been committed.

After reserving @key, you either get a reference to the object
corresponding to @key (similar to camel_object_bag_get()) or you get
%NULL, signifying that you MUST call either camel_object_bag_add() or
camel_object_bag_abort().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the object for @key, or %NULL if @key
is not found</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="bag" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelObjectBag</doc>
            <type name="ObjectBag" c:type="CamelObjectBag*"/>
          </instance-parameter>
          <parameter name="key"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the key to reserve</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="camel_object_bag_new"
                introspectable="0">
        <doc xml:space="preserve">Returns a new object bag.  Object bags are keyed hash tables of objects
that can be updated atomically using transaction semantics.  Use
camel_object_bag_destroy() to free the object bag.</doc>
        <return-value>
          <doc xml:space="preserve">a newly-allocated #CamelObjectBag</doc>
          <type name="ObjectBag" c:type="CamelObjectBag*"/>
        </return-value>
        <parameters>
          <parameter name="key_hash_func"
                     transfer-ownership="none"
                     scope="call">
            <doc xml:space="preserve">a hashing function for keys</doc>
            <type name="GLib.HashFunc" c:type="GHashFunc"/>
          </parameter>
          <parameter name="key_equal_func"
                     transfer-ownership="none"
                     scope="call">
            <doc xml:space="preserve">a comparison function for keys</doc>
            <type name="GLib.EqualFunc" c:type="GEqualFunc"/>
          </parameter>
          <parameter name="key_copy_func"
                     transfer-ownership="none"
                     scope="call">
            <doc xml:space="preserve">a function to copy keys</doc>
            <type name="CopyFunc" c:type="CamelCopyFunc"/>
          </parameter>
          <parameter name="key_free_func"
                     transfer-ownership="none"
                     scope="call">
            <doc xml:space="preserve">a function to free keys</doc>
            <type name="GLib.FreeFunc" c:type="GFreeFunc"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ObjectClass"
            c:type="CamelObjectClass"
            glib:is-gtype-struct-for="Object">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="state_read">
        <callback name="state_read">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="CamelObject*"/>
            </parameter>
            <parameter name="fp"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="state_write">
        <callback name="state_write">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="CamelObject*"/>
            </parameter>
            <parameter name="fp"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ObjectPrivate" c:type="CamelObjectPrivate" disguised="1">
    </record>
    <class name="OfflineFolder"
           c:symbol-prefix="offline_folder"
           c:type="CamelOfflineFolder"
           parent="Folder"
           glib:type-name="CamelOfflineFolder"
           glib:get-type="camel_offline_folder_get_type"
           glib:type-struct="OfflineFolderClass">
      <virtual-method name="downsync_sync"
                      invoker="downsync_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Synchronizes messages in @folder described by the search @expression to
the local machine for offline availability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineFolder</doc>
            <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">search expression describing which set of messages
             to downsync (%NULL for all)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_downsync"
              c:identifier="camel_offline_folder_can_downsync"
              version="3.22">
        <doc xml:space="preserve">Checks whether the @folder can run downsync according to its
settings (camel_offline_folder_get_offline_sync()) and to
the parent's #CamelOfflineStore settings (camel_offline_settings_get_stay_synchronized()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, when the @folder can be synchronized for offline; %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineFolder</doc>
            <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="downsync"
              c:identifier="camel_offline_folder_downsync"
              version="3.0">
        <doc xml:space="preserve">Synchronizes messages in @folder described by the search @expression to
the local machine asynchronously for offline availability.

When the operation is finished, @callback will be called.  You can then
call camel_offline_folder_downsync_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineFolder</doc>
            <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">search expression describing which set of messages
             to downsync (%NULL for all)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULl</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="downsync_finish"
              c:identifier="camel_offline_folder_downsync_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_offline_folder_downsync().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineFolder</doc>
            <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="downsync_sync"
              c:identifier="camel_offline_folder_downsync_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Synchronizes messages in @folder described by the search @expression to
the local machine for offline availability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineFolder</doc>
            <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">search expression describing which set of messages
             to downsync (%NULL for all)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_offline_sync"
              c:identifier="camel_offline_folder_get_offline_sync"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="ThreeState" c:type="CamelThreeState"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineFolder</doc>
            <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_offline_sync"
              c:identifier="camel_offline_folder_set_offline_sync"
              version="2.32">
        <doc xml:space="preserve">The %CAMEL_THREE_STATE_INCONSISTENT means what the parent store has set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineFolder</doc>
            <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
          </instance-parameter>
          <parameter name="offline_sync" transfer-ownership="none">
            <doc xml:space="preserve">whether to synchronize for offline use, as a #CamelThreeState enum</doc>
            <type name="ThreeState" c:type="CamelThreeState"/>
          </parameter>
        </parameters>
      </method>
      <property name="offline-sync" writable="1" transfer-ownership="none">
        <type name="ThreeState"/>
      </property>
      <field name="parent">
        <type name="Folder" c:type="CamelFolder"/>
      </field>
      <field name="priv">
        <type name="OfflineFolderPrivate" c:type="CamelOfflineFolderPrivate*"/>
      </field>
    </class>
    <record name="OfflineFolderClass"
            c:type="CamelOfflineFolderClass"
            glib:is-gtype-struct-for="OfflineFolder">
      <field name="parent_class">
        <type name="FolderClass" c:type="CamelFolderClass"/>
      </field>
      <field name="downsync_sync">
        <callback name="downsync_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelOfflineFolder</doc>
              <type name="OfflineFolder" c:type="CamelOfflineFolder*"/>
            </parameter>
            <parameter name="expression" transfer-ownership="none">
              <doc xml:space="preserve">search expression describing which set of messages
             to downsync (%NULL for all)</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="OfflineFolderPrivate"
            c:type="CamelOfflineFolderPrivate"
            disguised="1">
    </record>
    <class name="OfflineSettings"
           c:symbol-prefix="offline_settings"
           c:type="CamelOfflineSettings"
           version="3.2"
           parent="StoreSettings"
           glib:type-name="CamelOfflineSettings"
           glib:get-type="camel_offline_settings_get_type"
           glib:type-struct="OfflineSettingsClass">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <method name="get_limit_by_age"
              c:identifier="camel_offline_settings_get_limit_by_age"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether limit messages stored for offline use by their age</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_limit_unit"
              c:identifier="camel_offline_settings_get_limit_unit"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the limit unit to use when interpreting 'limit-value'</doc>
          <type name="TimeUnit" c:type="CamelTimeUnit"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_limit_value"
              c:identifier="camel_offline_settings_get_limit_value"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the limit, in 'limit-unit', to use when 'limit-by-age' is set to %TRUE</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stay_synchronized"
              c:identifier="camel_offline_settings_get_stay_synchronized"
              version="3.2">
        <doc xml:space="preserve">Returns whether to synchronize the local cache with the remote server
before switching to offline mode, so the store's content can still be
read while offline.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether to stay synchronized with the remote server</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_store_changes_interval"
              c:identifier="camel_offline_settings_get_store_changes_interval"
              version="3.18">
        <doc xml:space="preserve">Returns the interval, in seconds, for the changes in the folder being
saved automatically. 0 means immediately, while -1 means turning off
automatic folder change saving.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interval for automatic store of folder changes</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_limit_by_age"
              c:identifier="camel_offline_settings_set_limit_by_age"
              version="3.24">
        <doc xml:space="preserve">Set whether the messages to download for offline should be limited
by age. If set to %TRUE, then messages older than 'limit-value'
will not be downloaded automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
          <parameter name="limit_by_age" transfer-ownership="none">
            <doc xml:space="preserve">a value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_limit_unit"
              c:identifier="camel_offline_settings_set_limit_unit"
              version="3.24">
        <doc xml:space="preserve">Set the limit unit to use when interpreting 'limit-value'.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
          <parameter name="limit_unit" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelTimeUnit with a unit to use</doc>
            <type name="TimeUnit" c:type="CamelTimeUnit"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_limit_value"
              c:identifier="camel_offline_settings_set_limit_value"
              version="3.24">
        <doc xml:space="preserve">Set the limit, in 'limit-unit', to use when 'limit-by-age' is set to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
          <parameter name="limit_value" transfer-ownership="none">
            <doc xml:space="preserve">a value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stay_synchronized"
              c:identifier="camel_offline_settings_set_stay_synchronized"
              version="3.2">
        <doc xml:space="preserve">Sets whether to synchronize the local cache with the remote server before
switching to offline mode, so the store's content can still be read while
offline.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
          <parameter name="stay_synchronized" transfer-ownership="none">
            <doc xml:space="preserve">whether to stay synchronized with the remote server</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_store_changes_interval"
              c:identifier="camel_offline_settings_set_store_changes_interval"
              version="3.18">
        <doc xml:space="preserve">Sets the interval, in seconds, for the changes in the folder being
saved automatically. 0 means immediately, while -1 means turning off
automatic folder change saving.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineSettings</doc>
            <type name="OfflineSettings" c:type="CamelOfflineSettings*"/>
          </instance-parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:space="preserve">the interval, in seconds</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <property name="limit-by-age"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="limit-unit"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="TimeUnit"/>
      </property>
      <property name="limit-value"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="stay-synchronized"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="store-changes-interval"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="StoreSettings" c:type="CamelStoreSettings"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="OfflineSettingsPrivate"
              c:type="CamelOfflineSettingsPrivate*"/>
      </field>
    </class>
    <record name="OfflineSettingsClass"
            c:type="CamelOfflineSettingsClass"
            glib:is-gtype-struct-for="OfflineSettings">
      <field name="parent_class">
        <type name="StoreSettingsClass" c:type="CamelStoreSettingsClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="OfflineSettingsPrivate"
            c:type="CamelOfflineSettingsPrivate"
            disguised="1">
    </record>
    <class name="OfflineStore"
           c:symbol-prefix="offline_store"
           c:type="CamelOfflineStore"
           parent="Store"
           glib:type-name="CamelOfflineStore"
           glib:get-type="camel_offline_store_get_type"
           glib:type-struct="OfflineStoreClass">
      <implements name="Gio.Initable"/>
      <method name="get_online"
              c:identifier="camel_offline_store_get_online"
              version="2.24">
        <doc xml:space="preserve">Returns %TRUE if @store is online.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineStore</doc>
            <type name="OfflineStore" c:type="CamelOfflineStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepare_for_offline_sync"
              c:identifier="camel_offline_store_prepare_for_offline_sync"
              version="2.22"
              throws="1">
        <doc xml:space="preserve">Downloads messages for offline, when setup to do so and when
the host is reachable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineStore</doc>
            <type name="OfflineStore" c:type="CamelOfflineStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="requires_downsync"
              c:identifier="camel_offline_store_requires_downsync"
              version="3.12">
        <doc xml:space="preserve">Check whether the @store requires synchronization for offline usage.
This is not blocking, it only checks settings on the store and its
currently opened folders.

Returns %TRUE if the @store requires synchronization for offline usage</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineStore</doc>
            <type name="OfflineStore" c:type="CamelOfflineStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_online_sync"
              c:identifier="camel_offline_store_set_online_sync"
              throws="1">
        <doc xml:space="preserve">Sets the online/offline state of @store according to @online.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelOfflineStore</doc>
            <type name="OfflineStore" c:type="CamelOfflineStore*"/>
          </instance-parameter>
          <parameter name="online" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE for online, %FALSE for offline</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="online" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Store" c:type="CamelStore"/>
      </field>
      <field name="priv">
        <type name="OfflineStorePrivate" c:type="CamelOfflineStorePrivate*"/>
      </field>
    </class>
    <record name="OfflineStoreClass"
            c:type="CamelOfflineStoreClass"
            glib:is-gtype-struct-for="OfflineStore">
      <field name="parent_class">
        <type name="StoreClass" c:type="CamelStoreClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="OfflineStorePrivate"
            c:type="CamelOfflineStorePrivate"
            disguised="1">
    </record>
    <class name="Operation"
           c:symbol-prefix="operation"
           c:type="CamelOperation"
           parent="Gio.Cancellable"
           glib:type-name="CamelOperation"
           glib:get-type="camel_operation_get_type"
           glib:type-struct="OperationClass">
      <constructor name="new" c:identifier="camel_operation_new">
        <doc xml:space="preserve">Create a new camel operation handle.  Camel operation handles can
be used in a multithreaded application (or a single operation
handle can be used in a non threaded appliation) to cancel running
operations and to obtain notification messages of the internal
status of messages.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new operation handle.</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </return-value>
      </constructor>
      <constructor name="new_proxy"
                   c:identifier="camel_operation_new_proxy"
                   version="3.24">
        <doc xml:space="preserve">Proxies the @cancellable in a way that if it is cancelled,
then the returned cancellable is also cancelled, but when
the returned cancellable is cancelled, then it doesn't
influence the original cancellable. Other CamelOperation
actions being done on the returned cancellable are also
propagated to the @cancellable.

The passed-in @cancellable can be %NULL, in which case
a plain CamelOperation is returned.

This is useful when some operation can be cancelled from
elsewhere (like by a user), but also by the code on its own,
when it doesn't make sense to cancel also any larger operation
to which the passed-in cancellable belongs.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new operation handle, proxying @cancellable.</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable to proxy</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="cancel_all" c:identifier="camel_operation_cancel_all">
        <doc xml:space="preserve">Cancel all outstanding operations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="pop_message" c:identifier="camel_operation_pop_message">
        <doc xml:space="preserve">Pops the most recently pushed message.

This function only works if @cancellable is a #CamelOperation cast as a
#GCancellable.  If @cancellable is a plain #GCancellable or %NULL, the
function does nothing and returns silently.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="progress" c:identifier="camel_operation_progress">
        <doc xml:space="preserve">Report progress on the current operation.  @percent reports the current
percentage of completion, which should be in the range of 0 to 100.

This function only works if @cancellable is a #CamelOperation cast as a
#GCancellable.  If @cancellable is a plain #GCancellable or %NULL, the
function does nothing and returns silently.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="percent" transfer-ownership="none">
            <doc xml:space="preserve">percent complete, 0 to 100.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="push_message"
                c:identifier="camel_operation_push_message"
                introspectable="0">
        <doc xml:space="preserve">Call this function to describe an operation being performed.
Call camel_operation_progress() to report progress on the operation.
Call camel_operation_pop_message() when the operation is complete.

This function only works if @cancellable is a #CamelOperation cast as a
#GCancellable.  If @cancellable is a plain #GCancellable or %NULL, the
function does nothing and returns silently.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a standard printf() format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the parameters to insert into the format string</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="status">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="operation" transfer-ownership="none">
            <type name="Operation" c:type="CamelOperation*"/>
          </instance-parameter>
          <parameter name="what" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pc" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="parent">
        <type name="Gio.Cancellable" c:type="GCancellable"/>
      </field>
      <field name="priv">
        <type name="OperationPrivate" c:type="CamelOperationPrivate*"/>
      </field>
      <glib:signal name="pop-message" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="progress" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="push-message" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="status" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="OperationClass"
            c:type="CamelOperationClass"
            glib:is-gtype-struct-for="Operation">
      <field name="parent_class">
        <type name="Gio.CancellableClass" c:type="GCancellableClass"/>
      </field>
      <field name="status">
        <callback name="status">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="operation" transfer-ownership="none">
              <type name="Operation" c:type="CamelOperation*"/>
            </parameter>
            <parameter name="what" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="pc" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="OperationPrivate"
            c:type="CamelOperationPrivate"
            disguised="1">
    </record>
    <bitfield name="ParamFlags" version="2.32" c:type="CamelParamFlags">
      <doc xml:space="preserve">These flags extend #GParamFlags.  Most of the time you will use them
in conjunction with g_object_class_install_property().</doc>
      <member name="param_persistent"
              value="256"
              c:identifier="CAMEL_PARAM_PERSISTENT">
        <doc xml:space="preserve">The parameter is persistent, which means its value is saved to
    #CamelObject:state-filename during camel_object_state_write(),
    and restored during camel_object_state_read().</doc>
      </member>
    </bitfield>
    <record name="PartitionKey" c:type="CamelPartitionKey">
      <field name="hashid" writable="1">
        <type name="_hash_t" c:type="camel_hash_t"/>
      </field>
      <field name="keyid" writable="1">
        <type name="_key_t" c:type="camel_key_t"/>
      </field>
    </record>
    <record name="PartitionKeyBlock" c:type="CamelPartitionKeyBlock">
      <field name="used" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="keys" writable="1">
        <array zero-terminated="0" c:type="_CamelPartitionKey" fixed-size="0">
          <type name="gpointer" c:type="_CamelPartitionKey"/>
        </array>
      </field>
    </record>
    <record name="PartitionMap" c:type="CamelPartitionMap">
      <field name="hashid" writable="1">
        <type name="_hash_t" c:type="camel_hash_t"/>
      </field>
      <field name="blockid" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
    </record>
    <record name="PartitionMapBlock" c:type="CamelPartitionMapBlock">
      <field name="next" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
      <field name="used" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="partition" writable="1">
        <array zero-terminated="0" c:type="_CamelPartitionMap" fixed-size="0">
          <type name="gpointer" c:type="_CamelPartitionMap"/>
        </array>
      </field>
    </record>
    <class name="PartitionTable"
           c:symbol-prefix="partition_table"
           c:type="CamelPartitionTable"
           parent="GObject.Object"
           glib:type-name="CamelPartitionTable"
           glib:get-type="camel_partition_table_get_type"
           glib:type-struct="PartitionTableClass">
      <constructor name="new" c:identifier="camel_partition_table_new">
        <return-value transfer-ownership="full">
          <type name="PartitionTable" c:type="CamelPartitionTable*"/>
        </return-value>
        <parameters>
          <parameter name="bs" transfer-ownership="none">
            <type name="BlockFile" c:type="CamelBlockFile*"/>
          </parameter>
          <parameter name="root" transfer-ownership="none">
            <type name="_block_t" c:type="camel_block_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="camel_partition_table_add">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cpi" transfer-ownership="none">
            <type name="PartitionTable" c:type="CamelPartitionTable*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="keyid" transfer-ownership="none">
            <type name="_key_t" c:type="camel_key_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="camel_partition_table_lookup">
        <return-value transfer-ownership="none">
          <type name="_key_t" c:type="camel_key_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="cpi" transfer-ownership="none">
            <type name="PartitionTable" c:type="CamelPartitionTable*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="camel_partition_table_remove">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cpi" transfer-ownership="none">
            <type name="PartitionTable" c:type="CamelPartitionTable*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync" c:identifier="camel_partition_table_sync">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cpi" transfer-ownership="none">
            <type name="PartitionTable" c:type="CamelPartitionTable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="PartitionTablePrivate"
              c:type="CamelPartitionTablePrivate*"/>
      </field>
    </class>
    <record name="PartitionTableClass"
            c:type="CamelPartitionTableClass"
            glib:is-gtype-struct-for="PartitionTable">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="PartitionTablePrivate"
            c:type="CamelPartitionTablePrivate"
            disguised="1">
    </record>
    <record name="Provider"
            c:type="CamelProvider"
            glib:type-name="CamelProvider"
            glib:get-type="camel_provider_get_type"
            c:symbol-prefix="provider">
      <field name="protocol" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="domain" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="ProviderFlags" c:type="CamelProviderFlags"/>
      </field>
      <field name="url_flags" writable="1">
        <type name="ProviderURLFlags" c:type="CamelProviderURLFlags"/>
      </field>
      <field name="extra_conf" writable="1">
        <type name="ProviderConfEntry" c:type="CamelProviderConfEntry*"/>
      </field>
      <field name="port_entries" writable="1">
        <type name="ProviderPortEntry" c:type="CamelProviderPortEntry*"/>
      </field>
      <field name="auto_detect" writable="1">
        <type name="ProviderAutoDetectFunc"
              c:type="CamelProviderAutoDetectFunc"/>
      </field>
      <field name="object_types" writable="1">
        <array zero-terminated="0" c:type="GType">
          <type name="GType" c:type="GType"/>
        </array>
      </field>
      <field name="authtypes" writable="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="url_hash" writable="1">
        <type name="GLib.HashFunc" c:type="GHashFunc"/>
      </field>
      <field name="url_equal" writable="1">
        <type name="GLib.EqualFunc" c:type="GEqualFunc"/>
      </field>
      <field name="translation_domain" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="priv" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="auto_detect"
              c:identifier="camel_provider_auto_detect"
              throws="1">
        <doc xml:space="preserve">After filling in the standard Username/Hostname/Port/Path settings
(which must be set in @url), if the provider supports it, you
may wish to have the provider auto-detect further settings based on
the aformentioned settings.

If the provider does not support auto-detection, @auto_detected
will be set to %NULL. Otherwise the provider will attempt to
auto-detect whatever it can and file them into @auto_detected. If
for some reason it cannot auto-detect anything (not enough
information provided in @url?) then @auto_detected will be
set to %NULL and an exception may be set to explain why it failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">0 on success or -1 on fail.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="provider" transfer-ownership="none">
            <doc xml:space="preserve">camel provider</doc>
            <type name="Provider" c:type="CamelProvider*"/>
          </instance-parameter>
          <parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </parameter>
          <parameter name="auto_detected"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">output hash table of auto-detected values</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="camel_provider_register">
        <doc xml:space="preserve">Registers a provider.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="provider" transfer-ownership="none">
            <doc xml:space="preserve">provider object</doc>
            <type name="Provider" c:type="CamelProvider*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="get" c:identifier="camel_provider_get" throws="1">
        <doc xml:space="preserve">Returns the registered #CamelProvider for @protocol, loading it
from disk if necessary.  If no #CamelProvider can be found for
@protocol, or the provider module fails to load, the function
sets @error and returns %NULL.

The returned #CamelProvider is owned by Camel and should not be
modified or freed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelProvider for %protocol, or %NULL</doc>
          <type name="Provider" c:type="CamelProvider*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelProvider protocol name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init" c:identifier="camel_provider_init">
        <doc xml:space="preserve">Initialize the Camel provider system by reading in the .urls
files in the provider directory and creating a hash table mapping
URLs to module names.

A .urls file has the same initial prefix as the shared library it
correspond to, and consists of a series of lines containing the URL
protocols that that library handles.

TODO: This should be pathed?
TODO: This should be plugin-d?</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="list" c:identifier="camel_provider_list">
        <doc xml:space="preserve">This returns a list of available providers. If @load is %TRUE, it will
first load in all available providers that haven't yet been loaded.

Free the returned list with g_list_free().  The #CamelProvider structs
in the list are owned by Camel and should not be modified or freed.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GList of #CamelProvider structs</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Provider"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="load" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to load in providers that are not already loaded</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="load" c:identifier="camel_provider_load" throws="1">
        <doc xml:space="preserve">Loads the provider at @path, and calls its initialization function,
passing @session as an argument. The provider should then register
itself with @session.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to a shared library</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="ProviderAutoDetectFunc"
              c:type="CamelProviderAutoDetectFunc"
              throws="1">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="url" transfer-ownership="none">
          <type name="URL" c:type="CamelURL*"/>
        </parameter>
        <parameter name="auto_detected" transfer-ownership="none">
          <type name="GLib.HashTable" c:type="GHashTable**">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </callback>
    <record name="ProviderConfEntry" c:type="CamelProviderConfEntry">
      <field name="type" writable="1">
        <type name="ProviderConfType" c:type="CamelProviderConfType"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="depname" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="text" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="value" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
    </record>
    <enumeration name="ProviderConfType"
                 glib:type-name="CamelProviderConfType"
                 glib:get-type="camel_provider_conf_type_get_type"
                 c:type="CamelProviderConfType">
      <member name="end"
              value="0"
              c:identifier="CAMEL_PROVIDER_CONF_END"
              glib:nick="end">
      </member>
      <member name="section_start"
              value="1"
              c:identifier="CAMEL_PROVIDER_CONF_SECTION_START"
              glib:nick="section-start">
      </member>
      <member name="section_end"
              value="2"
              c:identifier="CAMEL_PROVIDER_CONF_SECTION_END"
              glib:nick="section-end">
      </member>
      <member name="checkbox"
              value="3"
              c:identifier="CAMEL_PROVIDER_CONF_CHECKBOX"
              glib:nick="checkbox">
      </member>
      <member name="checkspin"
              value="4"
              c:identifier="CAMEL_PROVIDER_CONF_CHECKSPIN"
              glib:nick="checkspin">
      </member>
      <member name="entry"
              value="5"
              c:identifier="CAMEL_PROVIDER_CONF_ENTRY"
              glib:nick="entry">
      </member>
      <member name="label"
              value="6"
              c:identifier="CAMEL_PROVIDER_CONF_LABEL"
              glib:nick="label">
      </member>
      <member name="hidden"
              value="7"
              c:identifier="CAMEL_PROVIDER_CONF_HIDDEN"
              glib:nick="hidden">
      </member>
      <member name="options"
              value="8"
              c:identifier="CAMEL_PROVIDER_CONF_OPTIONS"
              glib:nick="options">
      </member>
      <member name="placeholder"
              value="9"
              c:identifier="CAMEL_PROVIDER_CONF_PLACEHOLDER"
              glib:nick="placeholder">
      </member>
    </enumeration>
    <bitfield name="ProviderFlags"
              glib:type-name="CamelProviderFlags"
              glib:get-type="camel_provider_flags_get_type"
              c:type="CamelProviderFlags">
      <member name="is_remote"
              value="1"
              c:identifier="CAMEL_PROVIDER_IS_REMOTE"
              glib:nick="is-remote">
        <doc xml:space="preserve">Provider works with remote data.</doc>
      </member>
      <member name="is_local"
              value="2"
              c:identifier="CAMEL_PROVIDER_IS_LOCAL"
              glib:nick="is-local">
        <doc xml:space="preserve">Provider can be used as a backend for local folder tree folders.
  (Not just the opposite of #CAMEL_PROVIDER_IS_REMOTE.)</doc>
      </member>
      <member name="is_external"
              value="4"
              c:identifier="CAMEL_PROVIDER_IS_EXTERNAL"
              glib:nick="is-external">
        <doc xml:space="preserve">Provider appears in the folder tree but is not created by the
  mail component.</doc>
      </member>
      <member name="is_source"
              value="8"
              c:identifier="CAMEL_PROVIDER_IS_SOURCE"
              glib:nick="is-source">
        <doc xml:space="preserve">Mail arrives there, so it should be offered as an option in the
  mail config dialog.</doc>
      </member>
      <member name="is_storage"
              value="16"
              c:identifier="CAMEL_PROVIDER_IS_STORAGE"
              glib:nick="is-storage">
        <doc xml:space="preserve">Mail is stored there.  It will appear in the folder tree.</doc>
      </member>
      <member name="supports_ssl"
              value="32"
              c:identifier="CAMEL_PROVIDER_SUPPORTS_SSL"
              glib:nick="supports-ssl">
        <doc xml:space="preserve">Provider supports SSL/TLS connections.</doc>
      </member>
      <member name="has_license"
              value="64"
              c:identifier="CAMEL_PROVIDER_HAS_LICENSE"
              glib:nick="has-license">
        <doc xml:space="preserve">Provider configuration first needs the license to be accepted.
  (No longer used.)</doc>
      </member>
      <member name="disable_sent_folder"
              value="128"
              c:identifier="CAMEL_PROVIDER_DISABLE_SENT_FOLDER"
              glib:nick="disable-sent-folder">
        <doc xml:space="preserve">Provider requests to not use the Sent folder when sending with it.</doc>
      </member>
      <member name="allow_real_trash_folder"
              value="256"
              c:identifier="CAMEL_PROVIDER_ALLOW_REAL_TRASH_FOLDER"
              glib:nick="allow-real-trash-folder">
        <doc xml:space="preserve">Provider may use a real trash folder instead of a virtual folder.</doc>
      </member>
      <member name="allow_real_junk_folder"
              value="512"
              c:identifier="CAMEL_PROVIDER_ALLOW_REAL_JUNK_FOLDER"
              glib:nick="allow-real-junk-folder">
        <doc xml:space="preserve">Provider may use a real junk folder instead of a virtual folder.</doc>
      </member>
      <member name="supports_mobile_devices"
              value="1024"
              c:identifier="CAMEL_PROVIDER_SUPPORTS_MOBILE_DEVICES"
              glib:nick="supports-mobile-devices">
        <doc xml:space="preserve">Download limited set of emails instead of operating on full cache.</doc>
      </member>
      <member name="supports_batch_fetch"
              value="2048"
              c:identifier="CAMEL_PROVIDER_SUPPORTS_BATCH_FETCH"
              glib:nick="supports-batch-fetch">
        <doc xml:space="preserve">Support to fetch messages in batch.</doc>
      </member>
      <member name="supports_purge_message_cache"
              value="4096"
              c:identifier="CAMEL_PROVIDER_SUPPORTS_PURGE_MESSAGE_CACHE"
              glib:nick="supports-purge-message-cache">
        <doc xml:space="preserve">Support to remove oldest downloaded messages to conserve space.</doc>
      </member>
    </bitfield>
    <record name="ProviderModule" c:type="CamelProviderModule">
      <field name="path" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="types" writable="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="loaded" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <function name="init" c:identifier="camel_provider_module_init">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
    </record>
    <record name="ProviderPortEntry"
            c:type="CamelProviderPortEntry"
            version="3.2">
      <field name="port" writable="1">
        <doc xml:space="preserve">port number</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="desc" writable="1">
        <doc xml:space="preserve">human description of the port</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="is_ssl" writable="1">
        <doc xml:space="preserve">a boolean whether the port is used together with TLS/SSL</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
    </record>
    <enumeration name="ProviderType"
                 glib:type-name="CamelProviderType"
                 glib:get-type="camel_provider_type_get_type"
                 c:type="CamelProviderType">
      <member name="store"
              value="0"
              c:identifier="CAMEL_PROVIDER_STORE"
              glib:nick="store">
      </member>
      <member name="transport"
              value="1"
              c:identifier="CAMEL_PROVIDER_TRANSPORT"
              glib:nick="transport">
      </member>
    </enumeration>
    <bitfield name="ProviderURLFlags" c:type="CamelProviderURLFlags">
      <member name="allow_user" value="1" c:identifier="CAMEL_URL_ALLOW_USER">
      </member>
      <member name="allow_auth" value="2" c:identifier="CAMEL_URL_ALLOW_AUTH">
      </member>
      <member name="allow_password"
              value="4"
              c:identifier="CAMEL_URL_ALLOW_PASSWORD">
      </member>
      <member name="allow_host" value="8" c:identifier="CAMEL_URL_ALLOW_HOST">
      </member>
      <member name="allow_port" value="16" c:identifier="CAMEL_URL_ALLOW_PORT">
      </member>
      <member name="allow_path" value="32" c:identifier="CAMEL_URL_ALLOW_PATH">
      </member>
      <member name="need_user" value="256" c:identifier="CAMEL_URL_NEED_USER">
      </member>
      <member name="need_auth" value="512" c:identifier="CAMEL_URL_NEED_AUTH">
      </member>
      <member name="need_password"
              value="1024"
              c:identifier="CAMEL_URL_NEED_PASSWORD">
      </member>
      <member name="need_host" value="2048" c:identifier="CAMEL_URL_NEED_HOST">
      </member>
      <member name="need_port" value="4096" c:identifier="CAMEL_URL_NEED_PORT">
      </member>
      <member name="need_path" value="8192" c:identifier="CAMEL_URL_NEED_PATH">
      </member>
      <member name="need_path_dir"
              value="16384"
              c:identifier="CAMEL_URL_NEED_PATH_DIR">
      </member>
      <member name="hidden_user"
              value="65536"
              c:identifier="CAMEL_URL_HIDDEN_USER">
      </member>
      <member name="hidden_auth"
              value="131072"
              c:identifier="CAMEL_URL_HIDDEN_AUTH">
      </member>
      <member name="hidden_password"
              value="262144"
              c:identifier="CAMEL_URL_HIDDEN_PASSWORD">
      </member>
      <member name="hidden_host"
              value="524288"
              c:identifier="CAMEL_URL_HIDDEN_HOST">
      </member>
      <member name="hidden_port"
              value="1048576"
              c:identifier="CAMEL_URL_HIDDEN_PORT">
      </member>
      <member name="hidden_path"
              value="2097152"
              c:identifier="CAMEL_URL_HIDDEN_PATH">
      </member>
      <member name="fragment_is_path"
              value="1073741824"
              c:identifier="CAMEL_URL_FRAGMENT_IS_PATH">
      </member>
      <member name="path_is_absolute"
              value="2147483648"
              c:identifier="CAMEL_URL_PATH_IS_ABSOLUTE">
      </member>
    </bitfield>
    <constant name="RECIPIENT_TYPE_BCC"
              value="Bcc"
              c:type="CAMEL_RECIPIENT_TYPE_BCC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="RECIPIENT_TYPE_CC"
              value="Cc"
              c:type="CAMEL_RECIPIENT_TYPE_CC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="RECIPIENT_TYPE_RESENT_BCC"
              value="Resent-Bcc"
              c:type="CAMEL_RECIPIENT_TYPE_RESENT_BCC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="RECIPIENT_TYPE_RESENT_CC"
              value="Resent-Cc"
              c:type="CAMEL_RECIPIENT_TYPE_RESENT_CC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="RECIPIENT_TYPE_RESENT_TO"
              value="Resent-To"
              c:type="CAMEL_RECIPIENT_TYPE_RESENT_TO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="RECIPIENT_TYPE_TO"
              value="To"
              c:type="CAMEL_RECIPIENT_TYPE_TO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="SExp"
           c:symbol-prefix="sexp"
           c:type="CamelSExp"
           version="3.4"
           parent="GObject.Object"
           glib:type-name="CamelSExp"
           glib:get-type="camel_sexp_get_type"
           glib:type-struct="SExpClass">
      <constructor name="new" c:identifier="camel_sexp_new" version="3.4">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelSExp</doc>
          <type name="SExp" c:type="CamelSExp*"/>
        </return-value>
      </constructor>
      <function name="encode_bool"
                c:identifier="camel_sexp_encode_bool"
                version="3.4">
        <doc xml:space="preserve">Encode a bool into an s-expression @string.  Bools are
encoded using #t #f syntax.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">Destination #GString</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
          <parameter name="v_bool" transfer-ownership="none">
            <doc xml:space="preserve">the value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="encode_string"
                c:identifier="camel_sexp_encode_string"
                version="3.4">
        <doc xml:space="preserve">Add a c string @v_string to the s-expression stored in
the gstring @s.  Quotes are added, and special characters
are escaped appropriately.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">Destination #Gstring</doc>
            <type name="GLib.String" c:type="GString*"/>
          </parameter>
          <parameter name="v_string" transfer-ownership="none">
            <doc xml:space="preserve">String expression.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_sql_sexp"
                c:identifier="camel_sexp_to_sql_sexp"
                version="2.26">
        <doc xml:space="preserve">Converts a search expression to an SQL 'WHERE' part statement,
without the 'WHERE' keyword.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string, an SQL 'WHERE' part statement,
   or %NULL, when could not convert it. Free it with g_free(), when done with it.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a search expression to convert</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_function"
              c:identifier="camel_sexp_add_function"
              version="3.4"
              introspectable="0">
        <doc xml:space="preserve">Adds a function symbol which can not perform short evaluation.
Use camel_sexp_add_ifunction() for functions which can.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="scope" transfer-ownership="none">
            <doc xml:space="preserve">a scope</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a function name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="3">
            <doc xml:space="preserve">a function callback</doc>
            <type name="SExpFunc" c:type="CamelSExpFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_ifunction"
              c:identifier="camel_sexp_add_ifunction"
              version="3.4"
              introspectable="0">
        <doc xml:space="preserve">Adds a function symbol which can perform short evaluation,
or doesn't execute everything. Use camel_sexp_add_function()
for any other types of the function symbols.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="scope" transfer-ownership="none">
            <doc xml:space="preserve">a scope</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a function name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="ifunc"
                     transfer-ownership="none"
                     scope="call"
                     closure="3">
            <doc xml:space="preserve">a function callback</doc>
            <type name="SExpIFunc" c:type="CamelSExpIFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data for @ifunc</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_variable"
              c:identifier="camel_sexp_add_variable"
              version="3.4">
        <doc xml:space="preserve">Adds a variable named @name to the given @scope, set to the given @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="scope" transfer-ownership="none">
            <doc xml:space="preserve">a scope</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a variable name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a variable value, as a #CamelSExpTerm</doc>
            <type name="SExpTerm" c:type="CamelSExpTerm*"/>
          </parameter>
        </parameters>
      </method>
      <method name="error" c:identifier="camel_sexp_error" version="3.4">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">Set error string on the @sexp, or %NULL, when none is set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="eval"
              c:identifier="camel_sexp_eval"
              version="3.4"
              introspectable="0">
        <return-value>
          <type name="SExpResult" c:type="CamelSExpResult*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="evaluate_occur_times"
              c:identifier="camel_sexp_evaluate_occur_times">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <type name="glong" c:type="time_t*"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <type name="glong" c:type="time_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fatal_error"
              c:identifier="camel_sexp_fatal_error"
              version="3.4"
              introspectable="0">
        <doc xml:space="preserve">Sets an error from the given format and stops execution.
Int replaces previously set error, if any.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="why" transfer-ownership="none">
            <doc xml:space="preserve">a string format to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">parameters for the format</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="input_file"
              c:identifier="camel_sexp_input_file"
              version="3.4">
        <doc xml:space="preserve">Prepares to scan a file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="input_text"
              c:identifier="camel_sexp_input_text"
              version="3.4">
        <doc xml:space="preserve">Prepares to scan a text buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:space="preserve">a text buffer to scan</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the text buffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse" c:identifier="camel_sexp_parse" version="3.4">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_value"
              c:identifier="camel_sexp_parse_value"
              version="3.4"
              introspectable="0">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelSExpTerm of the next token, or %NULL when there is none.</doc>
          <type name="SExpTerm" c:type="CamelSExpTerm*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_symbol"
              c:identifier="camel_sexp_remove_symbol"
              version="3.4">
        <doc xml:space="preserve">Revoes a symbol from a scope.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="scope" transfer-ownership="none">
            <doc xml:space="preserve">a scope</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a symbol name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="result_free"
              c:identifier="camel_sexp_result_free"
              version="3.4">
        <doc xml:space="preserve">Frees the @result and its internal data. Does nothing,
when the @result is %NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="result"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelSExpResult to free</doc>
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="result_new"
              c:identifier="camel_sexp_result_new"
              version="3.4"
              introspectable="0">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelSExpResult result structure, associated with @sexp.
   Free with camel_sexp_result_free(), when no longer needed.</doc>
          <type name="SExpResult" c:type="CamelSExpResult*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type of the result, one of #CamelSExpResultType</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="resultv_free"
              c:identifier="camel_sexp_resultv_free"
              version="3.4">
        <doc xml:space="preserve">Frees an array of results.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="argc" transfer-ownership="none">
            <doc xml:space="preserve">a count of the @argv</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="argv" transfer-ownership="none">
            <doc xml:space="preserve">an array of #CamelSExpResult to free</doc>
            <array length="0" zero-terminated="0" c:type="CamelSExpResult**">
              <type name="SExpResult" c:type="CamelSExpResult*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_scope"
              c:identifier="camel_sexp_set_scope"
              version="3.4">
        <doc xml:space="preserve">sets the current scope for the scanner.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the previous scope id</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="scope" transfer-ownership="none">
            <doc xml:space="preserve">a scope to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="term_eval"
              c:identifier="camel_sexp_term_eval"
              version="3.4"
              introspectable="0">
        <doc xml:space="preserve">Evaluates a part of the expression.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated result of the evaluation. Free
   the returned pointer with camel_sexp_result_free(), when no longer needed.</doc>
          <type name="SExpResult" c:type="CamelSExpResult*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sexp" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExp</doc>
            <type name="SExp" c:type="CamelSExp*"/>
          </instance-parameter>
          <parameter name="term" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSExpTerm to evaluate</doc>
            <type name="SExpTerm" c:type="CamelSExpTerm*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SExpPrivate" c:type="CamelSExpPrivate*"/>
      </field>
    </class>
    <record name="SExpClass"
            c:type="CamelSExpClass"
            glib:is-gtype-struct-for="SExp">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="SExpFunc"
              c:type="CamelSExpFunc"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Callback type for function symbols used with camel_sexp_add_function().</doc>
      <return-value>
        <doc xml:space="preserve">Result of the function call, allocated by camel_sexp_result_new().</doc>
        <type name="SExpResult" c:type="CamelSExpResult*"/>
      </return-value>
      <parameters>
        <parameter name="sexp" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelSExp</doc>
          <type name="SExp" c:type="CamelSExp*"/>
        </parameter>
        <parameter name="argc" transfer-ownership="none">
          <doc xml:space="preserve">count of arguments</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">array of values of the arguments</doc>
          <array length="1" zero-terminated="0" c:type="CamelSExpResult**">
            <type name="SExpResult" c:type="CamelSExpResult*"/>
          </array>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">user data as passed to camel_sexp_add_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="SExpIFunc"
              c:type="CamelSExpIFunc"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Callback type for function symbols used with camel_sexp_add_ifunction().</doc>
      <return-value>
        <doc xml:space="preserve">Result of the function call, allocated by camel_sexp_result_new().</doc>
        <type name="SExpResult" c:type="CamelSExpResult*"/>
      </return-value>
      <parameters>
        <parameter name="sexp" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelSExp</doc>
          <type name="SExp" c:type="CamelSExp*"/>
        </parameter>
        <parameter name="argc" transfer-ownership="none">
          <doc xml:space="preserve">count of arguments</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:space="preserve">array of values of the arguments</doc>
          <array length="1" zero-terminated="0" c:type="CamelSExpTerm**">
            <type name="SExpTerm" c:type="CamelSExpTerm*"/>
          </array>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">user data as passed to camel_sexp_add_ifunction()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SExpPrivate" c:type="CamelSExpPrivate" disguised="1">
    </record>
    <record name="SExpResult" c:type="CamelSExpResult" version="3.4">
      <field name="type" writable="1">
        <doc xml:space="preserve">a #CamelSExpResultType, defining the @value type</doc>
        <type name="SExpResultType" c:type="CamelSExpResultType"/>
      </field>
      <union name="value" c:type="value">
        <field name="ptrarray" writable="1">
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
        <field name="number" writable="1">
          <type name="gint" c:type="gint"/>
        </field>
        <field name="string" writable="1">
          <type name="utf8" c:type="gchar*"/>
        </field>
        <field name="boolean" writable="1">
          <type name="gint" c:type="gint"/>
        </field>
        <field name="time" writable="1">
          <type name="glong" c:type="time_t"/>
        </field>
      </union>
      <field name="time_generator" writable="1">
        <doc xml:space="preserve">a boolean whether the occuring times are used</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="occuring_start" writable="1">
        <doc xml:space="preserve">start time</doc>
        <type name="glong" c:type="time_t"/>
      </field>
      <field name="occuring_end" writable="1">
        <doc xml:space="preserve">end time</doc>
        <type name="glong" c:type="time_t"/>
      </field>
    </record>
    <enumeration name="SExpResultType"
                 version="3.4"
                 c:type="CamelSExpResultType">
      <doc xml:space="preserve">Defines type of a #CamelSExpResult.</doc>
      <member name="array_ptr"
              value="0"
              c:identifier="CAMEL_SEXP_RES_ARRAY_PTR">
        <doc xml:space="preserve">type is a ptrarray, what it points to is implementation dependant</doc>
      </member>
      <member name="int" value="1" c:identifier="CAMEL_SEXP_RES_INT">
        <doc xml:space="preserve">type is a number</doc>
      </member>
      <member name="string" value="2" c:identifier="CAMEL_SEXP_RES_STRING">
        <doc xml:space="preserve">type is a pointer to a single string</doc>
      </member>
      <member name="bool" value="3" c:identifier="CAMEL_SEXP_RES_BOOL">
        <doc xml:space="preserve">boolean type</doc>
      </member>
      <member name="time" value="4" c:identifier="CAMEL_SEXP_RES_TIME">
        <doc xml:space="preserve">time_t type</doc>
      </member>
      <member name="undefined"
              value="5"
              c:identifier="CAMEL_SEXP_RES_UNDEFINED">
        <doc xml:space="preserve">unknown type</doc>
      </member>
    </enumeration>
    <record name="SExpSymbol" c:type="CamelSExpSymbol" version="3.4">
      <doc xml:space="preserve">Describes a function or a variable symbol</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">a type of the symbol, either CAMEL_SEXP_TERM_FUNC or CAMEL_SEXP_TERM_VAR</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">name of the symbol</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="data" writable="1">
        <doc xml:space="preserve">user data for the callback</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <union name="f" c:type="f">
        <field name="func" introspectable="0" writable="1">
          <type name="SExpFunc" c:type="CamelSExpFunc"/>
        </field>
        <field name="ifunc" introspectable="0" writable="1">
          <type name="SExpIFunc" c:type="CamelSExpIFunc"/>
        </field>
      </union>
    </record>
    <record name="SExpTerm" c:type="CamelSExpTerm" version="3.4">
      <field name="type" writable="1">
        <doc xml:space="preserve">a type of the term; one of #CamelSExpTermType</doc>
        <type name="SExpTermType" c:type="CamelSExpTermType"/>
      </field>
      <union name="value" c:type="value">
        <field name="string" writable="1">
          <type name="utf8" c:type="gchar*"/>
        </field>
        <field name="number" writable="1">
          <type name="gint" c:type="gint"/>
        </field>
        <field name="boolean" writable="1">
          <type name="gint" c:type="gint"/>
        </field>
        <field name="time" writable="1">
          <type name="glong" c:type="time_t"/>
        </field>
        <record name="func" c:type="func">
          <field name="sym" writable="1">
            <type name="SExpSymbol" c:type="CamelSExpSymbol*"/>
          </field>
          <field name="terms" writable="1">
            <type name="SExpTerm" c:type="CamelSExpTerm**"/>
          </field>
          <field name="termcount" writable="1">
            <type name="gint" c:type="gint"/>
          </field>
        </record>
        <field name="var" writable="1">
          <type name="SExpSymbol" c:type="CamelSExpSymbol*"/>
        </field>
      </union>
    </record>
    <enumeration name="SExpTermType" version="3.4" c:type="CamelSExpTermType">
      <doc xml:space="preserve">Defines type of a #CamelSExpTerm and partly also #CamelSExpSymbol</doc>
      <member name="int" value="0" c:identifier="CAMEL_SEXP_TERM_INT">
        <doc xml:space="preserve">integer literal</doc>
      </member>
      <member name="bool" value="1" c:identifier="CAMEL_SEXP_TERM_BOOL">
        <doc xml:space="preserve">boolean literal</doc>
      </member>
      <member name="string" value="2" c:identifier="CAMEL_SEXP_TERM_STRING">
        <doc xml:space="preserve">string literal</doc>
      </member>
      <member name="time" value="3" c:identifier="CAMEL_SEXP_TERM_TIME">
        <doc xml:space="preserve">time_t literal (number of seconds past the epoch)</doc>
      </member>
      <member name="func" value="4" c:identifier="CAMEL_SEXP_TERM_FUNC">
        <doc xml:space="preserve">normal function, arguments are evaluated before calling</doc>
      </member>
      <member name="ifunc" value="5" c:identifier="CAMEL_SEXP_TERM_IFUNC">
        <doc xml:space="preserve">immediate function, raw terms are arguments</doc>
      </member>
      <member name="var" value="6" c:identifier="CAMEL_SEXP_TERM_VAR">
        <doc xml:space="preserve">variable reference</doc>
      </member>
    </enumeration>
    <class name="SMIMEContext"
           c:symbol-prefix="smime_context"
           c:type="CamelSMIMEContext"
           parent="CipherContext"
           glib:type-name="CamelSMIMEContext"
           glib:get-type="camel_smime_context_get_type"
           glib:type-struct="SMIMEContextClass">
      <constructor name="new" c:identifier="camel_smime_context_new">
        <doc xml:space="preserve">Creates a new sm cipher context object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new sm cipher context object.</doc>
          <type name="CipherContext" c:type="CamelCipherContext*"/>
        </return-value>
        <parameters>
          <parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">session</doc>
            <type name="Session" c:type="CamelSession*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="describe_part"
              c:identifier="camel_smime_context_describe_part">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="SMIMEContext" c:type="CamelSMIMEContext*"/>
          </instance-parameter>
          <parameter name="part"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="_CamelMimePart*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_encrypt_key"
              c:identifier="camel_smime_context_set_encrypt_key">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="SMIMEContext" c:type="CamelSMIMEContext*"/>
          </instance-parameter>
          <parameter name="use" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sign_mode"
              c:identifier="camel_smime_context_set_sign_mode">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="SMIMEContext" c:type="CamelSMIMEContext*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="SMIMESign" c:type="CamelSMIMESign"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="CipherContext" c:type="CamelCipherContext"/>
      </field>
      <field name="priv">
        <type name="SMIMEContextPrivate" c:type="CamelSMIMEContextPrivate*"/>
      </field>
    </class>
    <record name="SMIMEContextClass"
            c:type="CamelSMIMEContextClass"
            glib:is-gtype-struct-for="SMIMEContext">
      <field name="parent_class">
        <type name="CipherContextClass" c:type="CamelCipherContextClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SMIMEContextPrivate"
            c:type="CamelSMIMEContextPrivate"
            disguised="1">
    </record>
    <bitfield name="SMIMEDescribe" c:type="CamelSMIMEDescribe">
      <member name="signed" value="1" c:identifier="CAMEL_SMIME_SIGNED">
      </member>
      <member name="encrypted" value="2" c:identifier="CAMEL_SMIME_ENCRYPTED">
      </member>
      <member name="certs" value="4" c:identifier="CAMEL_SMIME_CERTS">
      </member>
      <member name="crls" value="8" c:identifier="CAMEL_SMIME_CRLS">
      </member>
    </bitfield>
    <enumeration name="SMIMESign" c:type="CamelSMIMESign">
      <member name="clearsign"
              value="0"
              c:identifier="CAMEL_SMIME_SIGN_CLEARSIGN">
      </member>
      <member name="enveloped"
              value="1"
              c:identifier="CAMEL_SMIME_SIGN_ENVELOPED">
      </member>
    </enumeration>
    <constant name="STORE_INFO_FOLDER_TYPE_BIT"
              value="10"
              c:type="CAMEL_STORE_INFO_FOLDER_TYPE_BIT">
      <doc xml:space="preserve">The folder store info type bitshift value.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="STORE_INFO_FOLDER_TYPE_MASK"
              value="64512"
              c:type="CAMEL_STORE_INFO_FOLDER_TYPE_MASK">
      <doc xml:space="preserve">The folder store info type mask value.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="STORE_INFO_FOLDER_UNKNOWN"
              value="-1"
              c:type="CAMEL_STORE_INFO_FOLDER_UNKNOWN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="STORE_SETUP_ARCHIVE_FOLDER"
              value="Account:Mail Account:archive-folder:f"
              c:type="CAMEL_STORE_SETUP_ARCHIVE_FOLDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="STORE_SETUP_DRAFTS_FOLDER"
              value="Submission:Mail Composition:drafts-folder:f"
              c:type="CAMEL_STORE_SETUP_DRAFTS_FOLDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="STORE_SETUP_SENT_FOLDER"
              value="Submission:Mail Submission:sent-folder:f"
              c:type="CAMEL_STORE_SETUP_SENT_FOLDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="STORE_SETUP_TEMPLATES_FOLDER"
              value="Submission:Mail Composition:templates-folder:f"
              c:type="CAMEL_STORE_SETUP_TEMPLATES_FOLDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Sasl"
           c:symbol-prefix="sasl"
           c:type="CamelSasl"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CamelSasl"
           glib:get-type="camel_sasl_get_type"
           glib:type-struct="SaslClass">
      <constructor name="new" c:identifier="camel_sasl_new">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #CamelSasl object for the given @service_name,
@mechanism, and @service, or %NULL if the mechanism is not
supported.</doc>
          <type name="Sasl" c:type="CamelSasl*"/>
        </return-value>
        <parameters>
          <parameter name="service_name" transfer-ownership="none">
            <doc xml:space="preserve">the SASL service name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">the SASL mechanism</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the CamelService that will be using this SASL</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="authtype" c:identifier="camel_sasl_authtype">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelServiceAuthType for the given mechanism, if
it is supported.</doc>
          <type name="ServiceAuthType" c:type="CamelServiceAuthType*"/>
        </return-value>
        <parameters>
          <parameter name="mechanism" transfer-ownership="none">
            <doc xml:space="preserve">the SASL mechanism to get an authtype for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="authtype_list" c:identifier="camel_sasl_authtype_list">
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GList of SASL-supported authtypes. The caller must
free the list, but not the contents.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ServiceAuthType"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="include_plain" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to include the PLAIN mechanism</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="challenge_sync"
                      invoker="challenge_sync"
                      throws="1">
        <doc xml:space="preserve">If @token is %NULL, generate the initial SASL message to send to
the server.  (This will be %NULL if the client doesn't initiate the
exchange.)  Otherwise, @token is a challenge from the server, and
the return value is the response.

Free the returned #GByteArray with g_byte_array_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the SASL response or %NULL. If an error occurred, @error will
also be set.</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a token, or %NULL</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="try_empty_password_sync"
                      invoker="try_empty_password_sync"
                      version="3.2"
                      throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @sasl can attempt to authenticate without a
password being provided by the caller. This will be %TRUE for an
authentication method which can attempt to use single-sign-on
credentials, but which can fall back to using a provided password
so it still has the @need_password flag set in its description.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl object</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="challenge"
              c:identifier="camel_sasl_challenge"
              version="3.0">
        <doc xml:space="preserve">If @token is %NULL, asynchronously generate the initial SASL message
to send to the server.  (This will be %NULL if the client doesn't
initiate the exchange.)  Otherwise, @token is a challenge from the
server, and the asynchronous result is the response.

When the operation is finished, @callback will be called.  You can then
call camel_sasl_challenge_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a token, or %NULL</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="challenge_base64"
              c:identifier="camel_sasl_challenge_base64"
              version="3.0">
        <doc xml:space="preserve">As with camel_sasl_challenge(), but the challenge @token and the
response are both base64-encoded.

When the operation is finished, @callback will be called.  You can
then call camel_store_challenge_base64_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a base64-encoded token</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="challenge_base64_finish"
              c:identifier="camel_sasl_challenge_base64_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_sasl_challenge_base64().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the base64-encoded response</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="challenge_base64_sync"
              c:identifier="camel_sasl_challenge_base64_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">As with camel_sasl_challenge_sync(), but the challenge @token and the
response are both base64-encoded.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the base64-encoded response</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a base64-encoded token</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="challenge_finish"
              c:identifier="camel_sasl_challenge_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_sasl_challenge().  Free the
returned #GByteArray with g_byte_array_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the SASL response or %NULL.  If an error occurred, @error will
also be set.</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="challenge_sync"
              c:identifier="camel_sasl_challenge_sync"
              throws="1">
        <doc xml:space="preserve">If @token is %NULL, generate the initial SASL message to send to
the server.  (This will be %NULL if the client doesn't initiate the
exchange.)  Otherwise, @token is a challenge from the server, and
the return value is the response.

Free the returned #GByteArray with g_byte_array_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the SASL response or %NULL. If an error occurred, @error will
also be set.</doc>
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:space="preserve">a token, or %NULL</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_authenticated"
              c:identifier="camel_sasl_get_authenticated">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @sasl has successfully authenticated the
user. This will be %TRUE after it returns the last needed response.
The caller must still pass that information on to the server and
verify that it has accepted it.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mechanism"
              c:identifier="camel_sasl_get_mechanism"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="camel_sasl_get_service"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="Service" c:type="CamelService*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service_name"
              c:identifier="camel_sasl_get_service_name"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_authenticated"
              c:identifier="camel_sasl_set_authenticated"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="authenticated" transfer-ownership="none">
            <doc xml:space="preserve">whether we have successfully authenticated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="try_empty_password"
              c:identifier="camel_sasl_try_empty_password"
              version="3.2">
        <doc xml:space="preserve">Asynchronously determine whether @sasl can be used for password-less
authentication, for example single-sign-on using system credentials.

When the operation is finished, @callback will be called.  You can then
call camel_sasl_try_empty_password_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="try_empty_password_finish"
              c:identifier="camel_sasl_try_empty_password_finish"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_sasl_try_empty_password().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the SASL response.  If an error occurred, @error will also be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="try_empty_password_sync"
              c:identifier="camel_sasl_try_empty_password_sync"
              version="3.2"
              throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @sasl can attempt to authenticate without a
password being provided by the caller. This will be %TRUE for an
authentication method which can attempt to use single-sign-on
credentials, but which can fall back to using a provided password
so it still has the @need_password flag set in its description.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSasl object</doc>
            <type name="Sasl" c:type="CamelSasl*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="authenticated" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mechanism"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="service"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Service"/>
      </property>
      <property name="service-name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SaslPrivate" c:type="CamelSaslPrivate*"/>
      </field>
    </class>
    <enumeration name="SaslAnonTraceType"
                 glib:type-name="CamelSaslAnonTraceType"
                 glib:get-type="camel_sasl_anon_trace_type_get_type"
                 c:type="CamelSaslAnonTraceType">
      <member name="email"
              value="0"
              c:identifier="CAMEL_SASL_ANON_TRACE_EMAIL"
              glib:nick="email">
      </member>
      <member name="opaque"
              value="1"
              c:identifier="CAMEL_SASL_ANON_TRACE_OPAQUE"
              glib:nick="opaque">
      </member>
      <member name="empty"
              value="2"
              c:identifier="CAMEL_SASL_ANON_TRACE_EMPTY"
              glib:nick="empty">
      </member>
    </enumeration>
    <class name="SaslAnonymous"
           c:symbol-prefix="sasl_anonymous"
           c:type="CamelSaslAnonymous"
           parent="Sasl"
           glib:type-name="CamelSaslAnonymous"
           glib:get-type="camel_sasl_anonymous_get_type"
           glib:type-struct="SaslAnonymousClass">
      <constructor name="new" c:identifier="camel_sasl_anonymous_new">
        <doc xml:space="preserve">Create a new #CamelSaslAnonymous object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelSasl object</doc>
          <type name="Sasl" c:type="CamelSasl*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">trace type</doc>
            <type name="SaslAnonTraceType" c:type="CamelSaslAnonTraceType"/>
          </parameter>
          <parameter name="trace_info" transfer-ownership="none">
            <doc xml:space="preserve">trace info</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslAnonymousPrivate" c:type="CamelSaslAnonymousPrivate*"/>
      </field>
    </class>
    <record name="SaslAnonymousClass"
            c:type="CamelSaslAnonymousClass"
            glib:is-gtype-struct-for="SaslAnonymous">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslAnonymousPrivate"
            c:type="CamelSaslAnonymousPrivate"
            disguised="1">
    </record>
    <record name="SaslClass"
            c:type="CamelSaslClass"
            glib:is-gtype-struct-for="Sasl">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="auth_type">
        <type name="ServiceAuthType" c:type="CamelServiceAuthType*"/>
      </field>
      <field name="try_empty_password_sync">
        <callback name="try_empty_password_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether or not @sasl can attempt to authenticate without a
password being provided by the caller. This will be %TRUE for an
authentication method which can attempt to use single-sign-on
credentials, but which can fall back to using a provided password
so it still has the @need_password flag set in its description.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sasl" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSasl object</doc>
              <type name="Sasl" c:type="CamelSasl*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="challenge_sync">
        <callback name="challenge_sync" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the SASL response or %NULL. If an error occurred, @error will
also be set.</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="sasl" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSasl</doc>
              <type name="Sasl" c:type="CamelSasl*"/>
            </parameter>
            <parameter name="token" transfer-ownership="none">
              <doc xml:space="preserve">a token, or %NULL</doc>
              <array name="GLib.ByteArray" c:type="GByteArray*">
                <type name="guint8" c:type="guint8"/>
              </array>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="SaslCramMd5"
           c:symbol-prefix="sasl_cram_md5"
           c:type="CamelSaslCramMd5"
           parent="Sasl"
           glib:type-name="CamelSaslCramMd5"
           glib:get-type="camel_sasl_cram_md5_get_type"
           glib:type-struct="SaslCramMd5Class">
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslCramMd5Private" c:type="CamelSaslCramMd5Private*"/>
      </field>
    </class>
    <record name="SaslCramMd5Class"
            c:type="CamelSaslCramMd5Class"
            glib:is-gtype-struct-for="SaslCramMd5">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslCramMd5Private"
            c:type="CamelSaslCramMd5Private"
            disguised="1">
    </record>
    <class name="SaslDigestMd5"
           c:symbol-prefix="sasl_digest_md5"
           c:type="CamelSaslDigestMd5"
           parent="Sasl"
           glib:type-name="CamelSaslDigestMd5"
           glib:get-type="camel_sasl_digest_md5_get_type"
           glib:type-struct="SaslDigestMd5Class">
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslDigestMd5Private" c:type="CamelSaslDigestMd5Private*"/>
      </field>
    </class>
    <record name="SaslDigestMd5Class"
            c:type="CamelSaslDigestMd5Class"
            glib:is-gtype-struct-for="SaslDigestMd5">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslDigestMd5Private"
            c:type="CamelSaslDigestMd5Private"
            disguised="1">
    </record>
    <class name="SaslGssapi"
           c:symbol-prefix="sasl_gssapi"
           c:type="CamelSaslGssapi"
           parent="Sasl"
           glib:type-name="CamelSaslGssapi"
           glib:get-type="camel_sasl_gssapi_get_type"
           glib:type-struct="SaslGssapiClass">
      <function name="is_available"
                c:identifier="camel_sasl_gssapi_is_available"
                version="3.12">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the GSSAPI/KRB5 sasl authentication mechanism is available,
   which means whether Camel was built with KRB5 enabled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <method name="override_host_and_user"
              c:identifier="camel_sasl_gssapi_override_host_and_user"
              version="3.12">
        <doc xml:space="preserve">Set host and user to use, instead of those in CamelService's settings.
It's both or none, aka either set both, or the settings values are used.
This is used to not require CamelService instance at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sasl" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSaslGssapi</doc>
            <type name="SaslGssapi" c:type="CamelSaslGssapi*"/>
          </instance-parameter>
          <parameter name="override_host"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Host name to use during challenge processing; can be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="override_user"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">User name to use during challenge processing; can be %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslGssapiPrivate" c:type="CamelSaslGssapiPrivate*"/>
      </field>
    </class>
    <record name="SaslGssapiClass"
            c:type="CamelSaslGssapiClass"
            glib:is-gtype-struct-for="SaslGssapi">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslGssapiPrivate"
            c:type="CamelSaslGssapiPrivate"
            disguised="1">
    </record>
    <class name="SaslLogin"
           c:symbol-prefix="sasl_login"
           c:type="CamelSaslLogin"
           parent="Sasl"
           glib:type-name="CamelSaslLogin"
           glib:get-type="camel_sasl_login_get_type"
           glib:type-struct="SaslLoginClass">
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslLoginPrivate" c:type="CamelSaslLoginPrivate*"/>
      </field>
    </class>
    <record name="SaslLoginClass"
            c:type="CamelSaslLoginClass"
            glib:is-gtype-struct-for="SaslLogin">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslLoginPrivate"
            c:type="CamelSaslLoginPrivate"
            disguised="1">
    </record>
    <class name="SaslNTLM"
           c:symbol-prefix="sasl_ntlm"
           c:type="CamelSaslNTLM"
           parent="Sasl"
           glib:type-name="CamelSaslNTLM"
           glib:get-type="camel_sasl_ntlm_get_type"
           glib:type-struct="SaslNTLMClass">
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslNTLMPrivate" c:type="CamelSaslNTLMPrivate*"/>
      </field>
    </class>
    <record name="SaslNTLMClass"
            c:type="CamelSaslNTLMClass"
            glib:is-gtype-struct-for="SaslNTLM">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslNTLMPrivate" c:type="CamelSaslNTLMPrivate" disguised="1">
    </record>
    <class name="SaslPOPB4SMTP"
           c:symbol-prefix="sasl_popb4smtp"
           c:type="CamelSaslPOPB4SMTP"
           parent="Sasl"
           glib:type-name="CamelSaslPOPB4SMTP"
           glib:get-type="camel_sasl_popb4smtp_get_type"
           glib:type-struct="SaslPOPB4SMTPClass">
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslPOPB4SMTPPrivate" c:type="CamelSaslPOPB4SMTPPrivate*"/>
      </field>
    </class>
    <record name="SaslPOPB4SMTPClass"
            c:type="CamelSaslPOPB4SMTPClass"
            glib:is-gtype-struct-for="SaslPOPB4SMTP">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslPOPB4SMTPPrivate"
            c:type="CamelSaslPOPB4SMTPPrivate"
            disguised="1">
    </record>
    <class name="SaslPlain"
           c:symbol-prefix="sasl_plain"
           c:type="CamelSaslPlain"
           parent="Sasl"
           glib:type-name="CamelSaslPlain"
           glib:get-type="camel_sasl_plain_get_type"
           glib:type-struct="SaslPlainClass">
      <field name="parent">
        <type name="Sasl" c:type="CamelSasl"/>
      </field>
      <field name="priv">
        <type name="SaslPlainPrivate" c:type="CamelSaslPlainPrivate*"/>
      </field>
    </class>
    <record name="SaslPlainClass"
            c:type="CamelSaslPlainClass"
            glib:is-gtype-struct-for="SaslPlain">
      <field name="parent_class">
        <type name="SaslClass" c:type="CamelSaslClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SaslPlainPrivate"
            c:type="CamelSaslPlainPrivate"
            disguised="1">
    </record>
    <record name="SaslPrivate" c:type="CamelSaslPrivate" disguised="1">
    </record>
    <class name="Service"
           c:symbol-prefix="service"
           c:type="CamelService"
           parent="Object"
           abstract="1"
           glib:type-name="CamelService"
           glib:get-type="camel_service_get_type"
           glib:type-struct="ServiceClass">
      <implements name="Gio.Initable"/>
      <function name="error_quark" c:identifier="camel_service_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <virtual-method name="authenticate_sync"
                      invoker="authenticate_sync"
                      version="3.4"
                      throws="1">
        <doc xml:space="preserve">Attempts to authenticate @service using @mechanism and, if necessary,
@service's #CamelService:password property.  The function makes only
ONE attempt at authentication and does not loop.

If the authentication attempt completed and the server accepted the
credentials, the function returns #CAMEL_AUTHENTICATION_ACCEPTED.

If the authentication attempt completed but the server rejected the
credentials, the function returns #CAMEL_AUTHENTICATION_REJECTED.

If the authentication attempt failed to complete due to a network
communication issue or some other mishap, the function sets @error
and returns #CAMEL_AUTHENTICATION_ERROR.

Generally this function should only be called from a #CamelSession
subclass in order to implement its own authentication loop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the authentication result</doc>
          <type name="AuthenticationResult"
                c:type="CamelAuthenticationResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="mechanism"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="connect_sync"
                      invoker="connect_sync"
                      version="3.6"
                      throws="1">
        <doc xml:space="preserve">Connects @service to a remote server using the information in its
#CamelService:settings instance.

If a connect operation is already in progress when this function is
called, its results will be reflected in this connect operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is made or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="disconnect_sync"
                      invoker="disconnect_sync"
                      version="3.6"
                      throws="1">
        <doc xml:space="preserve">Disconnect from the service. If @clean is %FALSE, it should not
try to do any synchronizing or other cleanup of the connection.

If a disconnect operation is already in progress when this function is
called, its results will be reflected in this disconnect operation.

If any connect operations are in progress when this function is called,
they will be cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection was severed or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="clean" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to try to disconnect cleanly</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_name" invoker="get_name">
        <doc xml:space="preserve">This gets the name of the service in a "friendly" (suitable for
humans) form. If @brief is %TRUE, this should be a brief description
such as for use in the folder tree. If @brief is %FALSE, it should
be a more complete and mostly unambiguous description.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a description of the service which the caller must free</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="brief" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to use a briefer form</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query_auth_types_sync"
                      invoker="query_auth_types_sync"
                      throws="1">
        <doc xml:space="preserve">Obtains a list of authentication types supported by @service.
Free the returned list with g_list_free().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a list of #CamelServiceAuthType structs</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ServiceAuthType"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="authenticate"
              c:identifier="camel_service_authenticate"
              version="3.4">
        <doc xml:space="preserve">Asynchronously attempts to authenticate @service using @mechanism and,
if necessary, @service's #CamelService:password property.  The function
makes only ONE attempt at authentication and does not loop.

Generally this function should only be called from a #CamelSession
subclass in order to implement its own authentication loop.

When the operation is finished, @callback will be called.  You can
then call camel_service_authenticate_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="mechanism"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authenticate_finish"
              c:identifier="camel_service_authenticate_finish"
              version="3.4"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_service_authenticate().

If the authentication attempt completed and the server accepted the
credentials, the function returns #CAMEL_AUTHENTICATION_ACCEPTED.

If the authentication attempt completed but the server rejected the
credentials, the function returns #CAMEL_AUTHENTICATION_REJECTED.

If the authentication attempt failed to complete due to a network
communication issue or some other mishap, the function sets @error
and returns #CAMEL_AUTHENTICATION_ERROR.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the authentication result</doc>
          <type name="AuthenticationResult"
                c:type="CamelAuthenticationResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authenticate_sync"
              c:identifier="camel_service_authenticate_sync"
              version="3.4"
              throws="1">
        <doc xml:space="preserve">Attempts to authenticate @service using @mechanism and, if necessary,
@service's #CamelService:password property.  The function makes only
ONE attempt at authentication and does not loop.

If the authentication attempt completed and the server accepted the
credentials, the function returns #CAMEL_AUTHENTICATION_ACCEPTED.

If the authentication attempt completed but the server rejected the
credentials, the function returns #CAMEL_AUTHENTICATION_REJECTED.

If the authentication attempt failed to complete due to a network
communication issue or some other mishap, the function sets @error
and returns #CAMEL_AUTHENTICATION_ERROR.

Generally this function should only be called from a #CamelSession
subclass in order to implement its own authentication loop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the authentication result</doc>
          <type name="AuthenticationResult"
                c:type="CamelAuthenticationResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="mechanism"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect"
              c:identifier="camel_service_connect"
              version="3.6">
        <doc xml:space="preserve">Asynchronously connects @service to a remote server using the information
in its #CamelService:settings instance.

If a connect operation is already in progress when this function is
called, its results will be reflected in this connect operation.

If any disconnect operations are in progress when this function is
called, they will be cancelled.

When the operation is finished, @callback will be called.  You can
then call camel_service_connect_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_finish"
              c:identifier="camel_service_connect_finish"
              version="3.6"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_service_connect().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection was made or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_sync"
              c:identifier="camel_service_connect_sync"
              version="3.6"
              throws="1">
        <doc xml:space="preserve">Connects @service to a remote server using the information in its
#CamelService:settings instance.

If a connect operation is already in progress when this function is
called, its results will be reflected in this connect operation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is made or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect"
              c:identifier="camel_service_disconnect"
              version="3.6">
        <doc xml:space="preserve">If a disconnect operation is already in progress when this function is
called, its results will be reflected in this disconnect operation.

If any connect operations are in progress when this function is called,
they will be cancelled.

When the operation is finished, @callback will be called.  You can
then call camel_service_disconnect_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="clean" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to try to disconnect cleanly</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_finish"
              c:identifier="camel_service_disconnect_finish"
              version="3.6"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_service_disconnect().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection was severed or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_sync"
              c:identifier="camel_service_disconnect_sync"
              version="3.6"
              throws="1">
        <doc xml:space="preserve">Disconnect from the service. If @clean is %FALSE, it should not
try to do any synchronizing or other cleanup of the connection.

If a disconnect operation is already in progress when this function is
called, its results will be reflected in this disconnect operation.

If any connect operations are in progress when this function is called,
they will be cancelled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection was severed or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="clean" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to try to disconnect cleanly</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_display_name"
              c:identifier="camel_service_dup_display_name"
              version="3.12">
        <doc xml:space="preserve">Thread-safe variation of camel_service_get_display_name().
Use this function when accessing @service from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelService:display-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup_password"
              c:identifier="camel_service_dup_password"
              version="3.12">
        <doc xml:space="preserve">Thread-safe variation of camel_service_get_password().
Use this function when accessing @service from multiple threads.

The returned string should be freed with g_free() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated copy of #CamelService:password</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_status"
              c:identifier="camel_service_get_connection_status"
              version="3.2">
        <doc xml:space="preserve">Returns the connection status for @service.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection status</doc>
          <type name="ServiceConnectionStatus"
                c:type="CamelServiceConnectionStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_display_name"
              c:identifier="camel_service_get_display_name"
              version="3.2">
        <doc xml:space="preserve">Returns the display name for @service, or %NULL if @service has not
been given a display name.  The display name is intended for use in
a user interface and should generally be given a user-defined name.

Compare this with camel_service_get_name(), which returns a built-in
description of the type of service (IMAP, SMTP, etc.).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the display name for @service, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="camel_service_get_name">
        <doc xml:space="preserve">This gets the name of the service in a "friendly" (suitable for
humans) form. If @brief is %TRUE, this should be a brief description
such as for use in the folder tree. If @brief is %FALSE, it should
be a more complete and mostly unambiguous description.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a description of the service which the caller must free</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="brief" transfer-ownership="none">
            <doc xml:space="preserve">whether or not to use a briefer form</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_password"
              c:identifier="camel_service_get_password"
              version="3.4">
        <doc xml:space="preserve">Returns the password for @service.  Some SASL mechanisms use this
when attempting to authenticate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password for @service</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_provider" c:identifier="camel_service_get_provider">
        <doc xml:space="preserve">Gets the #CamelProvider associated with the service.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #CamelProvider</doc>
          <type name="Provider" c:type="CamelProvider*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uid"
              c:identifier="camel_service_get_uid"
              version="3.2">
        <doc xml:space="preserve">Gets the unique identifier string associated with the service.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the UID string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_cache_dir"
              c:identifier="camel_service_get_user_cache_dir"
              version="3.4">
        <doc xml:space="preserve">Returns the base directory under which to store cache data
for @service.  The directory is formed by appending the directory
returned by camel_session_get_user_cache_dir() with the service's
#CamelService:uid value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the base cache directory for @service</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data_dir"
              c:identifier="camel_service_get_user_data_dir"
              version="3.2">
        <doc xml:space="preserve">Returns the base directory under which to store user-specific data
for @service.  The directory is formed by appending the directory
returned by camel_session_get_user_data_dir() with the service's
#CamelService:uid value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the base directory for @service</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="migrate_files"
              c:identifier="camel_service_migrate_files"
              version="3.4">
        <doc xml:space="preserve">Performs any necessary file migrations for @service.  This should be
called after installing or configuring the @service's #CamelSettings,
since it requires building a URL string for @service.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_camel_url"
              c:identifier="camel_service_new_camel_url"
              version="3.2">
        <doc xml:space="preserve">Returns a new #CamelURL representing @service.
Free the returned #CamelURL with camel_url_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelURL</doc>
          <type name="URL" c:type="CamelURL*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_auth_types"
              c:identifier="camel_service_query_auth_types"
              version="3.2">
        <doc xml:space="preserve">Asynchronously obtains a list of authentication types supported by
@service.

When the operation is finished, @callback will be called.  You can
then call camel_service_query_auth_types_finish() to get the result
of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_auth_types_finish"
              c:identifier="camel_service_query_auth_types_finish"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_service_query_auth_types().
Free the returned list with g_list_free().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a list of #CamelServiceAuthType structs</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ServiceAuthType"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_auth_types_sync"
              c:identifier="camel_service_query_auth_types_sync"
              throws="1">
        <doc xml:space="preserve">Obtains a list of authentication types supported by @service.
Free the returned list with g_list_free().</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a list of #CamelServiceAuthType structs</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ServiceAuthType"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="queue_task"
              c:identifier="camel_service_queue_task"
              version="3.12">
        <doc xml:space="preserve">Adds @task to a queue of waiting tasks with the same source object.
Queued tasks execute one at a time in the order they were added.  When
@task reaches the front of the queue, it will be dispatched by invoking
@task_func in a separate thread.  If @task is cancelled while queued,
it will complete immediately with an appropriate error.

This is primarily intended for use by #CamelStore, #CamelTransport and
#CamelFolder to achieve ordered invocation of synchronous class methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="task" transfer-ownership="none">
            <doc xml:space="preserve">a #GTask</doc>
            <type name="Gio.Task" c:type="GTask*"/>
          </parameter>
          <parameter name="task_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to call when @task is dispatched</doc>
            <type name="Gio.TaskThreadFunc" c:type="GTaskThreadFunc"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_proxy_resolver"
              c:identifier="camel_service_ref_proxy_resolver"
              version="3.12">
        <doc xml:space="preserve">Returns the #GProxyResolver for @service.  If an application needs to
override this, it should do so prior to calling functions on @service
that may require a network connection.

The returned #GProxyResolver is referenced for thread-safety and must
be unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GProxyResolver, or %NULL</doc>
          <type name="Gio.ProxyResolver" c:type="GProxyResolver*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_session"
              c:identifier="camel_service_ref_session"
              version="3.8">
        <doc xml:space="preserve">Returns the #CamelSession associated with the service.

The returned #CamelSession is referenced for thread-safety.  Unreference
the #CamelSession with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #CamelSession</doc>
          <type name="Session" c:type="gpointer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_settings"
              c:identifier="camel_service_ref_settings"
              version="3.6">
        <doc xml:space="preserve">Returns the #CamelSettings instance associated with the service.

The returned #CamelSettings is referenced for thread-safety and must
be unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #CamelSettings</doc>
          <type name="Settings" c:type="CamelSettings*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_display_name"
              c:identifier="camel_service_set_display_name"
              version="3.2">
        <doc xml:space="preserve">Assigns a UTF-8 display name to @service.  The display name is intended
for use in a user interface and should generally be given a user-defined
name.

Compare this with camel_service_get_name(), which returns a built-in
description of the type of service (IMAP, SMTP, etc.).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:space="preserve">a valid UTF-8 string, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password"
              c:identifier="camel_service_set_password"
              version="3.4">
        <doc xml:space="preserve">Sets the password for @service.  Use this function to cache the password
in memory after obtaining it through camel_session_get_password().  Some
SASL mechanisms use this when attempting to authenticate.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">the password for @service</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_proxy_resolver"
              c:identifier="camel_service_set_proxy_resolver"
              version="3.12">
        <doc xml:space="preserve">Sets the #GProxyResolver for @service.  If an application needs to
override this, it should do so prior to calling functions on @service
that may require a network connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="proxy_resolver" transfer-ownership="none">
            <doc xml:space="preserve">a #GProxyResolver, or %NULL for the default</doc>
            <type name="Gio.ProxyResolver" c:type="GProxyResolver*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_settings"
              c:identifier="camel_service_set_settings"
              version="3.2">
        <doc xml:space="preserve">Associates a new #CamelSettings instance with the service.
The @settings instance must match the settings type defined in
#CamelServiceClass.  If @settings is %NULL, a new #CamelSettings
instance of the appropriate type is created with all properties
set to defaults.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </instance-parameter>
          <parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">an instance derviced from #CamelSettings, or %NULL</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </parameter>
        </parameters>
      </method>
      <property name="connection-status" transfer-ownership="none">
        <type name="ServiceConnectionStatus"/>
      </property>
      <property name="display-name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="provider"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Provider"/>
      </property>
      <property name="proxy-resolver" writable="1" transfer-ownership="none">
        <type name="Gio.ProxyResolver"/>
      </property>
      <property name="session"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Session"/>
      </property>
      <property name="settings"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Settings"/>
      </property>
      <property name="uid"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="CamelObject"/>
      </field>
      <field name="priv">
        <type name="ServicePrivate" c:type="CamelServicePrivate*"/>
      </field>
    </class>
    <record name="ServiceAuthType"
            c:type="CamelServiceAuthType"
            glib:type-name="CamelServiceAuthType"
            glib:get-type="camel_service_auth_type_get_type"
            c:symbol-prefix="service_auth_type">
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="authproto" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="need_password" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <method name="copy"
              c:identifier="camel_service_auth_type_copy"
              version="3.24">
        <doc xml:space="preserve">Copies the @service_auth_type struct.
Does nothing and returns the given object in reality, needed for the introspection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of @service_auth_type</doc>
          <type name="ServiceAuthType" c:type="CamelServiceAuthType*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service_auth_type"
                              transfer-ownership="none">
            <doc xml:space="preserve">an #CamelServiceAuthType</doc>
            <type name="ServiceAuthType" c:type="const CamelServiceAuthType*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="camel_service_auth_type_free"
              version="3.24">
        <doc xml:space="preserve">Frees the @service_auth_type struct.
Does nothing in reality, needed for the introspection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service_auth_type"
                              transfer-ownership="none">
            <doc xml:space="preserve">an #CamelServiceAuthType</doc>
            <type name="ServiceAuthType" c:type="CamelServiceAuthType*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="ServiceClass"
            c:type="CamelServiceClass"
            glib:is-gtype-struct-for="Service">
      <field name="parent_class">
        <type name="ObjectClass" c:type="CamelObjectClass"/>
      </field>
      <field name="settings_type">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="get_name">
        <callback name="get_name">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a description of the service which the caller must free</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="brief" transfer-ownership="none">
              <doc xml:space="preserve">whether or not to use a briefer form</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="connect_sync">
        <callback name="connect_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the connection is made or %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="disconnect_sync">
        <callback name="disconnect_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the connection was severed or %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="clean" transfer-ownership="none">
              <doc xml:space="preserve">whether or not to try to disconnect cleanly</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="authenticate_sync">
        <callback name="authenticate_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the authentication result</doc>
            <type name="AuthenticationResult"
                  c:type="CamelAuthenticationResult"/>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="mechanism"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query_auth_types_sync">
        <callback name="query_auth_types_sync" throws="1">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">a list of #CamelServiceAuthType structs</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ServiceAuthType"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="ServiceConnectionStatus"
                 version="3.6"
                 glib:type-name="CamelServiceConnectionStatus"
                 glib:get-type="camel_service_connection_status_get_type"
                 c:type="CamelServiceConnectionStatus">
      <doc xml:space="preserve">Connection status returned by camel_service_get_connection_status().</doc>
      <member name="disconnected"
              value="0"
              c:identifier="CAMEL_SERVICE_DISCONNECTED"
              glib:nick="disconnected">
        <doc xml:space="preserve">#CamelService is disconnected from a remote server.</doc>
      </member>
      <member name="connecting"
              value="1"
              c:identifier="CAMEL_SERVICE_CONNECTING"
              glib:nick="connecting">
        <doc xml:space="preserve">#CamelService is connecting to a remote server.</doc>
      </member>
      <member name="connected"
              value="2"
              c:identifier="CAMEL_SERVICE_CONNECTED"
              glib:nick="connected">
        <doc xml:space="preserve">#CamelService is connected to a remote server.</doc>
      </member>
      <member name="disconnecting"
              value="3"
              c:identifier="CAMEL_SERVICE_DISCONNECTING"
              glib:nick="disconnecting">
        <doc xml:space="preserve">#CamelService is disconnecting from a remote server.</doc>
      </member>
    </enumeration>
    <enumeration name="ServiceError" version="2.32" c:type="CamelServiceError">
      <member name="invalid"
              value="0"
              c:identifier="CAMEL_SERVICE_ERROR_INVALID">
        <doc xml:space="preserve">a generic service error code</doc>
      </member>
      <member name="url_invalid"
              value="1"
              c:identifier="CAMEL_SERVICE_ERROR_URL_INVALID">
        <doc xml:space="preserve">the URL for the service is invalid</doc>
      </member>
      <member name="unavailable"
              value="2"
              c:identifier="CAMEL_SERVICE_ERROR_UNAVAILABLE">
        <doc xml:space="preserve">the service is unavailable</doc>
      </member>
      <member name="cant_authenticate"
              value="3"
              c:identifier="CAMEL_SERVICE_ERROR_CANT_AUTHENTICATE">
        <doc xml:space="preserve">failed to authenitcate</doc>
      </member>
      <member name="not_connected"
              value="4"
              c:identifier="CAMEL_SERVICE_ERROR_NOT_CONNECTED">
        <doc xml:space="preserve">the service is not connected</doc>
      </member>
    </enumeration>
    <record name="ServicePrivate" c:type="CamelServicePrivate" disguised="1">
    </record>
    <class name="Session"
           c:symbol-prefix="session"
           c:type="CamelSession"
           parent="GObject.Object"
           glib:type-name="CamelSession"
           glib:get-type="camel_session_get_type"
           glib:type-struct="SessionClass">
      <virtual-method name="add_service"
                      invoker="add_service"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Instantiates a new #CamelService for @session.  The @uid identifies the
service for future lookup.  The @protocol indicates which #CamelProvider
holds the #GType of the #CamelService subclass to instantiate.  The @type
explicitly designates the service as a #CamelStore or #CamelTransport.

If the given @uid has already been added, the existing #CamelService
with that @uid is returned regardless of whether it agrees with the
given @protocol and @type.

If no #CamelProvider is available to handle the given @protocol, or
if the #CamelProvider does not specify a valid #GType for @type, the
function sets @error and returns %NULL.

The returned #CamelService is referenced for thread-safety and must be
unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelService instance, or %NULL</doc>
          <type name="Service" c:type="CamelService*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a unique identifier string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the service protocol</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the service type</doc>
            <type name="ProviderType" c:type="CamelProviderType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="authenticate_sync"
                      invoker="authenticate_sync"
                      version="3.4"
                      throws="1">
        <doc xml:space="preserve">Authenticates @service, which may involve repeated calls to
camel_service_authenticate() or camel_service_authenticate_sync().
A #CamelSession subclass is largely responsible for implementing this,
and should handle things like user prompts and secure password storage.
These issues are out-of-scope for Camel.

If an error occurs, or if authentication is aborted, the function sets
@error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="mechanism"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="forget_password"
                      invoker="forget_password"
                      throws="1">
        <doc xml:space="preserve">This function is used by a #CamelService to tell the application
that the authentication information it provided via
camel_session_get_password() was rejected by the service. If the
application was caching this information, it should stop,
and if the service asks for it again, it should ask the user.

@service and @item identify the rejected authentication information,
as with camel_session_get_password().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelService rejecting the password</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">an identifier, unique within this service, for the information</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="forward_to_sync"
                      invoker="forward_to_sync"
                      version="3.6"
                      throws="1">
        <doc xml:space="preserve">Forwards @message in @folder to the email address(es) given by @address.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelFolder where @message is located</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelMimeMessage to forward</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the recipient's email address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_filter_driver"
                      invoker="get_filter_driver"
                      throws="1">
        <doc xml:space="preserve">The optional @for_folder can be used to determine which filters
to add and which not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a filter driver, loaded with applicable rules</doc>
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of filter (eg, "incoming")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="for_folder"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an optional #CamelFolder, for which the filter driver will run, or %NULL</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_password" invoker="get_password" throws="1">
        <doc xml:space="preserve">This function is used by a #CamelService to ask the application and
the user for a password or other authentication data.

@service and @item together uniquely identify the piece of data the
caller is concerned with.

@prompt is a question to ask the user (if the application doesn't
already have the answer cached). If %CAMEL_SESSION_PASSWORD_SECRET
is set, the user's input will not be echoed back.

If %CAMEL_SESSION_PASSWORD_STATIC is set, it means the password returned
will be stored statically by the caller automatically, for the current
session.

The authenticator should set @error to %G_IO_ERROR_CANCELLED if
the user did not provide the information. The caller must g_free()
the information returned when it is done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the authentication information or %NULL</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelService this query is being made by</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">prompt to provide to user</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">an identifier, unique within this service, for the information</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">%CAMEL_SESSION_PASSWORD_REPROMPT, the prompt should force a reprompt
%CAMEL_SESSION_PASSWORD_SECRET, whether the password is secret
%CAMEL_SESSION_PASSWORD_STATIC, the password is remembered externally</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="job_finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="job_started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_addressbook"
                      invoker="lookup_addressbook"
                      version="2.22">
        <doc xml:space="preserve">Looks up for the @name in address books.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether found the @name in any address book.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name/address to lookup for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_service"
                      invoker="remove_service"
                      version="3.2">
        <doc xml:space="preserve">Removes a #CamelService previously added by camel_session_add_service().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelService to remove</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="trust_prompt" invoker="trust_prompt" version="3.8">
        <doc xml:space="preserve">Prompts the user whether to accept @certificate for @service.  The
set of flags given in @errors indicate why the @certificate failed
validation.

If an error occurs during prompting or if the user declines to respond,
the function returns #CAMEL_CERT_TRUST_UNKNOWN and the certificate will
be rejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the user's trust level for @certificate</doc>
          <type name="CertTrust" c:type="CamelCertTrust"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <doc xml:space="preserve">the problems with @certificate</doc>
            <type name="Gio.TlsCertificateFlags"
                  c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="user_alert" invoker="user_alert" version="3.12">
        <doc xml:space="preserve">Emits a #CamelSession:user_alert signal from an idle source on the main
loop.  The idle source's priority is #G_PRIORITY_LOW.

The purpose of the signal is to propagate a server-issued alert message
from @service to a user interface.  The @type hints at the nature of the
alert message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSessionAlertType</doc>
            <type name="SessionAlertType" c:type="CamelSessionAlertType"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message for the user</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_service"
              c:identifier="camel_session_add_service"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Instantiates a new #CamelService for @session.  The @uid identifies the
service for future lookup.  The @protocol indicates which #CamelProvider
holds the #GType of the #CamelService subclass to instantiate.  The @type
explicitly designates the service as a #CamelStore or #CamelTransport.

If the given @uid has already been added, the existing #CamelService
with that @uid is returned regardless of whether it agrees with the
given @protocol and @type.

If no #CamelProvider is available to handle the given @protocol, or
if the #CamelProvider does not specify a valid #GType for @type, the
function sets @error and returns %NULL.

The returned #CamelService is referenced for thread-safety and must be
unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelService instance, or %NULL</doc>
          <type name="Service" c:type="CamelService*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a unique identifier string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">the service protocol</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the service type</doc>
            <type name="ProviderType" c:type="CamelProviderType"/>
          </parameter>
        </parameters>
      </method>
      <method name="authenticate"
              c:identifier="camel_session_authenticate"
              version="3.4">
        <doc xml:space="preserve">Asynchronously authenticates @service, which may involve repeated calls
to camel_service_authenticate() or camel_service_authenticate_sync().
A #CamelSession subclass is largely responsible for implementing this,
and should handle things like user prompts and secure password storage.
These issues are out-of-scope for Camel.

When the operation is finished, @callback will be called.  You can
then call camel_session_authenticate_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="mechanism"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority for the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authenticate_finish"
              c:identifier="camel_session_authenticate_finish"
              version="3.4"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_session_authenticate().

If an error occurred, or if authentication was aborted, the function
sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authenticate_sync"
              c:identifier="camel_session_authenticate_sync"
              version="3.4"
              throws="1">
        <doc xml:space="preserve">Authenticates @service, which may involve repeated calls to
camel_service_authenticate() or camel_service_authenticate_sync().
A #CamelSession subclass is largely responsible for implementing this,
and should handle things like user prompts and secure password storage.
These issues are out-of-scope for Camel.

If an error occurs, or if authentication is aborted, the function sets
@error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="mechanism"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="forget_password"
              c:identifier="camel_session_forget_password"
              throws="1">
        <doc xml:space="preserve">This function is used by a #CamelService to tell the application
that the authentication information it provided via
camel_session_get_password() was rejected by the service. If the
application was caching this information, it should stop,
and if the service asks for it again, it should ask the user.

@service and @item identify the rejected authentication information,
as with camel_session_get_password().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelService rejecting the password</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">an identifier, unique within this service, for the information</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="forward_to"
              c:identifier="camel_session_forward_to"
              version="3.6">
        <doc xml:space="preserve">Asynchronously forwards @message in @folder to the email address(s)
given by @address.

When the operation is finished, @callback will be called.  You can
then call camel_session_forward_to_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelFolder where @message is located</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelMimeMessage to forward</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the recipient's email address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority for the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="forward_to_finish"
              c:identifier="camel_session_forward_to_finish"
              version="3.6"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_session_forward_to().

If an error occurred, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="forward_to_sync"
              c:identifier="camel_session_forward_to_sync"
              version="3.6"
              throws="1">
        <doc xml:space="preserve">Forwards @message in @folder to the email address(es) given by @address.

If an error occurs, the function sets @error and returns %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelFolder where @message is located</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelMimeMessage to forward</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the recipient's email address</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_filter_driver"
              c:identifier="camel_session_get_filter_driver"
              throws="1">
        <doc xml:space="preserve">The optional @for_folder can be used to determine which filters
to add and which not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a filter driver, loaded with applicable rules</doc>
          <type name="FilterDriver" c:type="CamelFilterDriver*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of filter (eg, "incoming")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="for_folder"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an optional #CamelFolder, for which the filter driver will run, or %NULL</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_junk_filter"
              c:identifier="camel_session_get_junk_filter"
              version="3.2">
        <doc xml:space="preserve">Returns the #CamelJunkFilter instance used to classify messages as
junk or not junk during filtering.

Note that #CamelJunkFilter itself is just an interface.  The application
must implement the interface and install a #CamelJunkFilter instance for
junk filtering to take place.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelJunkFilter, or %NULL</doc>
          <type name="JunkFilter" c:type="CamelJunkFilter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_junk_headers"
              c:identifier="camel_session_get_junk_headers"
              version="2.22">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Currently used junk
   headers as a hash table, previously set by camel_session_set_junk_headers().</doc>
          <type name="GLib.HashTable" c:type="const GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_online" c:identifier="camel_session_get_online">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether or not @session is online</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password"
              c:identifier="camel_session_get_password"
              throws="1">
        <doc xml:space="preserve">This function is used by a #CamelService to ask the application and
the user for a password or other authentication data.

@service and @item together uniquely identify the piece of data the
caller is concerned with.

@prompt is a question to ask the user (if the application doesn't
already have the answer cached). If %CAMEL_SESSION_PASSWORD_SECRET
is set, the user's input will not be echoed back.

If %CAMEL_SESSION_PASSWORD_STATIC is set, it means the password returned
will be stored statically by the caller automatically, for the current
session.

The authenticator should set @error to %G_IO_ERROR_CANCELLED if
the user did not provide the information. The caller must g_free()
the information returned when it is done with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the authentication information or %NULL</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelService this query is being made by</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">prompt to provide to user</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">an identifier, unique within this service, for the information</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">%CAMEL_SESSION_PASSWORD_REPROMPT, the prompt should force a reprompt
%CAMEL_SESSION_PASSWORD_SECRET, whether the password is secret
%CAMEL_SESSION_PASSWORD_STATIC, the password is remembered externally</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_cache_dir"
              c:identifier="camel_session_get_user_cache_dir"
              version="3.4">
        <doc xml:space="preserve">Returns the base directory under which to store user-specific mail cache.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the base directory for mail cache</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_data_dir"
              c:identifier="camel_session_get_user_data_dir"
              version="3.2">
        <doc xml:space="preserve">Returns the base directory under which to store user-specific mail data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the base directory for mail data</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="idle_add"
              c:identifier="camel_session_idle_add"
              version="3.6">
        <doc xml:space="preserve">Adds a function to be called whenever there are no higher priority events
pending.  If @function returns %FALSE it is automatically removed from the
list of event sources and will not be called again.

This internally creates a main loop source using g_idle_source_new()
and attaches it to @session's own #CamelSession:main-context using
g_source_attach().

The @priority is typically in the range between %G_PRIORITY_DEFAULT_IDLE
and %G_PRIORITY_HIGH_IDLE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the priority of the idle source</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="function"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">a function to call</doc>
            <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to @function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to call when the idle is removed, or %NULL</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_services"
              c:identifier="camel_session_list_services"
              version="3.2">
        <doc xml:space="preserve">Returns a list of all #CamelService objects previously added using
camel_session_add_service().

The services returned in the list are referenced for thread-safety.
They must each be unreferenced with g_object_unref() when finished
with them.  Free the returned list itself with g_list_free().

An easy way to free the list property in one step is as follows:

|[
  g_list_free_full (list, g_object_unref);
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an unsorted list of #CamelService objects</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Service"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="lookup_addressbook"
              c:identifier="camel_session_lookup_addressbook"
              version="2.22">
        <doc xml:space="preserve">Looks up for the @name in address books.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether found the @name in any address book.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a name/address to lookup for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_main_context"
              c:identifier="camel_session_ref_main_context"
              version="3.8">
        <doc xml:space="preserve">Returns the #GMainContext on which event sources for @session are to
be attached.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GMainContext</doc>
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_network_monitor"
              c:identifier="camel_session_ref_network_monitor"
              version="3.22">
        <doc xml:space="preserve">References a #GNetworkMonitor instance, which had been previously set
by camel_session_set_network_monitor(). If none is set, then the default
#GNetworkMonitor is returned, as provided by g_network_monitor_get_default().
The returned pointer is referenced for thread safety, unref it with
g_object_unref() when no longer needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A referenced #GNetworkMonitor instance to use
  for network availability tests.</doc>
          <type name="Gio.NetworkMonitor" c:type="GNetworkMonitor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref_service"
              c:identifier="camel_session_ref_service"
              version="3.6">
        <doc xml:space="preserve">Looks up a #CamelService by its unique identifier string.  The service
must have been previously added using camel_session_add_service().

The returned #CamelService is referenced for thread-safety and must be
unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelService instance, or %NULL</doc>
          <type name="Service" c:type="CamelService*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a unique identifier string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_service_by_url"
              c:identifier="camel_session_ref_service_by_url"
              version="3.6">
        <doc xml:space="preserve">Looks up a #CamelService by trying to match its #CamelURL against the
given @url and then checking that the object is of the desired @type.
The service must have been previously added using
camel_session_add_service().

The returned #CamelService is referenced for thread-safety and must be
unreferenced with g_object_unref() when finished with it.

Note this function is significantly slower than camel_session_ref_service().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelService instance, or %NULL</doc>
          <type name="Service" c:type="CamelService*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelProviderType</doc>
            <type name="ProviderType" c:type="CamelProviderType"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_service"
              c:identifier="camel_session_remove_service"
              version="3.2">
        <doc xml:space="preserve">Removes a #CamelService previously added by camel_session_add_service().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelService to remove</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_services"
              c:identifier="camel_session_remove_services"
              version="3.2">
        <doc xml:space="preserve">Removes all #CamelService instances added by camel_session_add_service().

This can be useful during application shutdown to ensure all #CamelService
instances are freed properly, especially since #CamelSession instances are
prone to reference cycles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_junk_filter"
              c:identifier="camel_session_set_junk_filter"
              version="3.2">
        <doc xml:space="preserve">Installs the #CamelJunkFilter instance used to classify messages as
junk or not junk during filtering.

Note that #CamelJunkFilter itself is just an interface.  The application
must implement the interface and install a #CamelJunkFilter instance for
junk filtering to take place.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="junk_filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelJunkFilter, or %NULL</doc>
            <type name="JunkFilter" c:type="CamelJunkFilter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_junk_headers"
              c:identifier="camel_session_set_junk_headers"
              version="2.22">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="headers" transfer-ownership="none">
            <array length="2" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <array zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the length of the headers and values arrays</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_network_monitor"
              c:identifier="camel_session_set_network_monitor"
              version="3.22">
        <doc xml:space="preserve">Sets a network monitor instance for the @session. This can be used
to override which #GNetworkMonitor should be used to check network
availability and whether a server is reachable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="network_monitor"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GNetworkMonitor or %NULL</doc>
            <type name="Gio.NetworkMonitor" c:type="GNetworkMonitor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_online" c:identifier="camel_session_set_online">
        <doc xml:space="preserve">Sets the online status of @session to @online.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="online" transfer-ownership="none">
            <doc xml:space="preserve">whether or not the session should be online</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="submit_job"
              c:identifier="camel_session_submit_job"
              version="3.2">
        <doc xml:space="preserve">This function provides a simple mechanism for providers to initiate
low-priority background jobs.  Jobs can be submitted from any thread,
but execution of the jobs is always as follows:

1) The #CamelSession:job-started signal is emitted from the thread
   in which @session was created.  This is typically the same thread
   that hosts the global default #GMainContext, or "main" thread.

2) The @callback function is invoked from a different thread where
   it's safe to call synchronous functions.

3) Once @callback has returned, the #CamelSesson:job-finished signal
   is emitted from the same thread as #CamelSession:job-started was
   emitted.

4) Finally if a @notify function was provided, it is invoked and
   passed @user_data so that @user_data can be freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">human readable description of the job, shown to a user</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">a #CamelSessionCallback</doc>
            <type name="SessionCallback" c:type="CamelSessionCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">a #GDestroyNotify function</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="trust_prompt"
              c:identifier="camel_session_trust_prompt"
              version="3.8">
        <doc xml:space="preserve">Prompts the user whether to accept @certificate for @service.  The
set of flags given in @errors indicate why the @certificate failed
validation.

If an error occurs during prompting or if the user declines to respond,
the function returns #CAMEL_CERT_TRUST_UNKNOWN and the certificate will
be rejected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the user's trust level for @certificate</doc>
          <type name="CertTrust" c:type="CamelCertTrust"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
            <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="errors" transfer-ownership="none">
            <doc xml:space="preserve">the problems with @certificate</doc>
            <type name="Gio.TlsCertificateFlags"
                  c:type="GTlsCertificateFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="user_alert"
              c:identifier="camel_session_user_alert"
              version="3.12">
        <doc xml:space="preserve">Emits a #CamelSession:user_alert signal from an idle source on the main
loop.  The idle source's priority is #G_PRIORITY_LOW.

The purpose of the signal is to propagate a server-issued alert message
from @service to a user interface.  The @type hints at the nature of the
alert message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSession</doc>
            <type name="Session" c:type="CamelSession*"/>
          </instance-parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelService</doc>
            <type name="Service" c:type="CamelService*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSessionAlertType</doc>
            <type name="SessionAlertType" c:type="CamelSessionAlertType"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the message for the user</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="junk-filter" writable="1" transfer-ownership="none">
        <type name="JunkFilter"/>
      </property>
      <property name="main-context" transfer-ownership="none">
        <type name="GLib.MainContext"/>
      </property>
      <property name="network-monitor" writable="1" transfer-ownership="none">
        <type name="Gio.NetworkMonitor"/>
      </property>
      <property name="online"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="user-cache-dir"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="user-data-dir"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="SessionPrivate" c:type="CamelSessionPrivate*"/>
      </field>
      <glib:signal name="job-finished" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="GLib.Error"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="job-started" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="user-alert" when="last">
        <doc xml:space="preserve">This purpose of this signal is to propagate a server-issued alert
message from @service to a user interface.  The @type hints at the
severity of the alert message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelService issuing the alert</doc>
            <type name="Service"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelSessionAlertType</doc>
            <type name="SessionAlertType"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the alert message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <enumeration name="SessionAlertType"
                 glib:type-name="CamelSessionAlertType"
                 glib:get-type="camel_session_alert_type_get_type"
                 c:type="CamelSessionAlertType">
      <member name="info"
              value="0"
              c:identifier="CAMEL_SESSION_ALERT_INFO"
              glib:nick="info">
      </member>
      <member name="warning"
              value="1"
              c:identifier="CAMEL_SESSION_ALERT_WARNING"
              glib:nick="warning">
      </member>
      <member name="error"
              value="2"
              c:identifier="CAMEL_SESSION_ALERT_ERROR"
              glib:nick="error">
      </member>
    </enumeration>
    <callback name="SessionCallback"
              c:type="CamelSessionCallback"
              version="3.2"
              throws="1">
      <doc xml:space="preserve">This is the callback signature for jobs submitted to the CamelSession
via camel_session_submit_job().  The @error pointer is always non-%NULL,
so it's safe to dereference to check if a #GError has been set.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="session" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelSession</doc>
          <type name="Session" c:type="CamelSession*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #CamelOperation cast as a #GCancellable</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">data passed to camel_session_submit_job()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SessionClass"
            c:type="CamelSessionClass"
            glib:is-gtype-struct-for="Session">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_service">
        <callback name="add_service" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #CamelService instance, or %NULL</doc>
            <type name="Service" c:type="CamelService*"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="uid" transfer-ownership="none">
              <doc xml:space="preserve">a unique identifier string</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="protocol" transfer-ownership="none">
              <doc xml:space="preserve">the service protocol</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">the service type</doc>
              <type name="ProviderType" c:type="CamelProviderType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_service">
        <callback name="remove_service">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">the #CamelService to remove</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_password">
        <callback name="get_password" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the authentication information or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">the #CamelService this query is being made by</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="prompt" transfer-ownership="none">
              <doc xml:space="preserve">prompt to provide to user</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="item" transfer-ownership="none">
              <doc xml:space="preserve">an identifier, unique within this service, for the information</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">%CAMEL_SESSION_PASSWORD_REPROMPT, the prompt should force a reprompt
%CAMEL_SESSION_PASSWORD_SECRET, whether the password is secret
%CAMEL_SESSION_PASSWORD_STATIC, the password is remembered externally</doc>
              <type name="guint32" c:type="guint32"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="forget_password">
        <callback name="forget_password" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">the #CamelService rejecting the password</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="item" transfer-ownership="none">
              <doc xml:space="preserve">an identifier, unique within this service, for the information</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="trust_prompt">
        <callback name="trust_prompt">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the user's trust level for @certificate</doc>
            <type name="CertTrust" c:type="CamelCertTrust"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="certificate" transfer-ownership="none">
              <doc xml:space="preserve">the peer's #GTlsCertificate</doc>
              <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
            </parameter>
            <parameter name="errors" transfer-ownership="none">
              <doc xml:space="preserve">the problems with @certificate</doc>
              <type name="Gio.TlsCertificateFlags"
                    c:type="GTlsCertificateFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_filter_driver">
        <callback name="get_filter_driver" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">a filter driver, loaded with applicable rules</doc>
            <type name="FilterDriver" c:type="CamelFilterDriver*"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">the type of filter (eg, "incoming")</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="for_folder"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">an optional #CamelFolder, for which the filter driver will run, or %NULL</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_addressbook">
        <callback name="lookup_addressbook">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether found the @name in any address book.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve">a name/address to lookup for</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="authenticate_sync">
        <callback name="authenticate_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="mechanism"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a SASL mechanism name, or %NULL</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="forward_to_sync">
        <callback name="forward_to_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">the #CamelFolder where @message is located</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">the #CamelMimeMessage to forward</doc>
              <type name="MimeMessage" c:type="CamelMimeMessage*"/>
            </parameter>
            <parameter name="address" transfer-ownership="none">
              <doc xml:space="preserve">the recipient's email address</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_methods">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="job_started">
        <callback name="job_started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="job_finished">
        <callback name="job_finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="const GError*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="user_alert">
        <callback name="user_alert">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSession</doc>
              <type name="Session" c:type="CamelSession*"/>
            </parameter>
            <parameter name="service" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelService</doc>
              <type name="Service" c:type="CamelService*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSessionAlertType</doc>
              <type name="SessionAlertType" c:type="CamelSessionAlertType"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">the message for the user</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_signals">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SessionPrivate" c:type="CamelSessionPrivate" disguised="1">
    </record>
    <class name="Settings"
           c:symbol-prefix="settings"
           c:type="CamelSettings"
           version="3.2"
           parent="GObject.Object"
           glib:type-name="CamelSettings"
           glib:get-type="camel_settings_get_type"
           glib:type-struct="SettingsClass">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <virtual-method name="clone" invoker="clone" version="3.2">
        <doc xml:space="preserve">Creates an copy of @settings, such that passing @settings and the
copied instance to camel_settings_equal() would return %TRUE.

By default, this creates a new settings instance with the same #GType
as @settings, and copies all #GObject property values from @settings
to the new instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-created copy of @settings</doc>
          <type name="Settings" c:type="CamelSettings*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSettings</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="equal" invoker="equal" version="3.2">
        <doc xml:space="preserve">Returns %TRUE if @settings_a and @settings_b are equal.

By default, equality requires both instances to have the same #GType
with the same set of #GObject properties, and each property value in
@settings_a is equal to the corresponding value in @settings_b.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @settings_a and @settings_b are equal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings_a" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSettings</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </instance-parameter>
          <parameter name="settings_b" transfer-ownership="none">
            <doc xml:space="preserve">another #CamelSettings</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clone" c:identifier="camel_settings_clone" version="3.2">
        <doc xml:space="preserve">Creates an copy of @settings, such that passing @settings and the
copied instance to camel_settings_equal() would return %TRUE.

By default, this creates a new settings instance with the same #GType
as @settings, and copies all #GObject property values from @settings
to the new instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-created copy of @settings</doc>
          <type name="Settings" c:type="CamelSettings*"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSettings</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="camel_settings_equal" version="3.2">
        <doc xml:space="preserve">Returns %TRUE if @settings_a and @settings_b are equal.

By default, equality requires both instances to have the same #GType
with the same set of #GObject properties, and each property value in
@settings_a is equal to the corresponding value in @settings_b.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @settings_a and @settings_b are equal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings_a" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSettings</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </instance-parameter>
          <parameter name="settings_b" transfer-ownership="none">
            <doc xml:space="preserve">another #CamelSettings</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SettingsPrivate" c:type="CamelSettingsPrivate*"/>
      </field>
    </class>
    <record name="SettingsClass"
            c:type="CamelSettingsClass"
            glib:is-gtype-struct-for="Settings">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="list_settings" introspectable="0">
        <callback name="list_settings" introspectable="0">
          <return-value>
            <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
          </return-value>
          <parameters>
            <parameter name="klass" transfer-ownership="none">
              <type name="SettingsClass" c:type="CamelSettingsClass*"/>
            </parameter>
            <parameter name="n_settings" transfer-ownership="none">
              <type name="guint" c:type="guint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clone">
        <callback name="clone">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly-created copy of @settings</doc>
            <type name="Settings" c:type="CamelSettings*"/>
          </return-value>
          <parameters>
            <parameter name="settings" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSettings</doc>
              <type name="Settings" c:type="CamelSettings*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="equal">
        <callback name="equal">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if @settings_a and @settings_b are equal</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="settings_a" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSettings</doc>
              <type name="Settings" c:type="CamelSettings*"/>
            </parameter>
            <parameter name="settings_b" transfer-ownership="none">
              <doc xml:space="preserve">another #CamelSettings</doc>
              <type name="Settings" c:type="CamelSettings*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="list_settings"
              c:identifier="camel_settings_class_list_settings"
              version="3.2">
        <doc xml:space="preserve">Returns an array of #GParamSpec for properties of @class which are
considered to be settings.  By default all properties are considered
to be settings, but subclasses may wish to exclude certain properties.
Free the returned array with g_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of #GParamSpec which should be freed after use</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings_class" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSettingsClass</doc>
            <type name="SettingsClass" c:type="CamelSettingsClass*"/>
          </instance-parameter>
          <parameter name="n_settings" transfer-ownership="none">
            <doc xml:space="preserve">return location for the length of the returned array</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="SettingsPrivate" c:type="CamelSettingsPrivate" disguised="1">
    </record>
    <enumeration name="SortType"
                 version="3.2"
                 glib:type-name="CamelSortType"
                 glib:get-type="camel_sort_type_get_type"
                 c:type="CamelSortType">
      <doc xml:space="preserve">Determines the direction of a sort.</doc>
      <member name="ascending"
              value="0"
              c:identifier="CAMEL_SORT_ASCENDING"
              glib:nick="ascending">
        <doc xml:space="preserve">Sorting is in ascending order.</doc>
      </member>
      <member name="descending"
              value="1"
              c:identifier="CAMEL_SORT_DESCENDING"
              glib:nick="descending">
        <doc xml:space="preserve">Sorting is in descending order.</doc>
      </member>
    </enumeration>
    <class name="Store"
           c:symbol-prefix="store"
           c:type="CamelStore"
           parent="Service"
           abstract="1"
           glib:type-name="CamelStore"
           glib:get-type="camel_store_get_type"
           glib:type-struct="StoreClass">
      <implements name="Gio.Initable"/>
      <function name="error_quark" c:identifier="camel_store_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <virtual-method name="can_refresh_folder"
                      invoker="can_refresh_folder"
                      version="2.22"
                      throws="1">
        <doc xml:space="preserve">Returns if this folder (param info) should be checked for new mail or not.
It should not look into sub infos (info-&gt;child) or next infos, it should
return value only for the actual folder info.
Default behavior is that all Inbox folders are intended to be refreshed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether folder should be checked for new mails</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderInfo</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_folder_sync"
                      invoker="create_folder_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Creates a new folder as a child of an existing folder.
@parent_name can be %NULL to create a new top-level folder.
The returned #CamelFolderInfo struct should be freed with
camel_folder_info_free().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">info about the created folder, or %NULL on error</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="parent_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">name of the new folder's parent, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to create</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delete_folder_sync"
                      invoker="delete_folder_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Deletes the folder described by @folder_name.  The folder must be empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_created"
                      invoker="folder_created"
                      version="2.32">
        <doc xml:space="preserve">Emits the #CamelStore::folder-created signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the created folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_deleted"
                      invoker="folder_deleted"
                      version="2.32">
        <doc xml:space="preserve">Emits the #CamelStore::folder-deleted signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the deleted folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_info_stale"
                      invoker="folder_info_stale"
                      version="3.10">
        <doc xml:space="preserve">Emits the #CamelStore::folder-info-stale signal from an idle source
on the main loop.  The idle source's priority is #G_PRIORITY_LOW.

See the #CamelStore::folder-info-stale documentation for details on
when to use this signal.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_opened"
                      invoker="folder_opened"
                      version="3.0">
        <doc xml:space="preserve">Emits the #CamelStore::folder-opened signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelFolder that was opened</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_renamed"
                      invoker="folder_renamed"
                      version="2.32">
        <doc xml:space="preserve">Emits the #CamelStore::folder-renamed signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the old name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the renamed folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_folder_info_sync"
                      invoker="get_folder_info_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">This fetches information about the folder structure of @store,
starting with @top, and returns a tree of #CamelFolderInfo
structures. If @flags includes %CAMEL_STORE_FOLDER_INFO_SUBSCRIBED,
only subscribed folders will be listed.   If the store doesn't support
subscriptions, then it will list all folders.  If @flags includes
%CAMEL_STORE_FOLDER_INFO_RECURSIVE, the returned tree will include
all levels of hierarchy below @top. If not, it will only include
the immediate subfolders of @top. If @flags includes
%CAMEL_STORE_FOLDER_INFO_FAST, the unread_message_count fields of
some or all of the structures may be set to %-1, if the store cannot
determine that information quickly.  If @flags includes
%CAMEL_STORE_FOLDER_INFO_NO_VIRTUAL, don't include special virtual
folders (such as vTrash or vJunk).

The returned #CamelFolderInfo tree should be freed with
camel_folder_info_free().

The CAMEL_STORE_FOLDER_INFO_FAST flag should be considered
deprecated; most backends will behave the same whether it is
supplied or not.  The only guaranteed way to get updated folder
counts is to both open the folder and invoke refresh_info() it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #CamelFolderInfo tree, or %NULL on error</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="top"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the name of the folder to start from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">various CAMEL_STORE_FOLDER_INFO_* flags to control behavior</doc>
            <type name="StoreGetFolderInfoFlags"
                  c:type="CamelStoreGetFolderInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_folder_sync"
                      invoker="get_folder_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Gets a specific folder object from @store by name.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the requested #CamelFolder object, or
%NULL on error</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">folder flags (create, save body index, etc)</doc>
            <type name="StoreGetFolderFlags"
                  c:type="CamelStoreGetFolderFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_inbox_folder_sync"
                      invoker="get_inbox_folder_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Gets the folder in @store into which new mail is delivered.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the inbox folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_junk_folder_sync"
                      invoker="get_junk_folder_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Gets the folder in @store into which junk is delivered.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the junk folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_trash_folder_sync"
                      invoker="get_trash_folder_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Gets the folder in @store into which trash is delivered.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the trash folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="initial_setup_sync"
                      invoker="initial_setup_sync"
                      version="3.20"
                      throws="1">
        <doc xml:space="preserve">Runs initial setup for the @store. It's meant to preset some
values the first time the account connects to the server after
it had been created. The function should return %TRUE even if
it didn't populate anything. The default implementation does
just that.

The save_setup result, if not %NULL, should be freed using
g_hash_table_destroy(). It's not an error to have it %NULL,
it only means the @store doesn't have anything to save.
Both the key and the value in the hash are newly allocated
UTF-8 strings, owned by the hash table.

The @store advertises support of this function by including
CAMEL_STORE_SUPPORTS_INITIAL_SETUP in CamelStore::flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="out_save_setup"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:space="preserve">setup values to save</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rename_folder_sync"
                      invoker="rename_folder_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Renames the folder described by @old_name to @new_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the current name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:space="preserve">the new name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="synchronize_sync"
                      invoker="synchronize_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Synchronizes any changes that have been made to @store and its folders
with the real store.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="expunge" transfer-ownership="none">
            <doc xml:space="preserve">whether to expunge after synchronizing</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="can_refresh_folder"
              c:identifier="camel_store_can_refresh_folder"
              version="2.22"
              throws="1">
        <doc xml:space="preserve">Returns if this folder (param info) should be checked for new mail or not.
It should not look into sub infos (info-&gt;child) or next infos, it should
return value only for the actual folder info.
Default behavior is that all Inbox folders are intended to be refreshed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether folder should be checked for new mails</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderInfo</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_folder"
              c:identifier="camel_store_create_folder"
              version="3.0">
        <doc xml:space="preserve">Asynchronously creates a new folder as a child of an existing folder.
@parent_name can be %NULL to create a new top-level folder.

When the operation is finished, @callback will be called.  You can then
call camel_store_create_folder_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="parent_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">name of the new folder's parent, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to create</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_folder_finish"
              c:identifier="camel_store_create_folder_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_create_folder().
The returned #CamelFolderInfo struct should be freed with
camel_folder_info_free().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">info about the created folder, or %NULL on error</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_folder_sync"
              c:identifier="camel_store_create_folder_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Creates a new folder as a child of an existing folder.
@parent_name can be %NULL to create a new top-level folder.
The returned #CamelFolderInfo struct should be freed with
camel_folder_info_free().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">info about the created folder, or %NULL on error</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="parent_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">name of the new folder's parent, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to create</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_cached_folder"
              c:identifier="camel_store_delete_cached_folder"
              version="3.24">
        <doc xml:space="preserve">Deletes local data for the given @folder_name. The folder should
be part of the opened folders.

It doesn't delete the folder in the store (server) as such.
Use camel_store_delete_folder(), or its synchronous variant,
if you want to do that instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">a folder full name to delete from the cache</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_folder"
              c:identifier="camel_store_delete_folder"
              version="3.0">
        <doc xml:space="preserve">Asynchronously deletes the folder described by @folder_name.  The
folder must be empty.

When the operation is finished, @callback will be called.  You can then
call camel_store_delete_folder_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_folder_finish"
              c:identifier="camel_store_delete_folder_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_delete_folder().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_folder_sync"
              c:identifier="camel_store_delete_folder_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Deletes the folder described by @folder_name.  The folder must be empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_opened_folders"
              c:identifier="camel_store_dup_opened_folders"
              version="3.24">
        <doc xml:space="preserve">Returns a #GPtrArray of all the opened folders for the @store. The caller owns
both the array and the folder references, so to free the array use:

|[
    g_ptr_array_foreach (array, (GFunc) g_object_unref, NULL);
    g_ptr_array_free (array, TRUE);
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array with all currently
  opened folders for the @store.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Folder"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="folder_created"
              c:identifier="camel_store_folder_created"
              version="2.32">
        <doc xml:space="preserve">Emits the #CamelStore::folder-created signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the created folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="folder_deleted"
              c:identifier="camel_store_folder_deleted"
              version="2.32">
        <doc xml:space="preserve">Emits the #CamelStore::folder-deleted signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the deleted folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="folder_info_stale"
              c:identifier="camel_store_folder_info_stale"
              version="3.10">
        <doc xml:space="preserve">Emits the #CamelStore::folder-info-stale signal from an idle source
on the main loop.  The idle source's priority is #G_PRIORITY_LOW.

See the #CamelStore::folder-info-stale documentation for details on
when to use this signal.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="folder_opened"
              c:identifier="camel_store_folder_opened"
              version="3.0">
        <doc xml:space="preserve">Emits the #CamelStore::folder-opened signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelFolder that was opened</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="folder_renamed"
              c:identifier="camel_store_folder_renamed"
              version="2.32">
        <doc xml:space="preserve">Emits the #CamelStore::folder-renamed signal from an idle source on
the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the old name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the renamed folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_db" c:identifier="camel_store_get_db" version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #CamelDB instance associated with this @store.</doc>
          <type name="DB" c:type="CamelDB*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="camel_store_get_flags"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">bit-or of #CamelStoreFlags set for the @store</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder"
              c:identifier="camel_store_get_folder"
              version="3.0">
        <doc xml:space="preserve">Asynchronously gets a specific folder object from @store by name.

When the operation is finished, @callback will be called.  You can then
call camel_store_get_folder_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">folder flags (create, save body index, etc)</doc>
            <type name="StoreGetFolderFlags"
                  c:type="CamelStoreGetFolderFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folder_finish"
              c:identifier="camel_store_get_folder_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_get_folder().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the requested #CamelFolder object, or
%NULL on error</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folder_info"
              c:identifier="camel_store_get_folder_info"
              version="3.0">
        <doc xml:space="preserve">Asynchronously fetches information about the folder structure of @store,
starting with @top.  For details of the behavior, see
camel_store_get_folder_info_sync().

When the operation is finished, @callback will be called.  You can
then call camel_store_get_folder_info_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="top"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the name of the folder to start from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">various CAMEL_STORE_FOLDER_INFO_* flags to control behavior</doc>
            <type name="StoreGetFolderInfoFlags"
                  c:type="CamelStoreGetFolderInfoFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folder_info_finish"
              c:identifier="camel_store_get_folder_info_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_get_folder_info().
The returned #CamelFolderInfo tree should be freed with
camel_folder_info_free().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #CamelFolderInfo tree, or %NULL on error</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folder_info_sync"
              c:identifier="camel_store_get_folder_info_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">This fetches information about the folder structure of @store,
starting with @top, and returns a tree of #CamelFolderInfo
structures. If @flags includes %CAMEL_STORE_FOLDER_INFO_SUBSCRIBED,
only subscribed folders will be listed.   If the store doesn't support
subscriptions, then it will list all folders.  If @flags includes
%CAMEL_STORE_FOLDER_INFO_RECURSIVE, the returned tree will include
all levels of hierarchy below @top. If not, it will only include
the immediate subfolders of @top. If @flags includes
%CAMEL_STORE_FOLDER_INFO_FAST, the unread_message_count fields of
some or all of the structures may be set to %-1, if the store cannot
determine that information quickly.  If @flags includes
%CAMEL_STORE_FOLDER_INFO_NO_VIRTUAL, don't include special virtual
folders (such as vTrash or vJunk).

The returned #CamelFolderInfo tree should be freed with
camel_folder_info_free().

The CAMEL_STORE_FOLDER_INFO_FAST flag should be considered
deprecated; most backends will behave the same whether it is
supplied or not.  The only guaranteed way to get updated folder
counts is to both open the folder and invoke refresh_info() it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #CamelFolderInfo tree, or %NULL on error</doc>
          <type name="FolderInfo" c:type="CamelFolderInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="top"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the name of the folder to start from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">various CAMEL_STORE_FOLDER_INFO_* flags to control behavior</doc>
            <type name="StoreGetFolderInfoFlags"
                  c:type="CamelStoreGetFolderInfoFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folder_sync"
              c:identifier="camel_store_get_folder_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Gets a specific folder object from @store by name.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the requested #CamelFolder object, or
%NULL on error</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the folder to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">folder flags (create, save body index, etc)</doc>
            <type name="StoreGetFolderFlags"
                  c:type="CamelStoreGetFolderFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_folders_bag"
              c:identifier="camel_store_get_folders_bag"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelObjectBag of opened #CamelFolder&lt;!-- --&gt;s</doc>
          <type name="ObjectBag" c:type="CamelObjectBag*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_inbox_folder"
              c:identifier="camel_store_get_inbox_folder"
              version="3.0">
        <doc xml:space="preserve">Asynchronously gets the folder in @store into which new mail is delivered.

When the operation is finished, @callback will be called.  You can
then call camel_store_get_inbox_folder_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_inbox_folder_finish"
              c:identifier="camel_store_get_inbox_folder_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_get_inbox_folder().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the inbox folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_inbox_folder_sync"
              c:identifier="camel_store_get_inbox_folder_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Gets the folder in @store into which new mail is delivered.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the inbox folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_junk_folder"
              c:identifier="camel_store_get_junk_folder"
              version="3.0">
        <doc xml:space="preserve">Asynchronously gets the folder in @store into which junk is delivered.

When the operation is finished, @callback will be called.  You can
then call camel_store_get_junk_folder_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_junk_folder_finish"
              c:identifier="camel_store_get_junk_folder_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_get_junk_folder().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the junk folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_junk_folder_sync"
              c:identifier="camel_store_get_junk_folder_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Gets the folder in @store into which junk is delivered.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the junk folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_permissions"
              c:identifier="camel_store_get_permissions"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Permissions of the @store, a bit-or of #CamelStorePermissionFlags</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_trash_folder"
              c:identifier="camel_store_get_trash_folder"
              version="3.0">
        <doc xml:space="preserve">Asynchronously gets the folder in @store into which trash is delivered.

When the operation is finished, @callback will be called.  You can
then call camel_store_get_trash_folder_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_trash_folder_finish"
              c:identifier="camel_store_get_trash_folder_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_get_trash_folder().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the trash folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_trash_folder_sync"
              c:identifier="camel_store_get_trash_folder_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Gets the folder in @store into which trash is delivered.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the trash folder for @store, or %NULL on
error or if no such folder exists</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="initial_setup"
              c:identifier="camel_store_initial_setup"
              version="3.20">
        <doc xml:space="preserve">Runs initial setup for the @store asynchronously.

When the operation is finished, @callback will be called. You can then
call camel_store_initial_setup_finish() to get the result of the operation.

The @store advertises support of this function by including
CAMEL_STORE_SUPPORTS_INITIAL_SETUP in CamelStore::flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="initial_setup_finish"
              c:identifier="camel_store_initial_setup_finish"
              version="3.20"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_initial_setup().

The save_setup result, if not %NULL, should be freed using
g_hash_table_destroy(). It's not an error to have it %NULL,
it only means the @store doesn't have anything to save.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="out_save_setup"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:space="preserve">setup values to save</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="initial_setup_sync"
              c:identifier="camel_store_initial_setup_sync"
              version="3.20"
              throws="1">
        <doc xml:space="preserve">Runs initial setup for the @store. It's meant to preset some
values the first time the account connects to the server after
it had been created. The function should return %TRUE even if
it didn't populate anything. The default implementation does
just that.

The save_setup result, if not %NULL, should be freed using
g_hash_table_destroy(). It's not an error to have it %NULL,
it only means the @store doesn't have anything to save.
Both the key and the value in the hash are newly allocated
UTF-8 strings, owned by the hash table.

The @store advertises support of this function by including
CAMEL_STORE_SUPPORTS_INITIAL_SETUP in CamelStore::flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="out_save_setup"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:space="preserve">setup values to save</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="maybe_run_db_maintenance"
              c:identifier="camel_store_maybe_run_db_maintenance"
              version="3.16"
              throws="1">
        <doc xml:space="preserve">Checks the state of the current CamelDB used for the @store and eventually
runs maintenance routines on it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore instance</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rename_folder"
              c:identifier="camel_store_rename_folder"
              version="3.0">
        <doc xml:space="preserve">Asynchronously renames the folder described by @old_name to @new_name.

When the operation is finished, @callback will be called.  You can then
call camel_store_rename_folder_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the current name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:space="preserve">the new name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_folder_finish"
              c:identifier="camel_store_rename_folder_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_rename_folder().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_folder_sync"
              c:identifier="camel_store_rename_folder_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Renames the folder described by @old_name to @new_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:space="preserve">the current name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:space="preserve">the new name of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flags"
              c:identifier="camel_store_set_flags"
              version="3.24">
        <doc xml:space="preserve">Sets flags for the @store, a bit-or of #CamelStoreFlags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">bit-or of #CamelStoreFlags</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_permissions"
              c:identifier="camel_store_set_permissions"
              version="3.24">
        <doc xml:space="preserve">Sets permissions for the @store, a bit-or of #CamelStorePermissionFlags</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="permissions" transfer-ownership="none">
            <doc xml:space="preserve">permissions of the @store, a bit-or of #CamelStorePermissionFlags</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize"
              c:identifier="camel_store_synchronize"
              version="3.0">
        <doc xml:space="preserve">Synchronizes any changes that have been made to @store and its folders
with the real store asynchronously.

When the operation is finished, @callback will be called.  You can then
call camel_store_synchronize_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="expunge" transfer-ownership="none">
            <doc xml:space="preserve">whether to expunge after synchronizing</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_finish"
              c:identifier="camel_store_synchronize_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_store_synchronize().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="synchronize_sync"
              c:identifier="camel_store_synchronize_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Synchronizes any changes that have been made to @store and its folders
with the real store.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="store" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </instance-parameter>
          <parameter name="expunge" transfer-ownership="none">
            <doc xml:space="preserve">whether to expunge after synchronizing</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Service" c:type="CamelService"/>
      </field>
      <field name="priv">
        <type name="StorePrivate" c:type="CamelStorePrivate*"/>
      </field>
      <glib:signal name="folder-created" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="FolderInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="folder-deleted" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="FolderInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="folder-info-stale" when="first">
        <doc xml:space="preserve">This signal indicates significant changes have occurred to
the folder hierarchy of @store, and that previously fetched
#CamelFolderInfo data should be considered stale.

Applications should handle this signal by replacing cached
#CamelFolderInfo data for @store with fresh data by way of
camel_store_get_folder_info().

More often than not this signal will be emitted as a result of
user preference changes rather than actual server-side changes.
For example, a user may change a preference that reveals a set
of folders previously hidden from view, or that alters whether
to augment the @store with virtual Junk and Trash folders.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="folder-opened" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Folder"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="folder-renamed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="FolderInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StoreClass"
            c:type="CamelStoreClass"
            glib:is-gtype-struct-for="Store">
      <field name="parent_class">
        <type name="ServiceClass" c:type="CamelServiceClass"/>
      </field>
      <field name="hash_folder_name">
        <type name="GLib.HashFunc" c:type="GHashFunc"/>
      </field>
      <field name="equal_folder_name">
        <type name="GLib.EqualFunc" c:type="GEqualFunc"/>
      </field>
      <field name="can_refresh_folder">
        <callback name="can_refresh_folder" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether folder should be checked for new mails</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelFolderInfo</doc>
              <type name="FolderInfo" c:type="CamelFolderInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_folder_sync">
        <callback name="get_folder_sync" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the requested #CamelFolder object, or
%NULL on error</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="folder_name" transfer-ownership="none">
              <doc xml:space="preserve">name of the folder to get</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">folder flags (create, save body index, etc)</doc>
              <type name="StoreGetFolderFlags"
                    c:type="CamelStoreGetFolderFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_folder_info_sync">
        <callback name="get_folder_info_sync" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">a #CamelFolderInfo tree, or %NULL on error</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="top"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">the name of the folder to start from</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">various CAMEL_STORE_FOLDER_INFO_* flags to control behavior</doc>
              <type name="StoreGetFolderInfoFlags"
                    c:type="CamelStoreGetFolderInfoFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_inbox_folder_sync">
        <callback name="get_inbox_folder_sync" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the inbox folder for @store, or %NULL on
error or if no such folder exists</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_junk_folder_sync">
        <callback name="get_junk_folder_sync" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the junk folder for @store, or %NULL on
error or if no such folder exists</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_trash_folder_sync">
        <callback name="get_trash_folder_sync" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">the trash folder for @store, or %NULL on
error or if no such folder exists</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_folder_sync">
        <callback name="create_folder_sync" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">info about the created folder, or %NULL on error</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="parent_name"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">name of the new folder's parent, or %NULL</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="folder_name" transfer-ownership="none">
              <doc xml:space="preserve">name of the folder to create</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_folder_sync">
        <callback name="delete_folder_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="folder_name" transfer-ownership="none">
              <doc xml:space="preserve">name of the folder to delete</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rename_folder_sync">
        <callback name="rename_folder_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="old_name" transfer-ownership="none">
              <doc xml:space="preserve">the current name of the folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="new_name" transfer-ownership="none">
              <doc xml:space="preserve">the new name of the folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="synchronize_sync">
        <callback name="synchronize_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="expunge" transfer-ownership="none">
              <doc xml:space="preserve">whether to expunge after synchronizing</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="initial_setup_sync">
        <callback name="initial_setup_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="out_save_setup"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="container">
              <doc xml:space="preserve">setup values to save</doc>
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="utf8"/>
                <type name="utf8"/>
              </type>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_methods">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="folder_created">
        <callback name="folder_created">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="folder_info" transfer-ownership="none">
              <doc xml:space="preserve">information about the created folder</doc>
              <type name="FolderInfo" c:type="CamelFolderInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="folder_deleted">
        <callback name="folder_deleted">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="folder_info" transfer-ownership="none">
              <doc xml:space="preserve">information about the deleted folder</doc>
              <type name="FolderInfo" c:type="CamelFolderInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="folder_opened">
        <callback name="folder_opened">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="folder" transfer-ownership="none">
              <doc xml:space="preserve">the #CamelFolder that was opened</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="folder_renamed">
        <callback name="folder_renamed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
            <parameter name="old_name" transfer-ownership="none">
              <doc xml:space="preserve">the old name of the folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="folder_info" transfer-ownership="none">
              <doc xml:space="preserve">information about the renamed folder</doc>
              <type name="FolderInfo" c:type="CamelFolderInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="folder_info_stale">
        <callback name="folder_info_stale">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="store" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStore</doc>
              <type name="Store" c:type="CamelStore*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_signals">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="StoreError" version="2.32" c:type="CamelStoreError">
      <member name="invalid"
              value="0"
              c:identifier="CAMEL_STORE_ERROR_INVALID">
        <doc xml:space="preserve">an invalid store operation had been requested</doc>
      </member>
      <member name="no_folder"
              value="1"
              c:identifier="CAMEL_STORE_ERROR_NO_FOLDER">
        <doc xml:space="preserve">requested operation cannot be performed with the given folder</doc>
      </member>
    </enumeration>
    <bitfield name="StoreFlags"
              glib:type-name="CamelStoreFlags"
              glib:get-type="camel_store_flags_get_type"
              c:type="CamelStoreFlags">
      <member name="vtrash"
              value="1"
              c:identifier="CAMEL_STORE_VTRASH"
              glib:nick="vtrash">
      </member>
      <member name="vjunk"
              value="2"
              c:identifier="CAMEL_STORE_VJUNK"
              glib:nick="vjunk">
      </member>
      <member name="proxy"
              value="4"
              c:identifier="CAMEL_STORE_PROXY"
              glib:nick="proxy">
      </member>
      <member name="is_migrating"
              value="8"
              c:identifier="CAMEL_STORE_IS_MIGRATING"
              glib:nick="is-migrating">
      </member>
      <member name="real_junk_folder"
              value="16"
              c:identifier="CAMEL_STORE_REAL_JUNK_FOLDER"
              glib:nick="real-junk-folder">
      </member>
      <member name="can_edit_folders"
              value="32"
              c:identifier="CAMEL_STORE_CAN_EDIT_FOLDERS"
              glib:nick="can-edit-folders">
      </member>
      <member name="use_cache_dir"
              value="64"
              c:identifier="CAMEL_STORE_USE_CACHE_DIR"
              glib:nick="use-cache-dir">
      </member>
      <member name="can_delete_folders_at_once"
              value="128"
              c:identifier="CAMEL_STORE_CAN_DELETE_FOLDERS_AT_ONCE"
              glib:nick="can-delete-folders-at-once">
      </member>
      <member name="supports_initial_setup"
              value="256"
              c:identifier="CAMEL_STORE_SUPPORTS_INITIAL_SETUP"
              glib:nick="supports-initial-setup">
      </member>
    </bitfield>
    <bitfield name="StoreGetFolderFlags" c:type="CamelStoreGetFolderFlags">
      <member name="create" value="1" c:identifier="CAMEL_STORE_FOLDER_CREATE">
      </member>
      <member name="excl" value="2" c:identifier="CAMEL_STORE_FOLDER_EXCL">
      </member>
      <member name="body_index"
              value="4"
              c:identifier="CAMEL_STORE_FOLDER_BODY_INDEX">
      </member>
      <member name="private"
              value="8"
              c:identifier="CAMEL_STORE_FOLDER_PRIVATE">
      </member>
    </bitfield>
    <bitfield name="StoreGetFolderInfoFlags"
              glib:type-name="CamelStoreGetFolderInfoFlags"
              glib:get-type="camel_store_get_folder_info_flags_get_type"
              c:type="CamelStoreGetFolderInfoFlags">
      <member name="fast"
              value="1"
              c:identifier="CAMEL_STORE_FOLDER_INFO_FAST"
              glib:nick="fast">
      </member>
      <member name="recursive"
              value="2"
              c:identifier="CAMEL_STORE_FOLDER_INFO_RECURSIVE"
              glib:nick="recursive">
      </member>
      <member name="subscribed"
              value="4"
              c:identifier="CAMEL_STORE_FOLDER_INFO_SUBSCRIBED"
              glib:nick="subscribed">
      </member>
      <member name="no_virtual"
              value="8"
              c:identifier="CAMEL_STORE_FOLDER_INFO_NO_VIRTUAL"
              glib:nick="no-virtual">
        <doc xml:space="preserve">Do not include virtual trash or junk folders.</doc>
      </member>
      <member name="subscription_list"
              value="16"
              c:identifier="CAMEL_STORE_FOLDER_INFO_SUBSCRIPTION_LIST"
              glib:nick="subscription-list">
        <doc xml:space="preserve">Fetch only the subscription list. Clients should use this
  flag for requesting the list of folders available for
  subscription. Used in Exchange / IMAP connectors for public
  folder fetching.</doc>
      </member>
      <member name="refresh"
              value="32"
              c:identifier="CAMEL_STORE_FOLDER_INFO_REFRESH"
              glib:nick="refresh">
        <doc xml:space="preserve">Treat this call as a request to refresh the folder summary;
  for remote accounts it can be to re-fetch fresh folder
  content from the server and update the local cache.</doc>
      </member>
    </bitfield>
    <record name="StoreInfo" c:type="CamelStoreInfo">
      <field name="refcount" writable="1">
        <type name="gint" c:type="volatile gint"/>
      </field>
      <field name="path" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="unread" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="total" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <function name="name" c:identifier="camel_store_info_name">
        <doc xml:space="preserve">Returns the last segment of the path string from @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the last segment of the path string from @info</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreInfo</doc>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </function>
      <function name="path" c:identifier="camel_store_info_path">
        <doc xml:space="preserve">Returns the path string from @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the path string from @info</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreInfo</doc>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_string" c:identifier="camel_store_info_set_string">
        <doc xml:space="preserve">Set a specific string on the @info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreInfo</doc>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">specific string being set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">string value to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="StoreInfoFlags"
              glib:type-name="CamelStoreInfoFlags"
              glib:get-type="camel_store_info_flags_get_type"
              c:type="CamelStoreInfoFlags">
      <member name="noselect"
              value="1"
              c:identifier="CAMEL_STORE_INFO_FOLDER_NOSELECT"
              glib:nick="noselect">
      </member>
      <member name="noinferiors"
              value="2"
              c:identifier="CAMEL_STORE_INFO_FOLDER_NOINFERIORS"
              glib:nick="noinferiors">
      </member>
      <member name="children"
              value="4"
              c:identifier="CAMEL_STORE_INFO_FOLDER_CHILDREN"
              glib:nick="children">
      </member>
      <member name="nochildren"
              value="8"
              c:identifier="CAMEL_STORE_INFO_FOLDER_NOCHILDREN"
              glib:nick="nochildren">
      </member>
      <member name="subscribed"
              value="16"
              c:identifier="CAMEL_STORE_INFO_FOLDER_SUBSCRIBED"
              glib:nick="subscribed">
      </member>
      <member name="virtual"
              value="32"
              c:identifier="CAMEL_STORE_INFO_FOLDER_VIRTUAL"
              glib:nick="virtual">
      </member>
      <member name="system"
              value="64"
              c:identifier="CAMEL_STORE_INFO_FOLDER_SYSTEM"
              glib:nick="system">
      </member>
      <member name="vtrash"
              value="128"
              c:identifier="CAMEL_STORE_INFO_FOLDER_VTRASH"
              glib:nick="vtrash">
      </member>
      <member name="shared_to_me"
              value="256"
              c:identifier="CAMEL_STORE_INFO_FOLDER_SHARED_TO_ME"
              glib:nick="shared-to-me">
      </member>
      <member name="shared_by_me"
              value="512"
              c:identifier="CAMEL_STORE_INFO_FOLDER_SHARED_BY_ME"
              glib:nick="shared-by-me">
      </member>
      <member name="type_normal"
              value="0"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_NORMAL"
              glib:nick="type-normal">
      </member>
      <member name="type_inbox"
              value="1024"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_INBOX"
              glib:nick="type-inbox">
      </member>
      <member name="type_outbox"
              value="2048"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_OUTBOX"
              glib:nick="type-outbox">
      </member>
      <member name="type_trash"
              value="3072"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_TRASH"
              glib:nick="type-trash">
      </member>
      <member name="type_junk"
              value="4096"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_JUNK"
              glib:nick="type-junk">
      </member>
      <member name="type_sent"
              value="5120"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_SENT"
              glib:nick="type-sent">
      </member>
      <member name="type_contacts"
              value="6144"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_CONTACTS"
              glib:nick="type-contacts">
      </member>
      <member name="type_events"
              value="7168"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_EVENTS"
              glib:nick="type-events">
      </member>
      <member name="type_memos"
              value="8192"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_MEMOS"
              glib:nick="type-memos">
      </member>
      <member name="type_tasks"
              value="9216"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_TASKS"
              glib:nick="type-tasks">
      </member>
      <member name="type_all"
              value="10240"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_ALL"
              glib:nick="type-all">
      </member>
      <member name="type_archive"
              value="11264"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_ARCHIVE"
              glib:nick="type-archive">
      </member>
      <member name="type_drafts"
              value="12288"
              c:identifier="CAMEL_STORE_INFO_FOLDER_TYPE_DRAFTS"
              glib:nick="type-drafts">
      </member>
      <member name="readonly"
              value="65536"
              c:identifier="CAMEL_STORE_INFO_FOLDER_READONLY"
              glib:nick="readonly">
      </member>
      <member name="writeonly"
              value="131072"
              c:identifier="CAMEL_STORE_INFO_FOLDER_WRITEONLY"
              glib:nick="writeonly">
      </member>
      <member name="flagged"
              value="262144"
              c:identifier="CAMEL_STORE_INFO_FOLDER_FLAGGED"
              glib:nick="flagged">
      </member>
    </bitfield>
    <bitfield name="StorePermissionFlags"
              glib:type-name="CamelStorePermissionFlags"
              glib:get-type="camel_store_permission_flags_get_type"
              c:type="CamelStorePermissionFlags">
      <member name="read"
              value="1"
              c:identifier="CAMEL_STORE_READ"
              glib:nick="read">
      </member>
      <member name="write"
              value="2"
              c:identifier="CAMEL_STORE_WRITE"
              glib:nick="write">
      </member>
    </bitfield>
    <record name="StorePrivate" c:type="CamelStorePrivate" disguised="1">
    </record>
    <class name="StoreSettings"
           c:symbol-prefix="store_settings"
           c:type="CamelStoreSettings"
           version="3.2"
           parent="Settings"
           glib:type-name="CamelStoreSettings"
           glib:get-type="camel_store_settings_get_type"
           glib:type-struct="StoreSettingsClass">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <method name="get_filter_inbox"
              c:identifier="camel_store_settings_get_filter_inbox"
              version="3.2">
        <doc xml:space="preserve">Returns whether to automatically apply filters to newly arrived messages
in the store's Inbox folder (assuming it has an Inbox folder).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether to filter new messages in Inbox</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSettings</doc>
            <type name="StoreSettings" c:type="CamelStoreSettings*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_filter_inbox"
              c:identifier="camel_store_settings_set_filter_inbox"
              version="3.2">
        <doc xml:space="preserve">Sets whether to automatically apply filters to newly arrived messages
in the store's Inbox folder (assuming it has an Inbox folder).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="settings" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSettings</doc>
            <type name="StoreSettings" c:type="CamelStoreSettings*"/>
          </instance-parameter>
          <parameter name="filter_inbox" transfer-ownership="none">
            <doc xml:space="preserve">whether to filter new messages in Inbox</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="filter-inbox"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Settings" c:type="CamelSettings"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="StoreSettingsPrivate" c:type="CamelStoreSettingsPrivate*"/>
      </field>
    </class>
    <record name="StoreSettingsClass"
            c:type="CamelStoreSettingsClass"
            glib:is-gtype-struct-for="StoreSettings">
      <field name="parent_class">
        <type name="SettingsClass" c:type="CamelSettingsClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StoreSettingsPrivate"
            c:type="CamelStoreSettingsPrivate"
            disguised="1">
    </record>
    <class name="StoreSummary"
           c:symbol-prefix="store_summary"
           c:type="CamelStoreSummary"
           parent="GObject.Object"
           glib:type-name="CamelStoreSummary"
           glib:get-type="camel_store_summary_get_type"
           glib:type-struct="StoreSummaryClass">
      <constructor name="new" c:identifier="camel_store_summary_new">
        <doc xml:space="preserve">Create a new #CamelStoreSummary object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelStoreSummary object</doc>
          <type name="StoreSummary" c:type="CamelStoreSummary*"/>
        </return-value>
      </constructor>
      <virtual-method name="store_info_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="store_info_load" introspectable="0">
        <return-value>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="file"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="store_info_new" introspectable="0">
        <return-value>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="store_info_save">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="file"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="store_info_set_string">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="summary_header_load">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="file"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="summary_header_save">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="file"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="FILE*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add" c:identifier="camel_store_summary_add">
        <doc xml:space="preserve">Adds a new @info record to the summary.  If @info-&gt;uid is %NULL,
then a new uid is automatically re-assigned by calling
camel_store_summary_next_uid_string().

The @info record should have been generated by calling one of the
info_new_*() functions, as it will be free'd based on the summary
class.  And MUST NOT be allocated directly using malloc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreInfo</doc>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_from_path"
              c:identifier="camel_store_summary_add_from_path"
              introspectable="0">
        <doc xml:space="preserve">Build a new info record based on the name, and add it to the summary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the newly added record</doc>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">item path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="array" c:identifier="camel_store_summary_array">
        <doc xml:space="preserve">Obtain a copy of the summary array.  This is done atomically,
so cannot contain empty entries.

It must be freed using camel_store_summary_array_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the summary array</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="StoreInfo"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="array_free" c:identifier="camel_store_summary_array_free">
        <doc xml:space="preserve">Free the folder summary array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">the summary array as gotten from camel_store_summary_array()</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="StoreInfo"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="connect_folder_summary"
              c:identifier="camel_store_summary_connect_folder_summary"
              version="3.4">
        <doc xml:space="preserve">Connects listeners for count changes on @folder_summary to keep
CamelStoreInfo.total and CamelStoreInfo.unread in sync transparently.
The @folder_summary is stored in @summary as @path. Use
camel_store_summary_disconnect_folder_summary() to disconnect from
listening.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether successfully connect callbacks for count change
notifications.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">used path for @folder_summary</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="folder_summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </parameter>
        </parameters>
      </method>
      <method name="count" c:identifier="camel_store_summary_count">
        <doc xml:space="preserve">Get the number of summary items stored in this summary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items gint he summary.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="disconnect_folder_summary"
              c:identifier="camel_store_summary_disconnect_folder_summary"
              version="3.4">
        <doc xml:space="preserve">Diconnects count change listeners previously connected
by camel_store_summary_connect_folder_summary().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether such connection existed and whether was successfully
removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="folder_summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolderSummary object</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </parameter>
        </parameters>
      </method>
      <method name="info_new"
              c:identifier="camel_store_summary_info_new"
              introspectable="0">
        <doc xml:space="preserve">Allocate a new #CamelStoreInfo, suitable for adding to this
summary.</doc>
        <return-value>
          <doc xml:space="preserve">the newly allocated #CamelStoreInfo</doc>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="info_ref"
              c:identifier="camel_store_summary_info_ref"
              introspectable="0">
        <doc xml:space="preserve">Add an extra reference to @info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the @info argument</doc>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreInfo</doc>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="info_unref" c:identifier="camel_store_summary_info_unref">
        <doc xml:space="preserve">Unref and potentially free @info, and all associated memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreInfo</doc>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load" c:identifier="camel_store_summary_load">
        <doc xml:space="preserve">Load the summary off disk.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on success or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="path"
              c:identifier="camel_store_summary_path"
              introspectable="0">
        <doc xml:space="preserve">Retrieve a summary item by path name.

The returned #CamelStoreInfo is referenced for thread-safety and should be
unreferenced with camel_store_summary_info_unref() when finished with it.</doc>
        <return-value>
          <doc xml:space="preserve">the summary item, or %NULL if the @path name is not
available</doc>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">path to the item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="camel_store_summary_remove">
        <doc xml:space="preserve">Remove a specific @info record from the summary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreInfo</doc>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_path"
              c:identifier="camel_store_summary_remove_path">
        <doc xml:space="preserve">Remove a specific info record from the summary, by @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">item path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="camel_store_summary_save">
        <doc xml:space="preserve">Writes the summary to disk.  The summary is only written if changes
have occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on succes or %-1 on fail</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_filename"
              c:identifier="camel_store_summary_set_filename">
        <doc xml:space="preserve">Set the filename where the summary will be loaded to/saved from.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">a filename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sort"
              c:identifier="camel_store_summary_sort"
              version="3.24">
        <doc xml:space="preserve">Sorts the array of the folders using the @compare_func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
          <parameter name="compare_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a compare function</doc>
            <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to the @compare_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="touch" c:identifier="camel_store_summary_touch">
        <doc xml:space="preserve">Mark the summary as changed, so that a save will force it to be
written back to disk.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStoreSummary object</doc>
            <type name="StoreSummary" c:type="CamelStoreSummary*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="StoreSummaryPrivate" c:type="CamelStoreSummaryPrivate*"/>
      </field>
    </class>
    <record name="StoreSummaryClass"
            c:type="CamelStoreSummaryClass"
            glib:is-gtype-struct-for="StoreSummary">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="store_info_size">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="summary_header_load">
        <callback name="summary_header_load">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="StoreSummary" c:type="CamelStoreSummary*"/>
            </parameter>
            <parameter name="file"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="summary_header_save">
        <callback name="summary_header_save">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="StoreSummary" c:type="CamelStoreSummary*"/>
            </parameter>
            <parameter name="file"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="store_info_new" introspectable="0">
        <callback name="store_info_new" introspectable="0">
          <return-value>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="StoreSummary" c:type="CamelStoreSummary*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="store_info_load" introspectable="0">
        <callback name="store_info_load" introspectable="0">
          <return-value>
            <type name="StoreInfo" c:type="CamelStoreInfo*"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="StoreSummary" c:type="CamelStoreSummary*"/>
            </parameter>
            <parameter name="file"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="store_info_save">
        <callback name="store_info_save">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="StoreSummary" c:type="CamelStoreSummary*"/>
            </parameter>
            <parameter name="file"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="FILE*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="StoreInfo" c:type="CamelStoreInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="store_info_free">
        <callback name="store_info_free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="StoreSummary" c:type="CamelStoreSummary*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="StoreInfo" c:type="CamelStoreInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="store_info_set_string">
        <callback name="store_info_set_string">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="summary" transfer-ownership="none">
              <type name="StoreSummary" c:type="CamelStoreSummary*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="StoreInfo" c:type="CamelStoreInfo*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StoreSummaryPrivate"
            c:type="CamelStoreSummaryPrivate"
            disguised="1">
    </record>
    <class name="Stream"
           c:symbol-prefix="stream"
           c:type="CamelStream"
           parent="GObject.Object"
           glib:type-name="CamelStream"
           glib:get-type="camel_stream_get_type"
           glib:type-struct="StreamClass">
      <implements name="Gio.Seekable"/>
      <constructor name="new" c:identifier="camel_stream_new" version="3.12">
        <doc xml:space="preserve">Creates a #CamelStream as a thin wrapper for @base_stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelStream</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="close" invoker="close" throws="1">
        <doc xml:space="preserve">Closes the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on success or %-1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="eos" invoker="eos">
        <doc xml:space="preserve">Tests if there are bytes left to read on the @stream object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on EOS or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush" invoker="flush" throws="1">
        <doc xml:space="preserve">Flushes any buffered data to the stream's backing store.  Only
meaningful for writable streams.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on success or %-1 on fail along with setting @error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read" invoker="read" throws="1">
        <doc xml:space="preserve">Attempts to read up to @n bytes from @stream into @buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes actually read, or %-1 on error and set
errno.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object.</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">output buffer</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">max number of bytes to read.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write" invoker="write" throws="1">
        <doc xml:space="preserve">Attempts to write up to @n bytes of @buffer into @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written to the stream, or %-1 on error
along with setting errno.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">buffer to write.</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="camel_stream_close" throws="1">
        <doc xml:space="preserve">Closes the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on success or %-1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="eos" c:identifier="camel_stream_eos">
        <doc xml:space="preserve">Tests if there are bytes left to read on the @stream object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on EOS or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="camel_stream_flush" throws="1">
        <doc xml:space="preserve">Flushes any buffered data to the stream's backing store.  Only
meaningful for writable streams.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%0 on success or %-1 on fail along with setting @error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="camel_stream_read" throws="1">
        <doc xml:space="preserve">Attempts to read up to @n bytes from @stream into @buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes actually read, or %-1 on error and set
errno.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object.</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">output buffer</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">max number of bytes to read.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_base_stream"
              c:identifier="camel_stream_ref_base_stream"
              version="3.12">
        <doc xml:space="preserve">Returns the #GIOStream for @stream.  This is only valid if @stream was
created with camel_stream_new().  For all other #CamelStream subclasses
this function returns %NULL.

The returned #GIOStream is referenced for thread-safety and should be
unreferenced with g_object_unref() when finished with it.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GIOStream, or %NULL</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_base_stream"
              c:identifier="camel_stream_set_base_stream"
              version="3.12">
        <doc xml:space="preserve">Replaces the #GIOStream passed to camel_stream_new() with @base_stream.
The new @base_stream should wrap the original #GIOStream, such as when
adding Transport Layer Security after issuing a STARTTLS command.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="base_stream" transfer-ownership="none">
            <doc xml:space="preserve">a #GIOStream</doc>
            <type name="Gio.IOStream" c:type="GIOStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write" c:identifier="camel_stream_write" throws="1">
        <doc xml:space="preserve">Attempts to write up to @n bytes of @buffer into @stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written to the stream, or %-1 on error
along with setting errno.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">buffer to write.</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number of bytes to write</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_string"
              c:identifier="camel_stream_write_string"
              throws="1">
        <doc xml:space="preserve">Writes the string to the stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of characters written or %-1 on error.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_to_stream"
              c:identifier="camel_stream_write_to_stream"
              throws="1">
        <doc xml:space="preserve">Write all of a stream (until eos) into another stream, in a
blocking fashion.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%-1 on error, or the number of bytes succesfully
copied across streams.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">source #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </instance-parameter>
          <parameter name="output_stream" transfer-ownership="none">
            <doc xml:space="preserve">destination #CamelStream object</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="base-stream" writable="1" transfer-ownership="none">
        <type name="Gio.IOStream"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="StreamPrivate" c:type="CamelStreamPrivate*"/>
      </field>
    </class>
    <class name="StreamBuffer"
           c:symbol-prefix="stream_buffer"
           c:type="CamelStreamBuffer"
           parent="Stream"
           glib:type-name="CamelStreamBuffer"
           glib:get-type="camel_stream_buffer_get_type"
           glib:type-struct="StreamBufferClass">
      <implements name="Gio.Seekable"/>
      <constructor name="new" c:identifier="camel_stream_buffer_new">
        <doc xml:space="preserve">Create a new buffered stream of another stream.  A default
buffer size (1024 bytes), automatically managed will be used
for buffering.

The following values are available for @mode:

#CAMEL_STREAM_BUFFER_BUFFER, Buffer the input/output in blocks.
#CAMEL_STREAM_BUFFER_NEWLINE, Buffer on newlines (for output).
#CAMEL_STREAM_BUFFER_NONE, Perform no buffering.

Note that currently this is ignored and #CAMEL_STREAM_BUFFER_BUFFER
is always used.

In addition, one of the following mode options should be or'd
together with the buffering mode:

#CAMEL_STREAM_BUFFER_WRITE, Buffer in write mode.
#CAMEL_STREAM_BUFFER_READ, Buffer in read mode.

Buffering can only be done in one direction for any
buffer instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created buffered stream.</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream object to buffer</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">Operational mode of buffered stream.</doc>
            <type name="StreamBufferMode" c:type="CamelStreamBufferMode"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="init">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream_buffer" transfer-ownership="none">
            <type name="StreamBuffer" c:type="CamelStreamBuffer*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <type name="StreamBufferMode" c:type="CamelStreamBufferMode"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="init_vbuf">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream_buffer" transfer-ownership="none">
            <type name="StreamBuffer" c:type="CamelStreamBuffer*"/>
          </instance-parameter>
          <parameter name="stream" transfer-ownership="none">
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <type name="StreamBufferMode" c:type="CamelStreamBufferMode"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="gets" c:identifier="camel_stream_buffer_gets" throws="1">
        <doc xml:space="preserve">Read a line of characters up to the next newline character or
@max-1 characters.

If the newline character is encountered, then it will be
included in the buffer @buf.  The buffer will be %NULL terminated.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of characters read, or %0 for end of file,
and %-1 on error.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamBuffer object</doc>
            <type name="StreamBuffer" c:type="CamelStreamBuffer*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">Memory to write the string to.</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve">Maxmimum number of characters to store.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_line"
              c:identifier="camel_stream_buffer_read_line"
              throws="1">
        <doc xml:space="preserve">This function reads a complete newline-terminated line from the stream
and returns it in allocated memory. The trailing newline (and carriage
return if any) are not included in the returned string.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">the line read, which the caller must free when done with,
or %NULL on eof. If an error occurs, @error will be set.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sbf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamBuffer object</doc>
            <type name="StreamBuffer" c:type="CamelStreamBuffer*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Stream" c:type="CamelStream"/>
      </field>
      <field name="priv">
        <type name="StreamBufferPrivate" c:type="CamelStreamBufferPrivate*"/>
      </field>
    </class>
    <record name="StreamBufferClass"
            c:type="CamelStreamBufferClass"
            glib:is-gtype-struct-for="StreamBuffer">
      <field name="parent_class">
        <type name="StreamClass" c:type="CamelStreamClass"/>
      </field>
      <field name="init">
        <callback name="init">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream_buffer" transfer-ownership="none">
              <type name="StreamBuffer" c:type="CamelStreamBuffer*"/>
            </parameter>
            <parameter name="stream" transfer-ownership="none">
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="mode" transfer-ownership="none">
              <type name="StreamBufferMode" c:type="CamelStreamBufferMode"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="init_vbuf">
        <callback name="init_vbuf">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream_buffer" transfer-ownership="none">
              <type name="StreamBuffer" c:type="CamelStreamBuffer*"/>
            </parameter>
            <parameter name="stream" transfer-ownership="none">
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="mode" transfer-ownership="none">
              <type name="StreamBufferMode" c:type="CamelStreamBufferMode"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint32" c:type="guint32"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="StreamBufferMode" c:type="CamelStreamBufferMode">
      <member name="buffer"
              value="0"
              c:identifier="CAMEL_STREAM_BUFFER_BUFFER">
      </member>
      <member name="none" value="1" c:identifier="CAMEL_STREAM_BUFFER_NONE">
      </member>
      <member name="read" value="0" c:identifier="CAMEL_STREAM_BUFFER_READ">
      </member>
      <member name="write"
              value="128"
              c:identifier="CAMEL_STREAM_BUFFER_WRITE">
      </member>
      <member name="mode" value="128" c:identifier="CAMEL_STREAM_BUFFER_MODE">
      </member>
    </enumeration>
    <record name="StreamBufferPrivate"
            c:type="CamelStreamBufferPrivate"
            disguised="1">
    </record>
    <record name="StreamClass"
            c:type="CamelStreamClass"
            glib:is-gtype-struct-for="Stream">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="read">
        <callback name="read" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes actually read, or %-1 on error and set
errno.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStream object.</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">output buffer</doc>
              <array length="2" zero-terminated="0" c:type="gchar*">
                <type name="gchar" c:type="gchar"/>
              </array>
            </parameter>
            <parameter name="n" transfer-ownership="none">
              <doc xml:space="preserve">max number of bytes to read.</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes written to the stream, or %-1 on error
along with setting errno.</doc>
            <type name="gssize" c:type="gssize"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStream object</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <doc xml:space="preserve">buffer to write.</doc>
              <array length="2" zero-terminated="0" c:type="gchar*">
                <type name="gchar" c:type="gchar"/>
              </array>
            </parameter>
            <parameter name="n" transfer-ownership="none">
              <doc xml:space="preserve">number of bytes to write</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%0 on success or %-1 on error.</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStream object</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%0 on success or %-1 on fail along with setting @error</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStream object</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="eos">
        <callback name="eos">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on EOS or %FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelStream object</doc>
              <type name="Stream" c:type="CamelStream*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="StreamFilter"
           c:symbol-prefix="stream_filter"
           c:type="CamelStreamFilter"
           parent="Stream"
           glib:type-name="CamelStreamFilter"
           glib:get-type="camel_stream_filter_get_type"
           glib:type-struct="StreamFilterClass">
      <implements name="Gio.Seekable"/>
      <constructor name="new"
                   c:identifier="camel_stream_filter_new"
                   version="2.32">
        <doc xml:space="preserve">Create a new #CamelStreamFilter object. The @source stream
is referenced, thus the caller can unref it, if not needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelStreamFilter object.</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream to filter</doc>
            <type name="Stream" c:type="CamelStream*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="camel_stream_filter_add">
        <doc xml:space="preserve">Add a new #CamelMimeFilter to execute during the processing of this
stream.  Each filter added is processed after the previous one.

Note that a filter should only be added to a single stream
at a time, otherwise unpredictable results may occur.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a filter id for the added @filter.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamFilter object</doc>
            <type name="StreamFilter" c:type="CamelStreamFilter*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeFilter object</doc>
            <type name="MimeFilter" c:type="CamelMimeFilter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_source"
              c:identifier="camel_stream_filter_get_source"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamFilter</doc>
            <type name="StreamFilter" c:type="CamelStreamFilter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="camel_stream_filter_remove">
        <doc xml:space="preserve">Remove a processing filter from the stream by id.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamFilter object</doc>
            <type name="StreamFilter" c:type="CamelStreamFilter*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">Filter id, as returned from camel_stream_filter_add()</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Stream" c:type="CamelStream"/>
      </field>
      <field name="priv">
        <type name="StreamFilterPrivate" c:type="CamelStreamFilterPrivate*"/>
      </field>
    </class>
    <record name="StreamFilterClass"
            c:type="CamelStreamFilterClass"
            glib:is-gtype-struct-for="StreamFilter">
      <field name="parent_class">
        <type name="StreamClass" c:type="CamelStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StreamFilterPrivate"
            c:type="CamelStreamFilterPrivate"
            disguised="1">
    </record>
    <class name="StreamFs"
           c:symbol-prefix="stream_fs"
           c:type="CamelStreamFs"
           parent="Stream"
           glib:type-name="CamelStreamFs"
           glib:get-type="camel_stream_fs_get_type"
           glib:type-struct="StreamFsClass">
      <implements name="Gio.Seekable"/>
      <constructor name="new_with_fd"
                   c:identifier="camel_stream_fs_new_with_fd">
        <doc xml:space="preserve">Creates a new fs stream using the given file descriptor @fd as the
backing store. When the stream is destroyed, the file descriptor
will be closed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelStreamFs</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:space="preserve">a file descriptor</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_name"
                   c:identifier="camel_stream_fs_new_with_name"
                   throws="1">
        <doc xml:space="preserve">Creates a new #CamelStreamFs corresponding to the named file, flags,
and mode.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new stream, or %NULL on error.</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a local filename</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags as in open(2)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">a file mode</doc>
            <type name="guint32" c:type="mode_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_fd"
              c:identifier="camel_stream_fs_get_fd"
              version="2.32">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStream</doc>
            <type name="StreamFs" c:type="CamelStreamFs*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Stream" c:type="CamelStream"/>
      </field>
      <field name="priv">
        <type name="StreamFsPrivate" c:type="CamelStreamFsPrivate*"/>
      </field>
    </class>
    <record name="StreamFsClass"
            c:type="CamelStreamFsClass"
            glib:is-gtype-struct-for="StreamFs">
      <field name="parent_class">
        <type name="StreamClass" c:type="CamelStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StreamFsPrivate" c:type="CamelStreamFsPrivate" disguised="1">
    </record>
    <class name="StreamMem"
           c:symbol-prefix="stream_mem"
           c:type="CamelStreamMem"
           parent="Stream"
           glib:type-name="CamelStreamMem"
           glib:get-type="camel_stream_mem_get_type"
           glib:type-struct="StreamMemClass">
      <implements name="Gio.Seekable"/>
      <constructor name="new" c:identifier="camel_stream_mem_new">
        <doc xml:space="preserve">Create a new #CamelStreamMem object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelStreamMem</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_buffer"
                   c:identifier="camel_stream_mem_new_with_buffer">
        <doc xml:space="preserve">Create a new memory stream using @buffer as the stream data.

Note: @buffer will be copied into an internal #GByteArray structure
for use as the stream backing. This may have resource implications
you may wish to consider.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelStreamMem</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a memory buffer to use as the stream data</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of @buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_byte_array"
                   c:identifier="camel_stream_mem_new_with_byte_array">
        <doc xml:space="preserve">Create a new #CamelStreamMem using @buffer as the stream data.

Note: The newly created #CamelStreamMem will destroy @buffer
when destroyed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelStreamMem</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GByteArray to use as the stream data</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_byte_array"
              c:identifier="camel_stream_mem_get_byte_array"
              version="2.32">
        <return-value transfer-ownership="none">
          <array name="GLib.ByteArray" c:type="GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamMem</doc>
            <type name="StreamMem" c:type="CamelStreamMem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_buffer" c:identifier="camel_stream_mem_set_buffer">
        <doc xml:space="preserve">Set @buffer to be the backing data to the existing #CamelStreamMem, @mem.

Note: @buffer will be copied into an internal #GByteArray structure
and so may have resource implications to consider.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamMem object</doc>
            <type name="StreamMem" c:type="CamelStreamMem*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a memory buffer</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="utf8" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">length of @buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_array"
              c:identifier="camel_stream_mem_set_byte_array">
        <doc xml:space="preserve">Set @buffer to be the backing data to the existing #CamelStreamMem, @mem.

Note: @mem will not take ownership of @buffer and so will need to
be freed separately from @mem.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamMem object</doc>
            <type name="StreamMem" c:type="CamelStreamMem*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GByteArray</doc>
            <array name="GLib.ByteArray" c:type="GByteArray*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_secure" c:identifier="camel_stream_mem_set_secure">
        <doc xml:space="preserve">Mark the memory stream as secure.  At the very least this means the
data in the buffer will be cleared when the buffer is finalized.
This only applies to buffers owned by the stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mem" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamMem object</doc>
            <type name="StreamMem" c:type="CamelStreamMem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Stream" c:type="CamelStream"/>
      </field>
      <field name="priv">
        <type name="StreamMemPrivate" c:type="CamelStreamMemPrivate*"/>
      </field>
    </class>
    <record name="StreamMemClass"
            c:type="CamelStreamMemClass"
            glib:is-gtype-struct-for="StreamMem">
      <field name="parent_class">
        <type name="StreamClass" c:type="CamelStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StreamMemPrivate"
            c:type="CamelStreamMemPrivate"
            disguised="1">
    </record>
    <class name="StreamNull"
           c:symbol-prefix="stream_null"
           c:type="CamelStreamNull"
           parent="Stream"
           glib:type-name="CamelStreamNull"
           glib:get-type="camel_stream_null_get_type"
           glib:type-struct="StreamNullClass">
      <implements name="Gio.Seekable"/>
      <constructor name="new" c:identifier="camel_stream_null_new">
        <doc xml:space="preserve">Returns a null stream.  A null stream is always at eof, and
always returns success for all reads and writes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelStreamNull</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
      </constructor>
      <method name="get_bytes_written"
              c:identifier="camel_stream_null_get_bytes_written"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">how many bytes had been written to the @stream_null since
  it was created or rewind to the beginning.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream_null" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelStreamNull</doc>
            <type name="StreamNull" c:type="CamelStreamNull*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Stream" c:type="CamelStream"/>
      </field>
      <field name="priv">
        <type name="StreamNullPrivate" c:type="CamelStreamNullPrivate*"/>
      </field>
    </class>
    <record name="StreamNullClass"
            c:type="CamelStreamNullClass"
            glib:is-gtype-struct-for="StreamNull">
      <field name="parent_class">
        <type name="StreamClass" c:type="CamelStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StreamNullPrivate"
            c:type="CamelStreamNullPrivate"
            disguised="1">
    </record>
    <record name="StreamPrivate" c:type="CamelStreamPrivate" disguised="1">
    </record>
    <class name="StreamProcess"
           c:symbol-prefix="stream_process"
           c:type="CamelStreamProcess"
           parent="Stream"
           glib:type-name="CamelStreamProcess"
           glib:get-type="camel_stream_process_get_type"
           glib:type-struct="StreamProcessClass">
      <implements name="Gio.Seekable"/>
      <constructor name="new" c:identifier="camel_stream_process_new">
        <doc xml:space="preserve">Returns a PROCESS stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the stream</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </return-value>
      </constructor>
      <method name="connect"
              c:identifier="camel_stream_process_connect"
              throws="1">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <type name="StreamProcess" c:type="CamelStreamProcess*"/>
          </instance-parameter>
          <parameter name="command" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="env" transfer-ownership="none">
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Stream" c:type="CamelStream"/>
      </field>
      <field name="priv">
        <type name="StreamProcessPrivate" c:type="CamelStreamProcessPrivate*"/>
      </field>
    </class>
    <record name="StreamProcessClass"
            c:type="CamelStreamProcessClass"
            glib:is-gtype-struct-for="StreamProcess">
      <field name="parent_class">
        <type name="StreamClass" c:type="CamelStreamClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StreamProcessPrivate"
            c:type="CamelStreamProcessPrivate"
            disguised="1">
    </record>
    <interface name="Subscribable"
               c:symbol-prefix="subscribable"
               c:type="CamelSubscribable"
               version="3.2"
               glib:type-name="CamelSubscribable"
               glib:get-type="camel_subscribable_get_type"
               glib:type-struct="SubscribableInterface">
      <prerequisite name="Store"/>
      <virtual-method name="folder_is_subscribed"
                      invoker="folder_is_subscribed"
                      version="3.2">
        <doc xml:space="preserve">Find out if a folder has been subscribed to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the folder has been subscribed to or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_subscribed"
                      invoker="folder_subscribed"
                      version="3.2">
        <doc xml:space="preserve">Emits the #CamelSubscribable::folder-subscribed signal from an idle source
on the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the subscribed folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_unsubscribed"
                      invoker="folder_unsubscribed"
                      version="3.2">
        <doc xml:space="preserve">Emits the #CamelSubscribable::folder-unsubscribed signal from an idle source
on the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the unsubscribed folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="subscribe_folder_sync"
                      invoker="subscribe_folder_sync"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Subscribes to the folder described by @folder_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unsubscribe_folder_sync"
                      invoker="unsubscribe_folder_sync"
                      version="3.2"
                      throws="1">
        <doc xml:space="preserve">Unsubscribes from the folder described by @folder_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="folder_is_subscribed"
              c:identifier="camel_subscribable_folder_is_subscribed"
              version="3.2">
        <doc xml:space="preserve">Find out if a folder has been subscribed to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the folder has been subscribed to or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="folder_subscribed"
              c:identifier="camel_subscribable_folder_subscribed"
              version="3.2">
        <doc xml:space="preserve">Emits the #CamelSubscribable::folder-subscribed signal from an idle source
on the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the subscribed folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="folder_unsubscribed"
              c:identifier="camel_subscribable_folder_unsubscribed"
              version="3.2">
        <doc xml:space="preserve">Emits the #CamelSubscribable::folder-unsubscribed signal from an idle source
on the main loop.  The idle source's priority is #G_PRIORITY_HIGH_IDLE.

This function is only intended for Camel providers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_info" transfer-ownership="none">
            <doc xml:space="preserve">information about the unsubscribed folder</doc>
            <type name="FolderInfo" c:type="CamelFolderInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subscribe_folder"
              c:identifier="camel_subscribable_subscribe_folder"
              version="3.2">
        <doc xml:space="preserve">Asynchronously subscribes to the folder described by @folder_name.

When the operation is finished, @callback will be called.  You can then
call camel_subscribable_subscribe_folder_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="subscribe_folder_finish"
              c:identifier="camel_subscribable_subscribe_folder_finish"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_subscribable_subscribe_folder().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subscribe_folder_sync"
              c:identifier="camel_subscribable_subscribe_folder_sync"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Subscribes to the folder described by @folder_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_folder"
              c:identifier="camel_subscribable_unsubscribe_folder"
              version="3.2">
        <doc xml:space="preserve">Asynchronously unsubscribes from the folder described by @folder_name.

When the operation is finished, @callback will be called.  You can then
call camel_subscribable_unsubscribe_folder_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_folder_finish"
              c:identifier="camel_subscribable_unsubscribe_folder_finish"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_subscribable_unsubscribe_folder().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_folder_sync"
              c:identifier="camel_subscribable_unsubscribe_folder_sync"
              version="3.2"
              throws="1">
        <doc xml:space="preserve">Unsubscribes from the folder described by @folder_name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="subscribable" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelSubscribable</doc>
            <type name="Subscribable" c:type="CamelSubscribable*"/>
          </instance-parameter>
          <parameter name="folder_name" transfer-ownership="none">
            <doc xml:space="preserve">full path of the folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="folder-subscribed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="FolderInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="folder-unsubscribed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="FolderInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="SubscribableInterface"
            c:type="CamelSubscribableInterface"
            glib:is-gtype-struct-for="Subscribable">
      <field name="parent_interface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="folder_is_subscribed">
        <callback name="folder_is_subscribed">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the folder has been subscribed to or %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="subscribable" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSubscribable</doc>
              <type name="Subscribable" c:type="CamelSubscribable*"/>
            </parameter>
            <parameter name="folder_name" transfer-ownership="none">
              <doc xml:space="preserve">full path of the folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="subscribe_folder_sync">
        <callback name="subscribe_folder_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="subscribable" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSubscribable</doc>
              <type name="Subscribable" c:type="CamelSubscribable*"/>
            </parameter>
            <parameter name="folder_name" transfer-ownership="none">
              <doc xml:space="preserve">full path of the folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unsubscribe_folder_sync">
        <callback name="unsubscribe_folder_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="subscribable" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSubscribable</doc>
              <type name="Subscribable" c:type="CamelSubscribable*"/>
            </parameter>
            <parameter name="folder_name" transfer-ownership="none">
              <doc xml:space="preserve">full path of the folder</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_methods">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="folder_subscribed">
        <callback name="folder_subscribed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="subscribable" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSubscribable</doc>
              <type name="Subscribable" c:type="CamelSubscribable*"/>
            </parameter>
            <parameter name="folder_info" transfer-ownership="none">
              <doc xml:space="preserve">information about the subscribed folder</doc>
              <type name="FolderInfo" c:type="CamelFolderInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="folder_unsubscribed">
        <callback name="folder_unsubscribed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="subscribable" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelSubscribable</doc>
              <type name="Subscribable" c:type="CamelSubscribable*"/>
            </parameter>
            <parameter name="folder_info" transfer-ownership="none">
              <doc xml:space="preserve">information about the unsubscribed folder</doc>
              <type name="FolderInfo" c:type="CamelFolderInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved_signals">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SummaryMessageID" c:type="CamelSummaryMessageID">
      <union name="id" c:type="id">
        <field name="id" writable="1">
          <type name="guint64" c:type="guint64"/>
        </field>
        <field name="hash" writable="1">
          <array zero-terminated="0" c:type="guchar" fixed-size="8">
            <type name="guint8" c:type="guchar"/>
          </array>
        </field>
        <record name="part" c:type="part">
          <field name="hi" writable="1">
            <type name="guint32" c:type="guint32"/>
          </field>
          <field name="lo" writable="1">
            <type name="guint32" c:type="guint32"/>
          </field>
        </record>
      </union>
    </record>
    <class name="TextIndex"
           c:symbol-prefix="text_index"
           c:type="CamelTextIndex"
           parent="Index"
           glib:type-name="CamelTextIndex"
           glib:get-type="camel_text_index_get_type"
           glib:type-struct="TextIndexClass">
      <constructor name="new" c:identifier="camel_text_index_new">
        <return-value transfer-ownership="full">
          <type name="TextIndex" c:type="CamelTextIndex*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="check" c:identifier="camel_text_index_check">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove" c:identifier="camel_text_index_remove">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="old" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="rename" c:identifier="camel_text_index_rename">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="old" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="dump" c:identifier="camel_text_index_dump">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="idx" transfer-ownership="none">
            <type name="TextIndex" c:type="CamelTextIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="info" c:identifier="camel_text_index_info">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="idx" transfer-ownership="none">
            <type name="TextIndex" c:type="CamelTextIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="validate" c:identifier="camel_text_index_validate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="idx" transfer-ownership="none">
            <type name="TextIndex" c:type="CamelTextIndex*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Index" c:type="CamelIndex"/>
      </field>
      <field name="priv">
        <type name="TextIndexPrivate" c:type="CamelTextIndexPrivate*"/>
      </field>
    </class>
    <record name="TextIndexClass"
            c:type="CamelTextIndexClass"
            glib:is-gtype-struct-for="TextIndex">
      <field name="parent_class">
        <type name="IndexClass" c:type="CamelIndexClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="TextIndexCursor"
           c:symbol-prefix="text_index_cursor"
           c:type="CamelTextIndexCursor"
           parent="IndexCursor"
           glib:type-name="CamelTextIndexCursor"
           glib:get-type="camel_text_index_cursor_get_type"
           glib:type-struct="TextIndexCursorClass">
      <field name="parent">
        <type name="IndexCursor" c:type="CamelIndexCursor"/>
      </field>
      <field name="priv">
        <type name="TextIndexCursorPrivate"
              c:type="CamelTextIndexCursorPrivate*"/>
      </field>
    </class>
    <record name="TextIndexCursorClass"
            c:type="CamelTextIndexCursorClass"
            glib:is-gtype-struct-for="TextIndexCursor">
      <field name="parent_class">
        <type name="IndexCursorClass" c:type="CamelIndexCursorClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TextIndexCursorPrivate"
            c:type="CamelTextIndexCursorPrivate"
            disguised="1">
    </record>
    <callback name="TextIndexFunc" c:type="CamelTextIndexFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="idx" transfer-ownership="none">
          <type name="TextIndex" c:type="CamelTextIndex*"/>
        </parameter>
        <parameter name="word" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="TextIndexKeyCursor"
           c:symbol-prefix="text_index_key_cursor"
           c:type="CamelTextIndexKeyCursor"
           parent="IndexCursor"
           glib:type-name="CamelTextIndexKeyCursor"
           glib:get-type="camel_text_index_key_cursor_get_type"
           glib:type-struct="TextIndexKeyCursorClass">
      <field name="parent">
        <type name="IndexCursor" c:type="CamelIndexCursor"/>
      </field>
      <field name="priv">
        <type name="TextIndexKeyCursorPrivate"
              c:type="CamelTextIndexKeyCursorPrivate*"/>
      </field>
    </class>
    <record name="TextIndexKeyCursorClass"
            c:type="CamelTextIndexKeyCursorClass"
            glib:is-gtype-struct-for="TextIndexKeyCursor">
      <field name="parent_class">
        <type name="IndexCursorClass" c:type="CamelIndexCursorClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TextIndexKeyCursorPrivate"
            c:type="CamelTextIndexKeyCursorPrivate"
            disguised="1">
    </record>
    <class name="TextIndexName"
           c:symbol-prefix="text_index_name"
           c:type="CamelTextIndexName"
           parent="IndexName"
           glib:type-name="CamelTextIndexName"
           glib:get-type="camel_text_index_name_get_type"
           glib:type-struct="TextIndexNameClass">
      <field name="parent">
        <type name="IndexName" c:type="CamelIndexName"/>
      </field>
      <field name="priv">
        <type name="TextIndexNamePrivate" c:type="CamelTextIndexNamePrivate*"/>
      </field>
    </class>
    <record name="TextIndexNameClass"
            c:type="CamelTextIndexNameClass"
            glib:is-gtype-struct-for="TextIndexName">
      <field name="parent_class">
        <type name="IndexNameClass" c:type="CamelIndexNameClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TextIndexNamePrivate"
            c:type="CamelTextIndexNamePrivate"
            disguised="1">
    </record>
    <record name="TextIndexPrivate"
            c:type="CamelTextIndexPrivate"
            disguised="1">
    </record>
    <enumeration name="ThreeState"
                 version="3.22"
                 glib:type-name="CamelThreeState"
                 glib:get-type="camel_three_state_get_type"
                 c:type="CamelThreeState">
      <doc xml:space="preserve">Describes a three-state value, which can be either Off, On or Inconsistent.</doc>
      <member name="off"
              value="0"
              c:identifier="CAMEL_THREE_STATE_OFF"
              glib:nick="off">
        <doc xml:space="preserve">the three-state value is Off</doc>
      </member>
      <member name="on"
              value="1"
              c:identifier="CAMEL_THREE_STATE_ON"
              glib:nick="on">
        <doc xml:space="preserve">the three-state value is On</doc>
      </member>
      <member name="inconsistent"
              value="2"
              c:identifier="CAMEL_THREE_STATE_INCONSISTENT"
              glib:nick="inconsistent">
        <doc xml:space="preserve">the three-state value is neither On, nor Off</doc>
      </member>
    </enumeration>
    <enumeration name="TimeUnit"
                 version="3.24"
                 glib:type-name="CamelTimeUnit"
                 glib:get-type="camel_time_unit_get_type"
                 c:type="CamelTimeUnit">
      <doc xml:space="preserve">Declares time unit, which serves to interpret the time value,
like in #CamelOfflineSettings.</doc>
      <member name="days"
              value="1"
              c:identifier="CAMEL_TIME_UNIT_DAYS"
              glib:nick="days">
        <doc xml:space="preserve">days</doc>
      </member>
      <member name="weeks"
              value="2"
              c:identifier="CAMEL_TIME_UNIT_WEEKS"
              glib:nick="weeks">
        <doc xml:space="preserve">weeks</doc>
      </member>
      <member name="months"
              value="3"
              c:identifier="CAMEL_TIME_UNIT_MONTHS"
              glib:nick="months">
        <doc xml:space="preserve">months</doc>
      </member>
      <member name="years"
              value="4"
              c:identifier="CAMEL_TIME_UNIT_YEARS"
              glib:nick="years">
        <doc xml:space="preserve">years</doc>
      </member>
    </enumeration>
    <enumeration name="TransferEncoding"
                 glib:type-name="CamelTransferEncoding"
                 glib:get-type="camel_transfer_encoding_get_type"
                 c:type="CamelTransferEncoding">
      <member name="encoding_default"
              value="0"
              c:identifier="CAMEL_TRANSFER_ENCODING_DEFAULT"
              glib:nick="encoding-default">
      </member>
      <member name="encoding_7bit"
              value="1"
              c:identifier="CAMEL_TRANSFER_ENCODING_7BIT"
              glib:nick="encoding-7bit">
      </member>
      <member name="encoding_8bit"
              value="2"
              c:identifier="CAMEL_TRANSFER_ENCODING_8BIT"
              glib:nick="encoding-8bit">
      </member>
      <member name="encoding_base64"
              value="3"
              c:identifier="CAMEL_TRANSFER_ENCODING_BASE64"
              glib:nick="encoding-base64">
      </member>
      <member name="encoding_quotedprintable"
              value="4"
              c:identifier="CAMEL_TRANSFER_ENCODING_QUOTEDPRINTABLE"
              glib:nick="encoding-quotedprintable">
      </member>
      <member name="encoding_binary"
              value="5"
              c:identifier="CAMEL_TRANSFER_ENCODING_BINARY"
              glib:nick="encoding-binary">
      </member>
      <member name="encoding_uuencode"
              value="6"
              c:identifier="CAMEL_TRANSFER_ENCODING_UUENCODE"
              glib:nick="encoding-uuencode">
      </member>
      <member name="num_encodings"
              value="7"
              c:identifier="CAMEL_TRANSFER_NUM_ENCODINGS"
              glib:nick="num-encodings">
      </member>
      <function name="from_string"
                c:identifier="camel_transfer_encoding_from_string">
        <return-value transfer-ownership="none">
          <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string"
                c:identifier="camel_transfer_encoding_to_string">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="encoding" transfer-ownership="none">
            <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <class name="Transport"
           c:symbol-prefix="transport"
           c:type="CamelTransport"
           parent="Service"
           abstract="1"
           glib:type-name="CamelTransport"
           glib:get-type="camel_transport_get_type"
           glib:type-struct="TransportClass">
      <implements name="Gio.Initable"/>
      <virtual-method name="send_to_sync"
                      invoker="send_to_sync"
                      version="3.0"
                      throws="1">
        <doc xml:space="preserve">Sends the message to the given recipients, regardless of the contents
of @message.  If the message contains a "Bcc" header, the transport
is responsible for stripping it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="transport" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelTransport</doc>
            <type name="Transport" c:type="CamelTransport*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage to send</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress to send from</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
          <parameter name="recipients" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress containing all recipients</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
          <parameter name="out_sent_message_saved"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">set to %TRUE, if the sent message was also saved</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="send_to"
              c:identifier="camel_transport_send_to"
              version="3.0">
        <doc xml:space="preserve">Sends the message asynchronously to the given recipients, regardless of
the contents of @message.  If the message contains a "Bcc" header, the
transport is responsible for stripping it.

When the operation is finished, @callback will be called.  You can then
call camel_transport_send_to_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="transport" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelTransport</doc>
            <type name="Transport" c:type="CamelTransport*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage to send</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress to send from</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
          <parameter name="recipients" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress containing all recipients</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the I/O priority of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_to_finish"
              c:identifier="camel_transport_send_to_finish"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Finishes the operation started with camel_transport_send_to().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="transport" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelTransport</doc>
            <type name="Transport" c:type="CamelTransport*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="out_sent_message_saved"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">set to %TRUE, if the sent message was also saved</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_to_sync"
              c:identifier="camel_transport_send_to_sync"
              version="3.0"
              throws="1">
        <doc xml:space="preserve">Sends the message to the given recipients, regardless of the contents
of @message.  If the message contains a "Bcc" header, the transport
is responsible for stripping it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success or %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="transport" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelTransport</doc>
            <type name="Transport" c:type="CamelTransport*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelMimeMessage to send</doc>
            <type name="MimeMessage" c:type="CamelMimeMessage*"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress to send from</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
          <parameter name="recipients" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelAddress containing all recipients</doc>
            <type name="Address" c:type="CamelAddress*"/>
          </parameter>
          <parameter name="out_sent_message_saved"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">set to %TRUE, if the sent message was also saved</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Service" c:type="CamelService"/>
      </field>
      <field name="priv">
        <type name="TransportPrivate" c:type="CamelTransportPrivate*"/>
      </field>
    </class>
    <record name="TransportClass"
            c:type="CamelTransportClass"
            glib:is-gtype-struct-for="Transport">
      <field name="parent_class">
        <type name="ServiceClass" c:type="CamelServiceClass"/>
      </field>
      <field name="send_to_sync">
        <callback name="send_to_sync" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success or %FALSE on error</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="transport" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelTransport</doc>
              <type name="Transport" c:type="CamelTransport*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelMimeMessage to send</doc>
              <type name="MimeMessage" c:type="CamelMimeMessage*"/>
            </parameter>
            <parameter name="from" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress to send from</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
            <parameter name="recipients" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelAddress containing all recipients</doc>
              <type name="Address" c:type="CamelAddress*"/>
            </parameter>
            <parameter name="out_sent_message_saved"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">set to %TRUE, if the sent message was also saved</doc>
              <type name="gboolean" c:type="gboolean*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TransportPrivate"
            c:type="CamelTransportPrivate"
            disguised="1">
    </record>
    <record name="Trie" c:type="CamelTrie" disguised="1" version="2.24">
      <doc xml:space="preserve">A trie data structure.</doc>
      <method name="add"
              c:identifier="camel_trie_add"
              version="2.24"
              introspectable="0">
        <doc xml:space="preserve">Add a new pattern to the #CamelTrie @trie.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trie" transfer-ownership="none">
            <doc xml:space="preserve">The #CamelTrie to add a pattern to.</doc>
            <type name="Trie" c:type="CamelTrie*"/>
          </instance-parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">The pattern to add.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pattern_id" transfer-ownership="none">
            <doc xml:space="preserve">The id to use for the pattern.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="camel_trie_free"
              version="2.24"
              introspectable="0">
        <doc xml:space="preserve">Frees the memory associated with the #CamelTrie @trie.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trie" transfer-ownership="none">
            <doc xml:space="preserve">The #CamelTrie to free.</doc>
            <type name="Trie" c:type="CamelTrie*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="search"
              c:identifier="camel_trie_search"
              version="2.24"
              introspectable="0">
        <doc xml:space="preserve">Try to match the string @buffer with a pattern in @trie.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The matched pattern, or %NULL if no pattern is matched.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trie" transfer-ownership="none">
            <doc xml:space="preserve">The #CamelTrie to search in.</doc>
            <type name="Trie" c:type="CamelTrie*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The string to match against a pattern in @trie.</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="buflen" transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="matched_id"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">An integer address to store the matched pattern id in.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="camel_trie_new"
                version="2.24"
                introspectable="0">
        <doc xml:space="preserve">Creates a new #CamelTrie. If @icase is %TRUE, then pattern matching
done by the CamelTrie will be case insensitive.</doc>
        <return-value>
          <doc xml:space="preserve">The newly-created #CamelTrie.</doc>
          <type name="Trie" c:type="CamelTrie*"/>
        </return-value>
        <parameters>
          <parameter name="icase" transfer-ownership="none">
            <doc xml:space="preserve">Case sensitivity for the #CamelTrie.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="UIDCache" c:type="CamelUIDCache">
      <field name="filename" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="uids" writable="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="level" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="expired" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="size" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="fd" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="destroy" c:identifier="camel_uid_cache_destroy">
        <doc xml:space="preserve">Destroys @cache and frees its data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a CamelUIDCache</doc>
            <type name="UIDCache" c:type="CamelUIDCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_new_uids" c:identifier="camel_uid_cache_get_new_uids">
        <doc xml:space="preserve">Returns an array of UIDs from @uids that are not in @cache, and
removes UIDs from @cache that aren't in @uids.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an array of new UIDs, which must be freed with
camel_uid_cache_free_uids().</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a CamelUIDCache</doc>
            <type name="UIDCache" c:type="CamelUIDCache*"/>
          </instance-parameter>
          <parameter name="uids" transfer-ownership="none">
            <doc xml:space="preserve">an array of UIDs</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="camel_uid_cache_save">
        <doc xml:space="preserve">Attempts to save @cache back to disk.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">success or failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a CamelUIDCache</doc>
            <type name="UIDCache" c:type="CamelUIDCache*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="save_uid" c:identifier="camel_uid_cache_save_uid">
        <doc xml:space="preserve">Marks a uid for saving.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cache" transfer-ownership="none">
            <doc xml:space="preserve">a CamelUIDCache</doc>
            <type name="UIDCache" c:type="CamelUIDCache*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a uid to save</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <function name="free_uids" c:identifier="camel_uid_cache_free_uids">
        <doc xml:space="preserve">Frees the array of UIDs.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uids" transfer-ownership="full">
            <doc xml:space="preserve">an array returned from camel_uid_cache_get_new_uids()</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="new"
                c:identifier="camel_uid_cache_new"
                introspectable="0">
        <doc xml:space="preserve">Creates a new UID cache, initialized from @filename. If @filename
doesn't already exist, the UID cache will be empty. Otherwise, if
it does exist but can't be read, the function will return %NULL.</doc>
        <return-value>
          <doc xml:space="preserve">a new UID cache, or %NULL</doc>
          <type name="UIDCache" c:type="CamelUIDCache*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">path to load the cache from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <constant name="UNMATCHED_NAME"
              value="UNMATCHED"
              c:type="CAMEL_UNMATCHED_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="URL"
            c:type="CamelURL"
            glib:type-name="CamelURL"
            glib:get-type="camel_url_get_type"
            c:symbol-prefix="url">
      <field name="protocol" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="user" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="authmech" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="host" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="port" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="path" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <type name="GLib.Data" c:type="GData*"/>
      </field>
      <field name="query" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="fragment" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <constructor name="new" c:identifier="camel_url_new" throws="1">
        <doc xml:space="preserve">Parses an absolute URL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CamelURL if it can be parsed, or %NULL otherwise</doc>
          <type name="URL" c:type="CamelURL*"/>
        </return-value>
        <parameters>
          <parameter name="url_string" transfer-ownership="none">
            <doc xml:space="preserve">a URL string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="camel_url_copy">
        <doc xml:space="preserve">Copy a #CamelURL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a duplicate copy of @in</doc>
          <type name="URL" c:type="CamelURL*"/>
        </return-value>
        <parameters>
          <instance-parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL to copy</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="camel_url_equal">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">return %TRUE if the two urls are equal</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="u" transfer-ownership="none">
            <doc xml:space="preserve">the base URL</doc>
            <type name="URL" c:type="const CamelURL*"/>
          </instance-parameter>
          <parameter name="u2" transfer-ownership="none">
            <doc xml:space="preserve">the URL to compare</doc>
            <type name="URL" c:type="const CamelURL*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="camel_url_free">
        <doc xml:space="preserve">Frees @url.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_param" c:identifier="camel_url_get_param">
        <doc xml:space="preserve">Get the value of the specified param on the URL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of a param if found or %NULL otherwise</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the param</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="camel_url_hash">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the url hash</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="u" transfer-ownership="none">
            <doc xml:space="preserve">the base URL</doc>
            <type name="URL" c:type="const CamelURL*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_with_base" c:identifier="camel_url_new_with_base">
        <doc xml:space="preserve">Parses @url_string relative to @base.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a parsed #CamelURL</doc>
          <type name="URL" c:type="CamelURL*"/>
        </return-value>
        <parameters>
          <instance-parameter name="base" transfer-ownership="none">
            <doc xml:space="preserve">a base URL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="url_string" transfer-ownership="none">
            <doc xml:space="preserve">the URL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_authmech" c:identifier="camel_url_set_authmech">
        <doc xml:space="preserve">Set the authmech of a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="authmech" transfer-ownership="none">
            <doc xml:space="preserve">authentication mechanism</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_fragment" c:identifier="camel_url_set_fragment">
        <doc xml:space="preserve">Set the fragment of a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="fragment" transfer-ownership="none">
            <doc xml:space="preserve">url fragment</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_host" c:identifier="camel_url_set_host">
        <doc xml:space="preserve">Set the hostname of a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="host" transfer-ownership="none">
            <doc xml:space="preserve">hostname</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_param" c:identifier="camel_url_set_param">
        <doc xml:space="preserve">Set a param on the #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the param to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value of the param to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path" c:identifier="camel_url_set_path">
        <doc xml:space="preserve">Set the path component of a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">path</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_port" c:identifier="camel_url_set_port">
        <doc xml:space="preserve">Set the port on a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">port</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_protocol" c:identifier="camel_url_set_protocol">
        <doc xml:space="preserve">Set the protocol of a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:space="preserve">protocol schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query" c:identifier="camel_url_set_query">
        <doc xml:space="preserve">Set the query of a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve">url query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user" c:identifier="camel_url_set_user">
        <doc xml:space="preserve">Set the user of a #CamelURL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="user" transfer-ownership="none">
            <doc xml:space="preserve">username</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="camel_url_to_string">
        <doc xml:space="preserve">Flatten a #CamelURL into a string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a string representing @url, which the caller must free</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelURL</doc>
            <type name="URL" c:type="CamelURL*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">additional translation options</doc>
            <type name="URLFlags" c:type="CamelURLFlags"/>
          </parameter>
        </parameters>
      </method>
      <function name="addrspec_end" c:identifier="camel_url_addrspec_end">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="inend" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <type name="UrlMatch" c:type="CamelUrlMatch*"/>
          </parameter>
        </parameters>
      </function>
      <function name="addrspec_start" c:identifier="camel_url_addrspec_start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="inend" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <type name="UrlMatch" c:type="CamelUrlMatch*"/>
          </parameter>
        </parameters>
      </function>
      <function name="decode" c:identifier="camel_url_decode">
        <doc xml:space="preserve">%-decodes the passed-in URL *in place*. The decoded version is
never longer than the encoded version, so there does not need to
be any additional space at the end of the string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a URL part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="decode_path" c:identifier="camel_url_decode_path">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="encode" c:identifier="camel_url_encode">
        <doc xml:space="preserve">This %-encodes the given URL part and returns the escaped version
in allocated memory, which the caller must free when it is done.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a URL part</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="escape_extra" transfer-ownership="none">
            <doc xml:space="preserve">additional characters beyond " \"%#&lt;&gt;{}|\^[]`"
to escape (or %NULL)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="file_end" c:identifier="camel_url_file_end">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="inend" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <type name="UrlMatch" c:type="CamelUrlMatch*"/>
          </parameter>
        </parameters>
      </function>
      <function name="file_start" c:identifier="camel_url_file_start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="inend" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <type name="UrlMatch" c:type="CamelUrlMatch*"/>
          </parameter>
        </parameters>
      </function>
      <function name="web_end" c:identifier="camel_url_web_end">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="inend" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <type name="UrlMatch" c:type="CamelUrlMatch*"/>
          </parameter>
        </parameters>
      </function>
      <function name="web_start" c:identifier="camel_url_web_start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="in" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="inend" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <type name="UrlMatch" c:type="CamelUrlMatch*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="URLFlags" c:type="CamelURLFlags">
      <member name="params" value="1" c:identifier="CAMEL_URL_HIDE_PARAMS">
      </member>
      <member name="auth" value="2" c:identifier="CAMEL_URL_HIDE_AUTH">
      </member>
    </bitfield>
    <constant name="URL_HIDE_ALL" value="0" c:type="CAMEL_URL_HIDE_ALL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_AUTH" value="2" c:type="CAMEL_URL_PART_AUTH">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_HIDDEN" value="8" c:type="CAMEL_URL_PART_HIDDEN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_HOST" value="8" c:type="CAMEL_URL_PART_HOST">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_NEED" value="8" c:type="CAMEL_URL_PART_NEED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_PASSWORD"
              value="4"
              c:type="CAMEL_URL_PART_PASSWORD">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_PATH" value="32" c:type="CAMEL_URL_PART_PATH">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_PATH_DIR"
              value="64"
              c:type="CAMEL_URL_PART_PATH_DIR">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_PORT" value="16" c:type="CAMEL_URL_PART_PORT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="URL_PART_USER" value="1" c:type="CAMEL_URL_PART_USER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="UUDECODE_STATE_MASK"
              value="0"
              c:type="CAMEL_UUDECODE_STATE_MASK">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="UUDecodeState" c:type="CamelUUDecodeState">
      <member name="init" value="0" c:identifier="CAMEL_UUDECODE_STATE_INIT">
      </member>
      <member name="begin"
              value="65536"
              c:identifier="CAMEL_UUDECODE_STATE_BEGIN">
      </member>
      <member name="end"
              value="131072"
              c:identifier="CAMEL_UUDECODE_STATE_END">
      </member>
    </bitfield>
    <record name="UrlMatch" c:type="CamelUrlMatch">
      <field name="pattern" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="prefix" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="um_so" writable="1">
        <type name="gint64" c:type="goffset"/>
      </field>
      <field name="um_eo" writable="1">
        <type name="gint64" c:type="goffset"/>
      </field>
    </record>
    <record name="UrlPattern" c:type="CamelUrlPattern">
      <field name="pattern" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="prefix" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="start" writable="1">
        <type name="UrlScanFunc" c:type="CamelUrlScanFunc"/>
      </field>
      <field name="end" writable="1">
        <type name="UrlScanFunc" c:type="CamelUrlScanFunc"/>
      </field>
    </record>
    <callback name="UrlScanFunc" c:type="CamelUrlScanFunc">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="inend" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="UrlMatch" c:type="CamelUrlMatch*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="UrlScanner" c:type="CamelUrlScanner" disguised="1">
      <method name="add"
              c:identifier="camel_url_scanner_add"
              introspectable="0">
        <doc xml:space="preserve">Adds a new @pattern into the scanner</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelUrlScanner</doc>
            <type name="UrlScanner" c:type="CamelUrlScanner*"/>
          </instance-parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelUrlPattern to add</doc>
            <type name="UrlPattern" c:type="CamelUrlPattern*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="camel_url_scanner_free"
              introspectable="0">
        <doc xml:space="preserve">Frees the @scanner.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelUrlScanner</doc>
            <type name="UrlScanner" c:type="CamelUrlScanner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="scan"
              c:identifier="camel_url_scanner_scan"
              introspectable="0">
        <doc xml:space="preserve">Scan the @in string with the @match criterias.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if there is a result.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanner" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelUrlScanner object.</doc>
            <type name="UrlScanner" c:type="CamelUrlScanner*"/>
          </instance-parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">the url to scan.</doc>
            <array length="1" zero-terminated="0" c:type="gchar*">
              <type name="gchar" c:type="gchar"/>
            </array>
          </parameter>
          <parameter name="inlen" transfer-ownership="none">
            <doc xml:space="preserve">length of the in array.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="match" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelUrlMatch structure containing the criterias.</doc>
            <type name="UrlMatch" c:type="CamelUrlMatch*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="camel_url_scanner_new"
                introspectable="0">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Creates a new #CamelUrlScanner</doc>
          <type name="UrlScanner" c:type="CamelUrlScanner*"/>
        </return-value>
      </function>
    </record>
    <constant name="VJUNK_NAME"
              value=".#evolution/Junk"
              c:type="CAMEL_VJUNK_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VTRASH_NAME"
              value=".#evolution/Trash"
              c:type="CAMEL_VTRASH_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="VTrashFolder"
           c:symbol-prefix="vtrash_folder"
           c:type="CamelVTrashFolder"
           parent="VeeFolder"
           glib:type-name="CamelVTrashFolder"
           glib:get-type="camel_vtrash_folder_get_type"
           glib:type-struct="VTrashFolderClass">
      <constructor name="new" c:identifier="camel_vtrash_folder_new">
        <doc xml:space="preserve">Create a new CamelVTrashFolder object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelVTrashFolder object</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <parameter name="parent_store" transfer-ownership="none">
            <doc xml:space="preserve">the parent #CamelVeeStore object</doc>
            <type name="Store" c:type="CamelStore*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">type of vfolder, #CAMEL_VTRASH_FOLDER_TRASH or
#CAMEL_VTRASH_FOLDER_JUNK currently.</doc>
            <type name="VTrashFolderType" c:type="CamelVTrashFolderType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_folder_type"
              c:identifier="camel_vtrash_folder_get_folder_type"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a @vtrash_folder folder type (#CamelVTrashFolderType)</doc>
          <type name="VTrashFolderType" c:type="CamelVTrashFolderType"/>
        </return-value>
        <parameters>
          <instance-parameter name="vtrash_folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVTrashFolder</doc>
            <type name="VTrashFolder" c:type="CamelVTrashFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="VeeFolder" c:type="CamelVeeFolder"/>
      </field>
      <field name="priv">
        <type name="VTrashFolderPrivate" c:type="CamelVTrashFolderPrivate*"/>
      </field>
    </class>
    <record name="VTrashFolderClass"
            c:type="CamelVTrashFolderClass"
            glib:is-gtype-struct-for="VTrashFolder">
      <field name="parent_class">
        <type name="VeeFolderClass" c:type="CamelVeeFolderClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="VTrashFolderPrivate"
            c:type="CamelVTrashFolderPrivate"
            disguised="1">
    </record>
    <enumeration name="VTrashFolderType" c:type="CamelVTrashFolderType">
      <member name="trash" value="0" c:identifier="CAMEL_VTRASH_FOLDER_TRASH">
      </member>
      <member name="junk" value="1" c:identifier="CAMEL_VTRASH_FOLDER_JUNK">
      </member>
      <member name="last" value="2" c:identifier="CAMEL_VTRASH_FOLDER_LAST">
      </member>
    </enumeration>
    <class name="VeeDataCache"
           c:symbol-prefix="vee_data_cache"
           c:type="CamelVeeDataCache"
           version="3.6"
           parent="GObject.Object"
           glib:type-name="CamelVeeDataCache"
           glib:get-type="camel_vee_data_cache_get_type"
           glib:type-struct="VeeDataCacheClass">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <constructor name="new"
                   c:identifier="camel_vee_data_cache_new"
                   version="3.6">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelVeeDataCache; unref it
   with g_object_unref(), when no longer needed.</doc>
          <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
        </return-value>
      </constructor>
      <method name="add_subfolder"
              c:identifier="camel_vee_data_cache_add_subfolder"
              version="3.6">
        <doc xml:space="preserve">Adds the @subfolder to the @data_cache to be tracked by it. The @subfolder
is referenced for later use. The function does nothing when the @subfolder
is already in the @data_cache. The subfolders can be removed with
camel_vee_data_cache_remove_subfolder().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_message_info_data"
              c:identifier="camel_vee_data_cache_contains_message_info_data"
              version="3.6">
        <doc xml:space="preserve">Returns whether data_cache contains given @orig_message_uid for the given @folder.
Unlike camel_vee_data_cache_get_message_info_data(), this only
returns %FALSE if not, while camel_vee_data_cache_get_message_info_data()
auto-adds it to data_cache.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder to which the @orig_message_uid belongs</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="orig_message_uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID from the @folder to check</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_message_info_data"
              c:identifier="camel_vee_data_cache_foreach_message_info_data"
              version="3.6">
        <doc xml:space="preserve">Calls the @func for each message info data from the given @fromfolder</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="fromfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:space="preserve">a #CamelForeachInfoData function to call</doc>
            <type name="ForeachInfoData" c:type="CamelForeachInfoData"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to the @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_info_data"
              c:identifier="camel_vee_data_cache_get_message_info_data"
              version="3.6">
        <doc xml:space="preserve">Returns a referenced #CamelVeeMessageInfoData referencing the given @folder
and @orig_message_uid. If it's not part of the @data_cache, then it is
created and auto-added. Use camel_vee_data_cache_contains_message_info_data()
when you only want to check the existence, without adding it to the @data_cache.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a referenced #CamelVeeMessageInfoData; unref it
   with g_object_unref(), when no longer needed.</doc>
          <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder to which the @orig_message_uid belongs</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="orig_message_uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID from the @folder to return</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_message_info_data_by_vuid"
              c:identifier="camel_vee_data_cache_get_message_info_data_by_vuid"
              version="3.6">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a referenced #CamelVeeMessageInfoData,
   which corresponds to the given @vee_message_uid, or %NULL, when no such
   message info with that virtual UID exists. Unref it with g_object_unref(),
   when no longer needed.</doc>
          <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="vee_message_uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID in the virtual folder</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_subfolder_data"
              c:identifier="camel_vee_data_cache_get_subfolder_data"
              version="3.6">
        <doc xml:space="preserve">Returns a #CamelVeeSubfolderData for the given @folder.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a referenced #CamelVeeSubfolderData; unref it
   with g_object_unref(), when no longer needed.</doc>
          <type name="VeeSubfolderData" c:type="CamelVeeSubfolderData*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder for which to return subfolder data</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_message_info_data"
              c:identifier="camel_vee_data_cache_remove_message_info_data"
              version="3.6">
        <doc xml:space="preserve">Removes given @mi_data from the @data_cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="mi_data" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeMessageInfoData to remove</doc>
            <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_subfolder"
              c:identifier="camel_vee_data_cache_remove_subfolder"
              version="3.6">
        <doc xml:space="preserve">Removes given @subfolder from the @data_cache, which had been
previously added with camel_vee_data_cache_add_subfolder().
The function does nothing, when the @subfolder is not part
of the @data_cache.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_cache" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeDataCache</doc>
            <type name="VeeDataCache" c:type="CamelVeeDataCache*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder to remove</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="VeeDataCachePrivate" c:type="CamelVeeDataCachePrivate*"/>
      </field>
    </class>
    <record name="VeeDataCacheClass"
            c:type="CamelVeeDataCacheClass"
            glib:is-gtype-struct-for="VeeDataCache">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="VeeDataCachePrivate"
            c:type="CamelVeeDataCachePrivate"
            disguised="1">
    </record>
    <class name="VeeFolder"
           c:symbol-prefix="vee_folder"
           c:type="CamelVeeFolder"
           parent="Folder"
           glib:type-name="CamelVeeFolder"
           glib:get-type="camel_vee_folder_get_type"
           glib:type-struct="VeeFolderClass">
      <constructor name="new" c:identifier="camel_vee_folder_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new @CamelVeeFolder object. Unref it
   with g_object_unref() when no longer needed.</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <parameter name="parent_store" transfer-ownership="none">
            <doc xml:space="preserve">the parent CamelVeeStore</doc>
            <type name="Store" c:type="CamelStore*"/>
          </parameter>
          <parameter name="full" transfer-ownership="none">
            <doc xml:space="preserve">the full path to the vfolder.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags of some kind</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="add_folder" invoker="add_folder">
        <doc xml:space="preserve">Adds @subfolder as a source folder to @vfolder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">source CamelFolder to add to @vfolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="folder_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="changes" transfer-ownership="none">
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rebuild_folder" invoker="rebuild_folder">
        <doc xml:space="preserve">Rebuild the folder @subfolder, if it should be.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">source CamelFolder to add to @vfolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_folder" invoker="remove_folder">
        <doc xml:space="preserve">Removed the source folder, @subfolder, from the virtual folder, @vfolder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">source CamelFolder to remove from @vfolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_expression"
                      invoker="set_expression"
                      version="3.6">
        <doc xml:space="preserve">Sets an SExp expression to be used for this @vfolder</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">an SExp expression to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_folder" c:identifier="camel_vee_folder_add_folder">
        <doc xml:space="preserve">Adds @subfolder as a source folder to @vfolder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">source CamelFolder to add to @vfolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_vuid"
              c:identifier="camel_vee_folder_add_vuid"
              version="3.6">
        <doc xml:space="preserve">Adds the @mi_data to the @vfolder. The @changes can be
updated with the made change and later used to notify others
with came_folder_changed() on the @vfolder. This can be used
only for the Unmatched folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="mi_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelVeeMessageInfoData to add</doc>
            <type name="gpointer" c:type="_CamelVeeMessageInfoData*"/>
          </parameter>
          <parameter name="changes"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an optional #CamelFolderChangeInfo to update with the made change, or %NULL</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="construct" c:identifier="camel_vee_folder_construct">
        <doc xml:space="preserve">Initializes internal structures of the @vf. This is meant to be
called by the descendants of #CamelVeeFolder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">flags for the @vf</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_auto_update"
              c:identifier="camel_vee_folder_get_auto_update"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the @vfolder can automatically update when any
   of its subfolders changes.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_expression"
              c:identifier="camel_vee_folder_get_expression"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a SExp expression used for this @vfolder</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="camel_vee_folder_get_flags"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">flags of @vf, as set by camel_vee_folder_construct()</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="vf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_location" c:identifier="camel_vee_folder_get_location">
        <doc xml:space="preserve">Find the real folder (and message info UID) for the given @vinfo.
When the @realuid is not %NULL and it's set, then use g_free() to
free it, when no longer needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a real (not virtual) #CamelFolder, which the @vinfo is for.</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vf" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="vinfo" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeMessageInfo to search for</doc>
            <type name="VeeMessageInfo" c:type="const CamelVeeMessageInfo*"/>
          </parameter>
          <parameter name="realuid"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve">if not %NULL, set to the UID of the real message info</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vee_uid_folder"
              c:identifier="camel_vee_folder_get_vee_uid_folder"
              version="3.6">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #CamelFolder to which the @vee_message_info
   belongs, or %NULL, when it could not be found.</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="vee_message_uid" transfer-ownership="none">
            <doc xml:space="preserve">a virtual message info UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ignore_next_changed_event"
              c:identifier="camel_vee_folder_ignore_next_changed_event"
              version="3.2">
        <doc xml:space="preserve">The next @subfolder-'s 'changed' event will be silently ignored. This
is usually used in virtual folders when the change was done in them,
but it is neither vTrash nor vJunk folder. Doing this avoids unnecessary
removals of messages which don't satisfy search criteria anymore,
which could be done on asynchronous delivery of folder's 'changed' signal.
These ignored changes are accumulated and used on folder refresh.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder folder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rebuild_folder"
              c:identifier="camel_vee_folder_rebuild_folder">
        <doc xml:space="preserve">Rebuild the folder @subfolder, if it should be.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">source CamelFolder to add to @vfolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_folder"
              c:identifier="camel_vee_folder_remove_folder">
        <doc xml:space="preserve">Removed the source folder, @subfolder, from the virtual folder, @vfolder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">source CamelFolder to remove from @vfolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_ignore_changed_event"
              c:identifier="camel_vee_folder_remove_from_ignore_changed_event"
              version="3.12">
        <doc xml:space="preserve">Make sure the next @subfolder-'s 'changed' event will not be silently ignored.
This is a counter-part function of camel_vee_folder_ignore_next_changed_event(),
when there was expected a change, which did not happen, to take back the previous
ignore event request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder folder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_vuid"
              c:identifier="camel_vee_folder_remove_vuid"
              version="3.6">
        <doc xml:space="preserve">Removes given @mi_data from the @vfolder. The @changes can be
updated with the made change and later used to notify others
with came_folder_changed() on the @vfolder. This can be used
only for the Unmatched folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="mi_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CamelVeeMessageInfoData to remove</doc>
            <type name="gpointer" c:type="_CamelVeeMessageInfoData*"/>
          </parameter>
          <parameter name="changes"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">an optional #CamelFolderChangeInfo to update with the made change, or %NULL</doc>
            <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_auto_update"
              c:identifier="camel_vee_folder_set_auto_update"
              version="3.6">
        <doc xml:space="preserve">Sets whether the @vfolder can automatically update when of its
subfolders changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="auto_update" transfer-ownership="none">
            <doc xml:space="preserve">a value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_expression"
              c:identifier="camel_vee_folder_set_expression"
              version="3.6">
        <doc xml:space="preserve">Sets an SExp expression to be used for this @vfolder</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="expression" transfer-ownership="none">
            <doc xml:space="preserve">an SExp expression to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_folders" c:identifier="camel_vee_folder_set_folders">
        <doc xml:space="preserve">Set the whole list of folder sources on a vee folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="CamelVeeFolder*"/>
          </instance-parameter>
          <parameter name="folders" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #CamelFolder to add</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Folder"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-update" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Folder" c:type="CamelFolder"/>
      </field>
      <field name="priv">
        <type name="VeeFolderPrivate" c:type="CamelVeeFolderPrivate*"/>
      </field>
    </class>
    <record name="VeeFolderClass"
            c:type="CamelVeeFolderClass"
            glib:is-gtype-struct-for="VeeFolder">
      <field name="parent_class">
        <type name="FolderClass" c:type="CamelFolderClass"/>
      </field>
      <field name="add_folder">
        <callback name="add_folder">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfolder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelVeeFolder</doc>
              <type name="VeeFolder" c:type="CamelVeeFolder*"/>
            </parameter>
            <parameter name="subfolder" transfer-ownership="none">
              <doc xml:space="preserve">source CamelFolder to add to @vfolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_folder">
        <callback name="remove_folder">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfolder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelVeeFolder</doc>
              <type name="VeeFolder" c:type="CamelVeeFolder*"/>
            </parameter>
            <parameter name="subfolder" transfer-ownership="none">
              <doc xml:space="preserve">source CamelFolder to remove from @vfolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rebuild_folder">
        <callback name="rebuild_folder">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfolder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelVeeFolder</doc>
              <type name="VeeFolder" c:type="CamelVeeFolder*"/>
            </parameter>
            <parameter name="subfolder" transfer-ownership="none">
              <doc xml:space="preserve">source CamelFolder to add to @vfolder</doc>
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_expression">
        <callback name="set_expression">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfolder" transfer-ownership="none">
              <doc xml:space="preserve">a #CamelVeeFolder</doc>
              <type name="VeeFolder" c:type="CamelVeeFolder*"/>
            </parameter>
            <parameter name="expression" transfer-ownership="none">
              <doc xml:space="preserve">an SExp expression to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="folder_changed">
        <callback name="folder_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="vfolder" transfer-ownership="none">
              <type name="VeeFolder" c:type="CamelVeeFolder*"/>
            </parameter>
            <parameter name="subfolder" transfer-ownership="none">
              <type name="Folder" c:type="CamelFolder*"/>
            </parameter>
            <parameter name="changes" transfer-ownership="none">
              <type name="FolderChangeInfo" c:type="CamelFolderChangeInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="VeeFolderPrivate"
            c:type="CamelVeeFolderPrivate"
            disguised="1">
    </record>
    <class name="VeeMessageInfo"
           c:symbol-prefix="vee_message_info"
           c:type="CamelVeeMessageInfo"
           parent="MessageInfo"
           glib:type-name="CamelVeeMessageInfo"
           glib:get-type="camel_vee_message_info_get_type"
           glib:type-struct="VeeMessageInfoClass">
      <constructor name="new"
                   c:identifier="camel_vee_message_info_new"
                   version="3.24">
        <doc xml:space="preserve">Creates a new instance of #CamelVeeMessageInfo which references
a message from the @original_summary internally.

The @vuid should be encoded in a way which the vFolder understands,
which is like the one returned by camel_vee_message_info_data_get_vee_message_uid().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly created #CamelVeeMessageInfo
  which references @orig_mi. Free with g_object_unref() when done
  with it.</doc>
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </return-value>
        <parameters>
          <parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeSummary, the "owner" of the created message info</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </parameter>
          <parameter name="original_summary" transfer-ownership="none">
            <doc xml:space="preserve">an original #CamelFolderSummary to reference to</doc>
            <type name="FolderSummary" c:type="CamelFolderSummary*"/>
          </parameter>
          <parameter name="vuid" transfer-ownership="none">
            <doc xml:space="preserve">what UID to set on the resulting message info</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_original_folder"
              c:identifier="camel_vee_message_info_get_original_folder"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #CamelFolder of the original
  message info, which this @vmi is proxying.</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vmi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeMessageInfo</doc>
            <type name="VeeMessageInfo" c:type="const CamelVeeMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_original_summary"
              c:identifier="camel_vee_message_info_get_original_summary"
              version="3.24">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #CamelFolderSummary of the original
  message info, which this @vmi is proxying.</doc>
          <type name="FolderSummary" c:type="CamelFolderSummary*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vmi" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeMessageInfo</doc>
            <type name="VeeMessageInfo" c:type="const CamelVeeMessageInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="MessageInfo" c:type="CamelMessageInfo"/>
      </field>
      <field name="priv">
        <type name="VeeMessageInfoPrivate"
              c:type="CamelVeeMessageInfoPrivate*"/>
      </field>
    </class>
    <record name="VeeMessageInfoClass"
            c:type="CamelVeeMessageInfoClass"
            glib:is-gtype-struct-for="VeeMessageInfo">
      <field name="parent_class">
        <type name="MessageInfoClass" c:type="CamelMessageInfoClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="VeeMessageInfoData"
           c:symbol-prefix="vee_message_info_data"
           c:type="CamelVeeMessageInfoData"
           version="3.6"
           parent="GObject.Object"
           glib:type-name="CamelVeeMessageInfoData"
           glib:get-type="camel_vee_message_info_data_get_type"
           glib:type-struct="VeeMessageInfoDataClass">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <constructor name="new"
                   c:identifier="camel_vee_message_info_data_new"
                   version="3.6">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelVeeMessageInfoData which references
   message info with UID @orig_message_uid froma folder managed by @subfolder_data.
   Unref the returned object with g_object_unref(), when no longer needed.</doc>
          <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
        </return-value>
        <parameters>
          <parameter name="subfolder_data" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeSubfolderData</doc>
            <type name="VeeSubfolderData" c:type="CamelVeeSubfolderData*"/>
          </parameter>
          <parameter name="orig_message_uid" transfer-ownership="none">
            <doc xml:space="preserve">original message info's UID</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_orig_message_uid"
              c:identifier="camel_vee_message_info_data_get_orig_message_uid"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The original message info's UID, for which
   the @data had been created.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a CamelVeeMessageInfoData</doc>
            <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subfolder_data"
              c:identifier="camel_vee_message_info_data_get_subfolder_data"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A #CamelVeeSubfolderData for which
   the @data had been created.</doc>
          <type name="VeeSubfolderData" c:type="CamelVeeSubfolderData*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a CamelVeeMessageInfoData</doc>
            <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vee_message_uid"
              c:identifier="camel_vee_message_info_data_get_vee_message_uid"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Message UID corresponding to this virtual
   message info @data.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a CamelVeeMessageInfoData</doc>
            <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="VeeMessageInfoDataPrivate"
              c:type="CamelVeeMessageInfoDataPrivate*"/>
      </field>
    </class>
    <record name="VeeMessageInfoDataClass"
            c:type="CamelVeeMessageInfoDataClass"
            glib:is-gtype-struct-for="VeeMessageInfoData">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="VeeMessageInfoDataPrivate"
            c:type="CamelVeeMessageInfoDataPrivate"
            disguised="1">
    </record>
    <record name="VeeMessageInfoPrivate"
            c:type="CamelVeeMessageInfoPrivate"
            disguised="1">
    </record>
    <class name="VeeStore"
           c:symbol-prefix="vee_store"
           c:type="CamelVeeStore"
           parent="Store"
           glib:type-name="CamelVeeStore"
           glib:get-type="camel_vee_store_get_type"
           glib:type-struct="VeeStoreClass">
      <implements name="Gio.Initable"/>
      <constructor name="new" c:identifier="camel_vee_store_new">
        <doc xml:space="preserve">Create a new #CamelVeeStore object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">new #CamelVeeStore object</doc>
          <type name="VeeStore" c:type="CamelVeeStore*"/>
        </return-value>
      </constructor>
      <method name="get_unmatched_enabled"
              c:identifier="camel_vee_store_get_unmatched_enabled"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether Unmatched folder processing is enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_unmatched_folder"
              c:identifier="camel_vee_store_get_unmatched_folder"
              version="3.6">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the Unmatched folder instance, or %NULL,
   when it's disabled.</doc>
          <type name="gpointer" c:type="_CamelVeeFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vee_data_cache"
              c:identifier="camel_vee_store_get_vee_data_cache"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the associated #CamelVeeDataCache</doc>
          <type name="VeeFolder" c:type="CamelVeeDataCache*"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="note_subfolder_unused"
              c:identifier="camel_vee_store_note_subfolder_unused"
              version="3.6">
        <doc xml:space="preserve">This is a counter part of camel_vee_store_note_subfolder_used(). Once
the @subfolder is claimed to be not used by all folders its message infos
are removed from the Unmatched folder.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="unused_by" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="note_subfolder_used"
              c:identifier="camel_vee_store_note_subfolder_used"
              version="3.6">
        <doc xml:space="preserve">Notes that the @subfolder is used by @used_by folder, which
is used to determine what folders will be included in
the Unmatched folders.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
          <parameter name="used_by" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="note_vuid_unused"
              c:identifier="camel_vee_store_note_vuid_unused"
              version="3.6">
        <doc xml:space="preserve">A counter part of camel_vee_store_note_vuid_used(). Once the @unused_by
claims the @mi_data is not used by it anymore, and neither any other
virtual folder is using it, then the Unmatched folder will have it added.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
          <parameter name="mi_data" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeMessageInfoData</doc>
            <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
          </parameter>
          <parameter name="unused_by" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="note_vuid_used"
              c:identifier="camel_vee_store_note_vuid_used"
              version="3.6">
        <doc xml:space="preserve">Notes the @mi_data is used by the @used_by virtual folder, which
removes it from the Unmatched folder, if not used anywhere else.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
          <parameter name="mi_data" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeMessageInfoData</doc>
            <type name="VeeMessageInfoData" c:type="CamelVeeMessageInfoData*"/>
          </parameter>
          <parameter name="used_by" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeFolder</doc>
            <type name="VeeFolder" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rebuild_unmatched_folder"
              c:identifier="camel_vee_store_rebuild_unmatched_folder"
              version="3.6"
              throws="1">
        <doc xml:space="preserve">Let's the @vstore know to rebuild the Unmatched folder. This is done
as a separate job, when the @cancellable is %NULL, otherwise it's run
synchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unmatched_enabled"
              c:identifier="camel_vee_store_set_unmatched_enabled"
              version="3.6">
        <doc xml:space="preserve">Sets whether the Unmatched folder processing is enabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="vstore" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeStore</doc>
            <type name="VeeStore" c:type="CamelVeeStore*"/>
          </instance-parameter>
          <parameter name="is_enabled" transfer-ownership="none">
            <doc xml:space="preserve">value to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="unmatched-enabled"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Store" c:type="CamelStore"/>
      </field>
      <field name="priv">
        <type name="VeeStorePrivate" c:type="CamelVeeStorePrivate*"/>
      </field>
    </class>
    <record name="VeeStoreClass"
            c:type="CamelVeeStoreClass"
            glib:is-gtype-struct-for="VeeStore">
      <field name="parent_class">
        <type name="StoreClass" c:type="CamelStoreClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="VeeStorePrivate" c:type="CamelVeeStorePrivate" disguised="1">
    </record>
    <class name="VeeSubfolderData"
           c:symbol-prefix="vee_subfolder_data"
           c:type="CamelVeeSubfolderData"
           version="3.6"
           parent="GObject.Object"
           glib:type-name="CamelVeeSubfolderData"
           glib:get-type="camel_vee_subfolder_data_get_type"
           glib:type-struct="VeeSubfolderDataClass">
      <doc xml:space="preserve">Contains only private data that should be read and manipulated using the
functions below.</doc>
      <constructor name="new"
                   c:identifier="camel_vee_subfolder_data_new"
                   version="3.6">
        <doc xml:space="preserve">Creates a new #CamelVeeSubfolderData object for the given @folder.
The @folder is referenced for later use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #CamelVeeSubfolderData. Use g_object_unref()
   to unref it, when no longer needed.</doc>
          <type name="VeeSubfolderData" c:type="CamelVeeSubfolderData*"/>
        </return-value>
        <parameters>
          <parameter name="folder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder for which create the object</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_folder"
              c:identifier="camel_vee_subfolder_data_get_folder"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CamelFolder to which this @data was created</doc>
          <type name="Folder" c:type="CamelFolder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a CamelVeeSubfolderData</doc>
            <type name="VeeSubfolderData" c:type="CamelVeeSubfolderData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_folder_id"
              c:identifier="camel_vee_subfolder_data_get_folder_id"
              version="3.6">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a folder ID for this subfolder @data</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">a CamelVeeSubfolderData</doc>
            <type name="VeeSubfolderData" c:type="CamelVeeSubfolderData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="VeeSubfolderDataPrivate"
              c:type="CamelVeeSubfolderDataPrivate*"/>
      </field>
    </class>
    <record name="VeeSubfolderDataClass"
            c:type="CamelVeeSubfolderDataClass"
            glib:is-gtype-struct-for="VeeSubfolderData">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="VeeSubfolderDataPrivate"
            c:type="CamelVeeSubfolderDataPrivate"
            disguised="1">
    </record>
    <class name="VeeSummary"
           c:symbol-prefix="vee_summary"
           c:type="CamelVeeSummary"
           parent="FolderSummary"
           glib:type-name="CamelVeeSummary"
           glib:get-type="camel_vee_summary_get_type"
           glib:type-struct="VeeSummaryClass">
      <constructor name="new" c:identifier="camel_vee_summary_new">
        <doc xml:space="preserve">This will create a new CamelVeeSummary object and read in the
summary data from disk, if it exists.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new CamelVeeSummary object.</doc>
          <type name="FolderSummary" c:type="CamelFolderSummary*"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">Folder its attached to.</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="camel_vee_summary_add">
        <doc xml:space="preserve">Unref returned pointer with g_object_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelVeeMessageInfo object.</doc>
          <type name="VeeMessageInfo" c:type="CamelVeeMessageInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">the CamelVeeSummary</doc>
            <type name="VeeSummary" c:type="CamelVeeSummary*"/>
          </instance-parameter>
          <parameter name="mi_data" transfer-ownership="none">
            <doc xml:space="preserve">the #CamelVeeMessageInfoData to add</doc>
            <type name="VeeMessageInfoData" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uids_for_subfolder"
              c:identifier="camel_vee_summary_get_uids_for_subfolder"
              version="3.6">
        <doc xml:space="preserve">Returns a hash table of all virtual message info UID-s known to the @summary.
The key of the hash table is the virtual message info UID, the value is
only the number 1.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GHashTable with
   all the virtual mesasge info UID-s knwn to the @summary.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="gint"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeSummary</doc>
            <type name="VeeSummary" c:type="CamelVeeSummary*"/>
          </instance-parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove"
              c:identifier="camel_vee_summary_remove"
              version="3.6">
        <doc xml:space="preserve">Removes the given @vuid of the @subfolder from the @summary.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeSummary</doc>
            <type name="VeeSummary" c:type="CamelVeeSummary*"/>
          </instance-parameter>
          <parameter name="vuid" transfer-ownership="none">
            <doc xml:space="preserve">a virtual message info UID to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="subfolder" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelFolder to which @vuid belongs</doc>
            <type name="Folder" c:type="CamelFolder*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_flags"
              c:identifier="camel_vee_summary_replace_flags"
              version="3.6">
        <doc xml:space="preserve">Makes sure @summary flags on @uid corresponds to those
in the subfolder of vee-folder, and updates internal counts
on @summary as well.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="summary" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelVeeSummary</doc>
            <type name="VeeSummary" c:type="CamelVeeSummary*"/>
          </instance-parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:space="preserve">a message UID to update flags for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="FolderSummary" c:type="CamelFolderSummary"/>
      </field>
      <field name="priv">
        <type name="VeeSummaryPrivate" c:type="CamelVeeSummaryPrivate*"/>
      </field>
    </class>
    <record name="VeeSummaryClass"
            c:type="CamelVeeSummaryClass"
            glib:is-gtype-struct-for="VeeSummary">
      <field name="parent_class">
        <type name="FolderSummaryClass" c:type="CamelFolderSummaryClass"/>
      </field>
      <field name="reserved">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="VeeSummaryPrivate"
            c:type="CamelVeeSummaryPrivate"
            disguised="1">
    </record>
    <record name="WeakRefGroup"
            c:type="CamelWeakRefGroup"
            glib:type-name="CamelWeakRefGroup"
            glib:get-type="camel_weak_ref_group_get_type"
            c:symbol-prefix="weak_ref_group">
      <constructor name="new"
                   c:identifier="camel_weak_ref_group_new"
                   version="3.24">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #CamelWeakRefGroup instance, which should
   be freed with camel_weak_ref_group_unref() when no longer needed.</doc>
          <type name="WeakRefGroup" c:type="CamelWeakRefGroup*"/>
        </return-value>
      </constructor>
      <method name="get"
              c:identifier="camel_weak_ref_group_get"
              version="3.24">
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">A referenced object associated with @group,
   or %NULL, when no object had been set to it. Use g_object_unref()
   to free it, when no longer needed.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelWeakRefGroup</doc>
            <type name="WeakRefGroup" c:type="CamelWeakRefGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref"
              c:identifier="camel_weak_ref_group_ref"
              version="3.24">
        <doc xml:space="preserve">Increases a reference count of the @group.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the @group</doc>
          <type name="WeakRefGroup" c:type="CamelWeakRefGroup*"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelWeakRefGroup</doc>
            <type name="WeakRefGroup" c:type="CamelWeakRefGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set"
              c:identifier="camel_weak_ref_group_set"
              version="3.24">
        <doc xml:space="preserve">Sets the @object as the object help by this @group. If
the @object is %NULL, then unsets any previously set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelWeakRefGroup</doc>
            <type name="WeakRefGroup" c:type="CamelWeakRefGroup*"/>
          </instance-parameter>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GObject descendant, or %NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref"
              c:identifier="camel_weak_ref_group_unref"
              version="3.24">
        <doc xml:space="preserve">Decreases a reference count of the @group. The @group is
freed when the reference count reaches zero.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">a #CamelWeakRefGroup</doc>
            <type name="WeakRefGroup" c:type="CamelWeakRefGroup*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="_KeyKey" c:type="_CamelKeyKey">
      <field name="data" writable="1">
        <type name="_block_t" c:type="camel_block_t"/>
      </field>
      <field name="offset" writable="1" bits="10">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="flags" writable="1" bits="22">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="_LockHelperMsg" c:type="_CamelLockHelperMsg">
      <field name="magic" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="seq" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="id" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="data" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
    </record>
    <record name="__search_word" c:type="_camel_search_word">
      <field name="type" writable="1">
        <type name="_search_word_t" c:type="camel_search_word_t"/>
      </field>
      <field name="word" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
    </record>
    <record name="__search_words" c:type="_camel_search_words">
      <field name="len" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="type" writable="1">
        <type name="_search_word_t" c:type="camel_search_word_t"/>
      </field>
      <field name="words" writable="1">
        <type name="gpointer" c:type="_camel_search_word**"/>
      </field>
    </record>
    <record name="_encrypt" c:type="_encrypt">
      <field name="status" writable="1">
        <type name="CipherValidityEncrypt"
              c:type="CamelCipherValidityEncrypt"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="encrypters" writable="1">
        <type name="GLib.Queue" c:type="GQueue"/>
      </field>
    </record>
    <bitfield name="_search_flags_t" c:type="camel_search_flags_t">
      <member name="start" value="1" c:identifier="CAMEL_SEARCH_MATCH_START">
      </member>
      <member name="end" value="2" c:identifier="CAMEL_SEARCH_MATCH_END">
      </member>
      <member name="regex" value="4" c:identifier="CAMEL_SEARCH_MATCH_REGEX">
      </member>
      <member name="icase" value="8" c:identifier="CAMEL_SEARCH_MATCH_ICASE">
      </member>
      <member name="newline"
              value="16"
              c:identifier="CAMEL_SEARCH_MATCH_NEWLINE">
      </member>
    </bitfield>
    <enumeration name="_search_match_t" c:type="camel_search_match_t">
      <member name="exact" value="0" c:identifier="CAMEL_SEARCH_MATCH_EXACT">
      </member>
      <member name="contains"
              value="1"
              c:identifier="CAMEL_SEARCH_MATCH_CONTAINS">
      </member>
      <member name="word" value="2" c:identifier="CAMEL_SEARCH_MATCH_WORD">
      </member>
      <member name="starts" value="3" c:identifier="CAMEL_SEARCH_MATCH_STARTS">
      </member>
      <member name="ends" value="4" c:identifier="CAMEL_SEARCH_MATCH_ENDS">
      </member>
      <member name="soundex"
              value="5"
              c:identifier="CAMEL_SEARCH_MATCH_SOUNDEX">
      </member>
    </enumeration>
    <enumeration name="_search_t" c:type="camel_search_t">
      <member name="asis" value="0" c:identifier="CAMEL_SEARCH_TYPE_ASIS">
      </member>
      <member name="encoded"
              value="1"
              c:identifier="CAMEL_SEARCH_TYPE_ENCODED">
      </member>
      <member name="address"
              value="2"
              c:identifier="CAMEL_SEARCH_TYPE_ADDRESS">
      </member>
      <member name="address_encoded"
              value="3"
              c:identifier="CAMEL_SEARCH_TYPE_ADDRESS_ENCODED">
      </member>
      <member name="mlist" value="4" c:identifier="CAMEL_SEARCH_TYPE_MLIST">
      </member>
    </enumeration>
    <enumeration name="_search_word_t" c:type="camel_search_word_t">
      <member name="simple" value="1" c:identifier="CAMEL_SEARCH_WORD_SIMPLE">
      </member>
      <member name="complex"
              value="2"
              c:identifier="CAMEL_SEARCH_WORD_COMPLEX">
      </member>
      <member name="8bit" value="4" c:identifier="CAMEL_SEARCH_WORD_8BIT">
      </member>
    </enumeration>
    <record name="_sign" c:type="_sign">
      <field name="status" writable="1">
        <type name="CipherValiditySign" c:type="CamelCipherValiditySign"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="signers" writable="1">
        <type name="GLib.Queue" c:type="GQueue"/>
      </field>
    </record>
    <function name="async_closure_callback"
              c:identifier="camel_async_closure_callback"
              moved-to="AsyncClosure.callback"
              version="3.12"
              introspectable="0">
      <doc xml:space="preserve">Pass this function as the #GAsyncReadyCallback argument of an asynchronous
function, and the #CamelAsyncClosure as the data argument.

This causes camel_async_closure_wait() to terminate and return @result.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_object" transfer-ownership="none">
          <doc xml:space="preserve">a #GObject or %NULL</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">a #GAsyncResult</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
        <parameter name="closure"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #CamelAsyncClosure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="async_closure_new"
              c:identifier="camel_async_closure_new"
              moved-to="AsyncClosure.new"
              version="3.12"
              introspectable="0">
      <doc xml:space="preserve">Creates a new #CamelAsyncClosure for use with asynchronous functions.</doc>
      <return-value>
        <doc xml:space="preserve">a new #CamelAsyncClosure</doc>
        <type name="AsyncClosure" c:type="CamelAsyncClosure*"/>
      </return-value>
    </function>
    <function name="binding_bind_property"
              c:identifier="camel_binding_bind_property"
              version="3.16">
      <doc xml:space="preserve">Thread safe variant of g_object_bind_property(). See its documentation
for more information on arguments and return value.</doc>
      <return-value transfer-ownership="none">
        <type name="GObject.Binding" c:type="GBinding*"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">the source #GObject</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="source_property" transfer-ownership="none">
          <doc xml:space="preserve">the property on @source to bind</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">the target #GObject</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="target_property" transfer-ownership="none">
          <doc xml:space="preserve">the property on @target to bind</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to pass to #GBinding</doc>
          <type name="GObject.BindingFlags" c:type="GBindingFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="binding_bind_property_full"
              c:identifier="camel_binding_bind_property_full"
              shadowed-by="binding_bind_property_with_closures"
              version="3.16">
      <doc xml:space="preserve">Thread safe variant of g_object_bind_property_full(). See its documentation
for more information on arguments and return value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GBinding instance representing the
  binding between the two #GObject instances. The binding is released
  whenever the #GBinding reference count reaches zero.</doc>
        <type name="GObject.Binding" c:type="GBinding*"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">the source #GObject</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="source_property" transfer-ownership="none">
          <doc xml:space="preserve">the property on @source to bind</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">the target #GObject</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="target_property" transfer-ownership="none">
          <doc xml:space="preserve">the property on @target to bind</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to pass to #GBinding</doc>
          <type name="GObject.BindingFlags" c:type="GBindingFlags"/>
        </parameter>
        <parameter name="transform_to"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="notified">
          <doc xml:space="preserve">the transformation function
  from the @source to the @target, or %NULL to use the default</doc>
          <type name="GObject.BindingTransformFunc"
                c:type="GBindingTransformFunc"/>
        </parameter>
        <parameter name="transform_from"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="notified"
                   closure="7"
                   destroy="8">
          <doc xml:space="preserve">the transformation function
  from the @target to the @source, or %NULL to use the default</doc>
          <type name="GObject.BindingTransformFunc"
                c:type="GBindingTransformFunc"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">custom data to be passed to the transformation functions,
  or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">function to be called when disposing the binding, to free the
  resources used by the transformation functions</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="binding_bind_property_with_closures"
              c:identifier="camel_binding_bind_property_with_closures"
              shadows="binding_bind_property_full"
              version="3.16">
      <doc xml:space="preserve">Thread safe variant of g_object_bind_property_with_closures(). See its
documentation for more information on arguments and return value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GBinding instance representing the
  binding between the two #GObject instances. The binding is released
  whenever the #GBinding reference count reaches zero.</doc>
        <type name="GObject.Binding" c:type="GBinding*"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">the source #GObject</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="source_property" transfer-ownership="none">
          <doc xml:space="preserve">the property on @source to bind</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">the target #GObject</doc>
          <type name="GObject.Object" c:type="gpointer"/>
        </parameter>
        <parameter name="target_property" transfer-ownership="none">
          <doc xml:space="preserve">the property on @target to bind</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags to pass to #GBinding</doc>
          <type name="GObject.BindingFlags" c:type="GBindingFlags"/>
        </parameter>
        <parameter name="transform_to" transfer-ownership="none">
          <doc xml:space="preserve">a #GClosure wrapping the transformation function
  from the @source to the @target, or %NULL to use the default</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
        <parameter name="transform_from" transfer-ownership="none">
          <doc xml:space="preserve">a #GClosure wrapping the transformation function
  from the @target to the @source, or %NULL to use the default</doc>
          <type name="GObject.Closure" c:type="GClosure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="charset_best"
              c:identifier="camel_charset_best"
              moved-to="Charset.best">
      <doc xml:space="preserve">Finds the minimum charset for this string NULL means US-ASCII.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the minimum charset or NULL for US_ASCII.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input text</doc>
          <array length="1" zero-terminated="0" c:type="gchar*">
            <type name="gchar" c:type="gchar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the input text</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="charset_iso_to_windows"
              c:identifier="camel_charset_iso_to_windows"
              moved-to="Charset.iso_to_windows">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the equivalent Windows charset.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="isocharset" transfer-ownership="none">
          <doc xml:space="preserve">a canonicalised ISO charset</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cipher_can_load_photos"
              c:identifier="camel_cipher_can_load_photos"
              version="3.22">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether ciphers can load photos, as being setup by the user.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="cipher_canonical_to_stream"
              c:identifier="camel_cipher_canonical_to_stream"
              throws="1">
      <doc xml:space="preserve">Writes a part to a stream in a canonicalised format, suitable for signing/encrypting.

The transfer encoding paramaters for the part may be changed by this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1 on error;</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="part" transfer-ownership="none">
          <doc xml:space="preserve">Part to write.</doc>
          <type name="MimePart" c:type="CamelMimePart*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the canonicalisation filter (CamelMimeFilterCanon)</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="ostream" transfer-ownership="none">
          <doc xml:space="preserve">stream to write canonicalised output to.</doc>
          <type name="Stream" c:type="CamelStream*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cipher_certinfo_get_property"
              c:identifier="camel_cipher_certinfo_get_property"
              version="3.22">
      <doc xml:space="preserve">Gets a named property @name value for the given @cert_info.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">Value of a named property of the @cert_info,
   or %NULL when no such property exists. The returned value is owned by
   the @cert_info and is valid until the @cert_info is freed.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="cert_info" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelCipherCertInfo</doc>
          <type name="CipherCertInfo" c:type="CamelCipherCertInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a property name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cipher_certinfo_set_property"
              c:identifier="camel_cipher_certinfo_set_property"
              version="3.22">
      <doc xml:space="preserve">Sets a named property @name value @value for the given @cert_info.
If the @value is %NULL, then the property is removed. With a non-%NULL
@value also @value_free and @value_clone functions cannot be %NULL.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cert_info" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelCipherCertInfo</doc>
          <type name="CipherCertInfo" c:type="CamelCipherCertInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a property name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="notified"
                   destroy="3">
          <doc xml:space="preserve">a property value, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value_free"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async">
          <doc xml:space="preserve">a free function for the @value</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="value_clone"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="call">
          <doc xml:space="preserve">a clone function for the @value</doc>
          <type name="CipherCloneFunc" c:type="CamelCipherCloneFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_disposition_decode"
              c:identifier="camel_content_disposition_decode"
              moved-to="ContentDisposition.decode">
      <return-value transfer-ownership="full">
        <type name="ContentDisposition" c:type="CamelContentDisposition*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_transfer_encoding_decode"
              c:identifier="camel_content_transfer_encoding_decode">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="content_type_decode"
              c:identifier="camel_content_type_decode"
              moved-to="ContentType.decode">
      <return-value transfer-ownership="full">
        <type name="ContentType" c:type="CamelContentType*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug" c:identifier="camel_debug">
      <doc xml:space="preserve">Check to see if a debug mode is activated.  @mode takes one of two forms,
a fully qualified 'module:target', or a wildcard 'module' name.  It
returns a boolean to indicate if the module or module and target is
currently activated for debug output.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the debug @mode is activated</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">string name of the mode to check for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_end" c:identifier="camel_debug_end">
      <doc xml:space="preserve">Call this when you're done with your debug output.  If and only if
you called camel_debug_start, and if it returns TRUE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_get_backtrace"
              c:identifier="camel_debug_get_backtrace"
              version="3.12">
      <doc xml:space="preserve">Gets current backtrace leading to this function call.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Current backtrace, or %NULL, if cannot determine it.

Note: Getting backtraces only works if the library was
configured with --enable-backtraces.</doc>
        <type name="GLib.String" c:type="GString*"/>
      </return-value>
    </function>
    <function name="debug_init" c:identifier="camel_debug_init">
      <doc xml:space="preserve">Init camel debug.

CAMEL_DEBUG is set to a comma separated list of modules to debug.
The modules can contain module-specific specifiers after a ':', or
just act as a wildcard for the module or even specifier.  e.g. 'imap'
for imap debug, or 'imap:folder' for imap folder debug.  Additionaly,
':folder' can be used for a wildcard for any folder operations.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_ref_unref_dump_backtraces"
              c:identifier="camel_debug_ref_unref_dump_backtraces"
              version="3.20">
      <doc xml:space="preserve">Prints current backtraces stored with camel_debug_ref_unref_push_backtrace()
or with camel_debug_ref_unref_push_backtrace_for_object().

It's usually not needed to use this function, as the left backtraces, if any,
are printed at the end of the application.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_ref_unref_push_backtrace"
              c:identifier="camel_debug_ref_unref_push_backtrace"
              version="3.20">
      <doc xml:space="preserve">Adds this backtrace into the set of backtraces related to some object
reference counting issues debugging. This is usually called inside g_object_ref()
and g_object_unref(). If the backtrace corresponds to a g_object_unref()
call, and a corresponding g_object_ref() backtrace is found in the current list,
then the previous backtrace is removed and this one is skipped.

Any left backtraces in the list are printed at the application end.

A convenient function camel_debug_ref_unref_push_backtrace_for_object()
is provided too.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="backtrace" transfer-ownership="none">
          <doc xml:space="preserve">a backtrace to push, taken from camel_debug_get_backtrace()</doc>
          <type name="GLib.String" c:type="const GString*"/>
        </parameter>
        <parameter name="object_ref_count" transfer-ownership="none">
          <doc xml:space="preserve">the current object reference count when the push is done</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_ref_unref_push_backtrace_for_object"
              c:identifier="camel_debug_ref_unref_push_backtrace_for_object"
              version="3.20">
      <doc xml:space="preserve">Gets current backtrace of this call and adds it to the list
of backtraces with camel_debug_ref_unref_push_backtrace().

Usual usage would be, once GNOME bug 758358 is applied to the GLib sources,
or a patched GLib is used, to call this function in an object init() function,
like this:

static void
my_object_init (MyObject *obj)
{
   camel_debug_ref_unref_push_backtrace_for_object (obj);
   g_track_object_ref_unref (obj, (GFunc) camel_debug_ref_unref_push_backtrace_for_object, NULL);
}

Note that the g_track_object_ref_unref() can track only one pointer, thus make
sure you track the right one (add some logic if multiple objects are created at once).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="_object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #GObject, for which add the backtrace</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_start" c:identifier="camel_debug_start">
      <doc xml:space="preserve">Start debug output for a given mode, used to make sure debug output
is output atomically and not interspersed with unrelated stuff.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if mode is set, and in which case, you must
call camel_debug_end() when finished any screen output.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">string name of the mode to start the debug for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enriched_to_html" c:identifier="camel_enriched_to_html">
      <doc xml:space="preserve">Convert @in from text/plain into text/enriched or text/richtext
based on @flags.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing the enriched or
richtext version of @in.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input textual string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags specifying filter behaviour</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark" c:identifier="camel_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="file_util_decode_fixed_int32"
              c:identifier="camel_file_util_decode_fixed_int32">
      <doc xml:space="preserve">Retrieve a gint32.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to read from</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a variable to store the value in</doc>
          <type name="gint32" c:type="gint32*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_decode_fixed_string"
              c:identifier="camel_file_util_decode_fixed_string">
      <doc xml:space="preserve">Decode a normal string from the input file.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to read from</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a variable to store the value in</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">total-len to decode.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_decode_gsize"
              c:identifier="camel_file_util_decode_gsize">
      <doc xml:space="preserve">Decode an gsize type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on failure.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to read from</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a variable to put the value in</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_decode_off_t"
              c:identifier="camel_file_util_decode_off_t">
      <doc xml:space="preserve">Decode an off_t type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on failure.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to read from</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a variable to put the value in</doc>
          <type name="gsize" c:type="off_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_decode_string"
              c:identifier="camel_file_util_decode_string">
      <doc xml:space="preserve">Decode a normal string from the input file.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to read from</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a variable to store the value in</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_decode_time_t"
              c:identifier="camel_file_util_decode_time_t">
      <doc xml:space="preserve">Decode a time_t value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to read from</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a variable to store the value in</doc>
          <type name="glong" c:type="time_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_decode_uint32"
              c:identifier="camel_file_util_decode_uint32">
      <doc xml:space="preserve">Retrieve an encoded uint32 from a file.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.  @*dest will contain the
decoded value.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to read from</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a variable to store the value in</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_encode_fixed_int32"
              c:identifier="camel_file_util_encode_fixed_int32">
      <doc xml:space="preserve">Encode a gint32, performing no compression, but converting
to network order.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to output to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value to output</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_encode_fixed_string"
              c:identifier="camel_file_util_encode_fixed_string">
      <doc xml:space="preserve">Encode a normal string and save it in the output file.
Unlike @camel_file_util_encode_string, it pads the
@str with "NULL" bytes, if @len is &gt; strlen(str)</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to output to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">value to output</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">total-len of str to store</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_encode_gsize"
              c:identifier="camel_file_util_encode_gsize">
      <doc xml:space="preserve">Encode an gsize type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to output to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value to output</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_encode_off_t"
              c:identifier="camel_file_util_encode_off_t">
      <doc xml:space="preserve">Encode an off_t type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to output to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value to output</doc>
          <type name="gsize" c:type="off_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_encode_string"
              c:identifier="camel_file_util_encode_string">
      <doc xml:space="preserve">Encode a normal string and save it in the output file.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to output to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">value to output</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_encode_time_t"
              c:identifier="camel_file_util_encode_time_t">
      <doc xml:space="preserve">Encode a time_t value to the file.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to output to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value to output</doc>
          <type name="glong" c:type="time_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_encode_uint32"
              c:identifier="camel_file_util_encode_uint32">
      <doc xml:space="preserve">Utility function to save an uint32 to a file.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%0 on success, %-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">file to output to</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value to output</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_safe_filename"
              c:identifier="camel_file_util_safe_filename">
      <doc xml:space="preserve">'Flattens' @name into a safe filename string by hex encoding any
chars that may cause problems on the filesystem.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a safe filename string.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">string to 'flattened' into a safe filename</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="file_util_savename"
              c:identifier="camel_file_util_savename">
      <doc xml:space="preserve">Builds a pathname where the basename is of the form ".#" + the
basename of @filename, for instance used in a two-stage commit file
write.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new pathname.  It must be free'd with g_free().</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">a pathname</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_search_match"
              c:identifier="camel_filter_search_match"
              introspectable="0"
              throws="1">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">one of CAMEL_SEARCH_MATCHED, CAMEL_SEARCH_NOMATCH, or
CAMEL_SEARCH_ERROR.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="session"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="_CamelSession*"/>
        </parameter>
        <parameter name="get_message"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve">function to retrieve the message if necessary</doc>
          <type name="FilterSearchGetMessageFunc"
                c:type="CamelFilterSearchGetMessageFunc"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">data for above</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="folder"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">in which folder the message is stored</doc>
          <type name="gpointer" c:type="_CamelFolder*"/>
        </parameter>
        <parameter name="expression" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_search_match_with_log"
              c:identifier="camel_filter_search_match_with_log"
              introspectable="0"
              throws="1">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">one of CAMEL_SEARCH_MATCHED, CAMEL_SEARCH_NOMATCH, or
CAMEL_SEARCH_ERROR.

Since 3.24</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="session"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="_CamelSession*"/>
        </parameter>
        <parameter name="get_message"
                   transfer-ownership="none"
                   scope="async"
                   closure="2">
          <doc xml:space="preserve">function to retrieve the message if necessary</doc>
          <type name="FilterSearchGetMessageFunc"
                c:type="CamelFilterSearchGetMessageFunc"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">data for above</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <type name="MessageInfo" c:type="CamelMessageInfo*"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="folder"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">in which folder the message is stored</doc>
          <type name="gpointer" c:type="_CamelFolder*"/>
        </parameter>
        <parameter name="expression" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="logfile"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">an optional log file to write logging information to, or %NULL</doc>
          <type name="gpointer" c:type="FILE*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="folder_info_build"
              c:identifier="camel_folder_info_build"
              moved-to="FolderInfo.build">
      <doc xml:space="preserve">This takes an array of folders and attaches them together according
to the hierarchy described by their full_names and @separator. If
@namespace_ is non-%NULL, then it will be ignored as a full_name
prefix, for purposes of comparison. If necessary,
camel_folder_info_build() will create additional #CamelFolderInfo with
%NULL urls to fill in gaps in the tree. The value of @short_names
is used in constructing the names of these intermediate folders.

NOTE: This is deprected, do not use this.
FIXME: remove this/move it to imap, which is the only user of it now.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the top level of the tree of linked folder info.</doc>
        <type name="FolderInfo" c:type="CamelFolderInfo*"/>
      </return-value>
      <parameters>
        <parameter name="folders" transfer-ownership="none">
          <doc xml:space="preserve">an array of #CamelFolderInfo</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="FolderInfo"/>
          </array>
        </parameter>
        <parameter name="namespace_" transfer-ownership="none">
          <doc xml:space="preserve">an ignorable prefix on the folder names</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="separator" transfer-ownership="none">
          <doc xml:space="preserve">the hieararchy separator character</doc>
          <type name="gchar" c:type="gchar"/>
        </parameter>
        <parameter name="short_names" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the (short) name of a folder is the part after
the last @separator in the full name. %FALSE if it is the full name.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="freeaddrinfo"
              c:identifier="camel_freeaddrinfo"
              version="2.22">
      <doc xml:space="preserve">Frees a structure returned with camel_getaddrinfo(). It does
nothing when the @host is %NULL.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="host"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a host address information structure to free, or %NULL</doc>
          <type name="gpointer" c:type="addrinfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="getaddrinfo"
              c:identifier="camel_getaddrinfo"
              version="2.22"
              throws="1">
      <doc xml:space="preserve">Resolves a host @name and returns an information about its address.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly allocated #addrinfo. Free it
   with camel_freeaddrinfo() when done with it.</doc>
        <type name="gpointer" c:type="addrinfo*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">an address name to resolve</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="service" transfer-ownership="none">
          <doc xml:space="preserve">a service name to use</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="hints"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">an #addrinfo hints, or %NULL</doc>
          <type name="gpointer" c:type="const addrinfo*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_address_decode"
              c:identifier="camel_header_address_decode"
              moved-to="HeaderAddress.decode">
      <return-value transfer-ownership="full">
        <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="charset" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_address_fold"
              c:identifier="camel_header_address_fold"
              moved-to="HeaderAddress.fold">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="headerlen" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_address_list_append"
              c:identifier="camel_header_address_list_append"
              moved-to="HeaderAddress.list_append">
      <doc xml:space="preserve">TODO: Document me.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="addrlistp" transfer-ownership="none">
          <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
          <array c:type="CamelHeaderAddress**">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </array>
        </parameter>
        <parameter name="addr" transfer-ownership="none">
          <doc xml:space="preserve">the #CamelHeaderAddress to add</doc>
          <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_address_list_append_list"
              c:identifier="camel_header_address_list_append_list"
              moved-to="HeaderAddress.list_append_list">
      <doc xml:space="preserve">TODO: Document me.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="addrlistp" transfer-ownership="none">
          <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
          <array c:type="CamelHeaderAddress**">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </array>
        </parameter>
        <parameter name="addrs" transfer-ownership="none">
          <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress to add</doc>
          <array c:type="CamelHeaderAddress**">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="header_address_list_clear"
              c:identifier="camel_header_address_list_clear"
              moved-to="HeaderAddress.list_clear">
      <doc xml:space="preserve">TODO: Document me.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="addrlistp" transfer-ownership="none">
          <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
          <array c:type="CamelHeaderAddress**">
            <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="header_address_list_encode"
              c:identifier="camel_header_address_list_encode"
              moved-to="HeaderAddress.list_encode">
      <doc xml:space="preserve">TODO: Document me.</doc>
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="addrlist" transfer-ownership="none">
          <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
          <array c:type="CamelHeaderAddress*">
            <type name="HeaderAddress" c:type="CamelHeaderAddress"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="header_address_list_format"
              c:identifier="camel_header_address_list_format"
              moved-to="HeaderAddress.list_format">
      <doc xml:space="preserve">TODO: Document me.</doc>
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="addrlist" transfer-ownership="none">
          <doc xml:space="preserve">a NULL-terminated list of #CamelHeaderAddress objects</doc>
          <array c:type="CamelHeaderAddress*">
            <type name="HeaderAddress" c:type="CamelHeaderAddress"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="header_contentid_decode"
              c:identifier="camel_header_contentid_decode">
      <doc xml:space="preserve">Extract a content-id from @in.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the extracted content-id</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_decode_date"
              c:identifier="camel_header_decode_date">
      <doc xml:space="preserve">Decodes the rfc822 date string and saves the GMT offset into
@tz_offset if non-NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the time_t representation of the date string specified by
@str or (time_t) %0 on error. If @tz_offset is non-NULL, the value
of the timezone offset will be stored.</doc>
        <type name="glong" c:type="time_t"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">input date string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="tz_offset" transfer-ownership="none">
          <doc xml:space="preserve">timezone offset</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_decode_int" c:identifier="camel_header_decode_int">
      <doc xml:space="preserve">Extracts an integer token from @in and updates the pointer to point
to after the end of the integer token (sort of like strtol).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the gint value</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">pointer to input string</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_decode_string"
              c:identifier="camel_header_decode_string">
      <doc xml:space="preserve">Decodes rfc2047 encoded-word tokens</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a string containing the UTF-8 version of the decoded header
value</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input header value string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_charset" transfer-ownership="none">
          <doc xml:space="preserve">default charset to use if improperly encoded</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_encode_phrase"
              c:identifier="camel_header_encode_phrase">
      <doc xml:space="preserve">Encodes a 'phrase' header according to the rules in rfc2047.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded 'phrase'</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">header to encode</doc>
          <type name="guint8" c:type="const guchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_encode_string"
              c:identifier="camel_header_encode_string">
      <doc xml:space="preserve">Encodes a 'text' header according to the rules of rfc2047.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the rfc2047 encoded header</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input string</doc>
          <type name="guint8" c:type="const guchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_fold" c:identifier="camel_header_fold">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="headerlen" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_format_ctext"
              c:identifier="camel_header_format_ctext">
      <doc xml:space="preserve">Decodes a header which contains rfc2047 encoded-word tokens that
may or may not be within a comment.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a string containing the UTF-8 version of the decoded header
value</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input header value string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_charset" transfer-ownership="none">
          <doc xml:space="preserve">default charset to use if improperly encoded</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_format_date"
              c:identifier="camel_header_format_date">
      <doc xml:space="preserve">Allocates a string buffer containing the rfc822 formatted date
string represented by @time and @tz_offset.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a valid string representation of the date.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="date" transfer-ownership="none">
          <doc xml:space="preserve">time_t date representation</doc>
          <type name="glong" c:type="time_t"/>
        </parameter>
        <parameter name="tz_offset" transfer-ownership="none">
          <doc xml:space="preserve">Timezone offset</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_location_decode"
              c:identifier="camel_header_location_decode">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_mailbox_decode"
              c:identifier="camel_header_mailbox_decode">
      <return-value transfer-ownership="full">
        <type name="HeaderAddress" c:type="CamelHeaderAddress*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="charset" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_mime_decode"
              c:identifier="camel_header_mime_decode">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="maj" transfer-ownership="none">
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="min" transfer-ownership="none">
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_msgid_decode"
              c:identifier="camel_header_msgid_decode">
      <doc xml:space="preserve">Extract a message-id token from @in.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the msg-id</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_msgid_generate"
              c:identifier="camel_header_msgid_generate">
      <doc xml:space="preserve">Either the @domain is used, or the user's local hostname,
in case it's NULL or empty.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Unique message ID.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve">domain to use (like "example.com") for the ID suffix; can be NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_newsgroups_decode"
              c:identifier="camel_header_newsgroups_decode">
      <return-value transfer-ownership="full">
        <type name="GLib.SList" c:type="GSList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_param" c:identifier="camel_header_param">
      <doc xml:space="preserve">Searches @params for a param named @name and gets the value.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the value of the @name param</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="params"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">parameters</doc>
          <type name="gpointer" c:type="_camel_header_param*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of param to find</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_param_list_decode"
              c:identifier="camel_header_param_list_decode"
              moved-to="HeaderParam.list_decode">
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">Decode list of parameters.
   Free with camel_header_param_list_free() when done with it.</doc>
        <type name="gpointer" c:type="_camel_header_param*"/>
      </return-value>
      <parameters>
        <parameter name="in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a header param value to decode</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_param_list_format"
              c:identifier="camel_header_param_list_format"
              moved-to="HeaderParam.list_format">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="params"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="_camel_header_param*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_param_list_format_append"
              c:identifier="camel_header_param_list_format_append"
              moved-to="HeaderParam.list_format_append">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="out" transfer-ownership="none">
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="params"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="_camel_header_param*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_param_list_free"
              c:identifier="camel_header_param_list_free"
              moved-to="HeaderParam.list_free">
      <doc xml:space="preserve">Free the list of params.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="params"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a list of params</doc>
          <type name="gpointer" c:type="_camel_header_param*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_references_decode"
              c:identifier="camel_header_references_decode">
      <doc xml:space="preserve">Generate a list of references, from most recent up.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a list of references decoedd from @in</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">References header value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_set_param" c:identifier="camel_header_set_param">
      <doc xml:space="preserve">Set a parameter in the list.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the set param</doc>
        <type name="gpointer" c:type="_camel_header_param*"/>
      </return-value>
      <parameters>
        <parameter name="paramsp"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">poinetr to a list of params</doc>
          <type name="gpointer" c:type="_camel_header_param**"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of param to set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">value to set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_token_decode"
              c:identifier="camel_header_token_decode">
      <doc xml:space="preserve">Gets the first token in the string according to the rules of
rfc0822.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new string containing the first token in @in</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="header_unfold" c:identifier="camel_header_unfold">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="headers_dup_mailing_list"
              c:identifier="camel_headers_dup_mailing_list">
      <doc xml:space="preserve">Searches for a mailing list information among known headers and returns
a newly allocated string with its value.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">The mailing list header, or %NULL, if none is found</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="headers" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelNameValueArray with headers</doc>
          <type name="NameValueArray" c:type="const CamelNameValueArray*"/>
        </parameter>
      </parameters>
    </function>
    <function name="host_idna_to_ascii"
              c:identifier="camel_host_idna_to_ascii"
              version="3.16">
      <doc xml:space="preserve">Converts IDN (Internationalized Domain Name) into ASCII representation.
If there's a failure or the @host has only ASCII letters, then a copy
of @host is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Newly allocated string with only ASCII letters describing the @host.
  Free it with g_free() when done with it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="host" transfer-ownership="none">
          <doc xml:space="preserve">Host name, with or without non-ascii letters in utf8</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="iconv" c:identifier="camel_iconv">
      <return-value transfer-ownership="none">
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="cd" transfer-ownership="none">
          <type name="GLib.IConv" c:type="GIConv"/>
        </parameter>
        <parameter name="inbuf" transfer-ownership="none">
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
        <parameter name="inleft" transfer-ownership="none">
          <type name="gsize" c:type="gsize*"/>
        </parameter>
        <parameter name="outbuf" transfer-ownership="none">
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="outleft" transfer-ownership="none">
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="iconv_charset_language"
              c:identifier="camel_iconv_charset_language">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="charset" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="iconv_charset_name"
              c:identifier="camel_iconv_charset_name">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="charset" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="iconv_close" c:identifier="camel_iconv_close">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cd" transfer-ownership="none">
          <type name="GLib.IConv" c:type="GIConv"/>
        </parameter>
      </parameters>
    </function>
    <function name="iconv_locale_charset"
              c:identifier="camel_iconv_locale_charset">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="iconv_locale_language"
              c:identifier="camel_iconv_locale_language">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="iconv_open"
              c:identifier="camel_iconv_open"
              introspectable="0">
      <return-value>
        <doc xml:space="preserve">a #GIConv for the conversion from charset @from to charset @to, or (GIConv) -1 on error.</doc>
        <type name="GLib.IConv" c:type="GIConv"/>
      </return-value>
      <parameters>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">charset to convert to</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">charset to covert from</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="camel_init">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="certdb_dir" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nss_init" transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="localtime_with_offset"
              c:identifier="camel_localtime_with_offset">
      <doc xml:space="preserve">Converts the calendar time representation @tt to a broken-down
time representation, stored in @tm, and provides the offset in
seconds from UTC time, stored in @offset.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="tt" transfer-ownership="none">
          <doc xml:space="preserve">the #time_t to convert</doc>
          <type name="glong" c:type="time_t"/>
        </parameter>
        <parameter name="tm"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the #tm to store the result in</doc>
          <type name="gpointer" c:type="tm*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">the #gint to store the offset in</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="lock_dot" c:identifier="camel_lock_dot" throws="1">
      <doc xml:space="preserve">Create an exclusive lock using .lock semantics.
All locks are equivalent to write locks (exclusive).

The function does nothing and returns success (zero),
when dot locking had not been compiled.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1 on error, sets @ex appropriately.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">a path to lock</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="lock_fcntl" c:identifier="camel_lock_fcntl" throws="1">
      <doc xml:space="preserve">Create a lock using fcntl(2).

@type is CAMEL_LOCK_WRITE or CAMEL_LOCK_READ,
to create exclusive or shared read locks

The function does nothing and returns success (zero),
when fcntl locking had not been compiled.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelLockType</doc>
          <type name="LockType" c:type="CamelLockType"/>
        </parameter>
      </parameters>
    </function>
    <function name="lock_flock" c:identifier="camel_lock_flock" throws="1">
      <doc xml:space="preserve">Create a lock using flock(2).

@type is CAMEL_LOCK_WRITE or CAMEL_LOCK_READ,
to create exclusive or shared read locks

The function does nothing and returns success (zero),
when flock locking had not been compiled.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1 on error.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelLockType</doc>
          <type name="LockType" c:type="CamelLockType"/>
        </parameter>
      </parameters>
    </function>
    <function name="lock_folder" c:identifier="camel_lock_folder" throws="1">
      <doc xml:space="preserve">Attempt to lock a folder, multiple attempts will be made using all
locking strategies available.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">-1 on error, @ex will describe the locking system that failed.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Path to the file to lock (used for .locking only).</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">Open file descriptor of the right type to lock.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">Type of lock, CAMEL_LOCK_READ or CAMEL_LOCK_WRITE.</doc>
          <type name="LockType" c:type="CamelLockType"/>
        </parameter>
      </parameters>
    </function>
    <function name="lock_helper_lock"
              c:identifier="camel_lock_helper_lock"
              throws="1">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="lock_helper_unlock"
              c:identifier="camel_lock_helper_unlock">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="lockid" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="memchunk_alloc"
              c:identifier="camel_memchunk_alloc"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Allocate a new atom size block of memory from an #CamelMemChunk.
Free the returned atom with camel_memchunk_free().</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">an allocated block of memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="memchunk" transfer-ownership="none">
          <doc xml:space="preserve">an #CamelMemChunk</doc>
          <type name="MemChunk" c:type="CamelMemChunk*"/>
        </parameter>
      </parameters>
    </function>
    <function name="memchunk_alloc0"
              c:identifier="camel_memchunk_alloc0"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Allocate a new atom size block of memory from an #CamelMemChunk,
and fill the memory with zeros.  Free the returned atom with
camel_memchunk_free().</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">an allocated block of memory</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="memchunk" transfer-ownership="none">
          <doc xml:space="preserve">an #CamelMemChunk</doc>
          <type name="MemChunk" c:type="CamelMemChunk*"/>
        </parameter>
      </parameters>
    </function>
    <function name="memchunk_clean"
              c:identifier="camel_memchunk_clean"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Scan all empty blocks and check for blocks which can be free'd
back to the system.

This routine may take a while to run if there are many allocated
memory blocks (if the total number of allocations is many times
greater than atomcount).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="memchunk" transfer-ownership="none">
          <doc xml:space="preserve">an #CamelMemChunk</doc>
          <type name="MemChunk" c:type="CamelMemChunk*"/>
        </parameter>
      </parameters>
    </function>
    <function name="memchunk_destroy"
              c:identifier="camel_memchunk_destroy"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Free the memchunk header, and all associated memory.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="memchunk" transfer-ownership="none">
          <doc xml:space="preserve">an #CamelMemChunk</doc>
          <type name="MemChunk" c:type="CamelMemChunk*"/>
        </parameter>
      </parameters>
    </function>
    <function name="memchunk_empty"
              c:identifier="camel_memchunk_empty"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Clean out the memchunk buffers.  Marks all allocated memory as free blocks,
but does not give it back to the system.  Can be used if the memchunk
is to be used repeatedly.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="memchunk" transfer-ownership="none">
          <doc xml:space="preserve">an #CamelMemChunk</doc>
          <type name="MemChunk" c:type="CamelMemChunk*"/>
        </parameter>
      </parameters>
    </function>
    <function name="memchunk_free"
              c:identifier="camel_memchunk_free"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Free a single atom back to the free pool of atoms in the given
memchunk.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="memchunk" transfer-ownership="none">
          <doc xml:space="preserve">an #CamelMemChunk</doc>
          <type name="MemChunk" c:type="CamelMemChunk*"/>
        </parameter>
        <parameter name="mem"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">address of atom to free</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="memchunk_new"
              c:identifier="camel_memchunk_new"
              version="3.4"
              introspectable="0">
      <doc xml:space="preserve">Create a new #CamelMemChunk header.  Memchunks are an efficient way to
allocate and deallocate identical sized blocks of memory quickly, and
space efficiently.

camel_memchunks are effectively the same as gmemchunks, only faster (much),
and they use less memory overhead for housekeeping.</doc>
      <return-value>
        <doc xml:space="preserve">a new #CamelMemChunk</doc>
        <type name="MemChunk" c:type="CamelMemChunk*"/>
      </return-value>
      <parameters>
        <parameter name="atomcount" transfer-ownership="none">
          <doc xml:space="preserve">the number of atoms stored in a single malloc'd block of memory</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="atomsize" transfer-ownership="none">
          <doc xml:space="preserve">the size of each allocation</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="mempool_alloc"
              c:identifier="camel_mempool_alloc"
              version="2.32"
              introspectable="0">
      <doc xml:space="preserve">Allocate a new data block in the mempool.  Size will
be rounded up to the mempool's alignment restrictions
before being used.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="pool" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMemPool</doc>
          <type name="MemPool" c:type="CamelMemPool*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">requested size to allocate</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="mempool_destroy"
              c:identifier="camel_mempool_destroy"
              version="2.32"
              introspectable="0">
      <doc xml:space="preserve">Free all memory associated with a mempool.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pool" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMemPool</doc>
          <type name="MemPool" c:type="CamelMemPool*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mempool_flush"
              c:identifier="camel_mempool_flush"
              version="2.32"
              introspectable="0">
      <doc xml:space="preserve">Flush used memory and mark allocated blocks as free.

If @freeall is %TRUE, then all allocated blocks are free'd
as well.  Otherwise only blocks above the threshold are
actually freed, and the others are simply marked as empty.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pool" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMemPool</doc>
          <type name="MemPool" c:type="CamelMemPool*"/>
        </parameter>
        <parameter name="freeall" transfer-ownership="none">
          <doc xml:space="preserve">free all system allocated blocks as well</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="mempool_new"
              c:identifier="camel_mempool_new"
              version="2.32"
              introspectable="0">
      <doc xml:space="preserve">Create a new mempool header.  Mempools can be used to efficiently
allocate data which can then be freed as a whole.

Mempools can also be used to efficiently allocate arbitrarily
aligned data (such as strings) without incurring the space overhead
of aligning each allocation (which is not required for strings).

However, each allocation cannot be freed individually, only all
or nothing.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #CamelMemPool</doc>
        <type name="MemPool" c:type="CamelMemPool*"/>
      </return-value>
      <parameters>
        <parameter name="blocksize" transfer-ownership="none">
          <doc xml:space="preserve">The base blocksize to use for all system alocations.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="threshold" transfer-ownership="none">
          <doc xml:space="preserve">If the allocation exceeds the threshold, then it is
allocated separately and stored in a separate list.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">Alignment options: CAMEL_MEMPOOL_ALIGN_STRUCT uses native
struct alignment, CAMEL_MEMPOOL_ALIGN_WORD aligns to 16 bits (2 bytes),
and CAMEL_MEMPOOL_ALIGN_BYTE aligns to the nearest byte.  The default
is to align to native structures.</doc>
          <type name="MemPoolFlags" c:type="CamelMemPoolFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="mempool_strdup"
              c:identifier="camel_mempool_strdup"
              version="2.32"
              introspectable="0">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="pool" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMemPool</doc>
          <type name="MemPool" c:type="CamelMemPool*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mktime_utc" c:identifier="camel_mktime_utc" version="3.4">
      <doc xml:space="preserve">Like mktime(3), but assumes UTC instead of local timezone.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the calendar time representation of @tm</doc>
        <type name="glong" c:type="time_t"/>
      </return-value>
      <parameters>
        <parameter name="tm"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the #tm to convert to a calendar time representation</doc>
          <type name="gpointer" c:type="tm*"/>
        </parameter>
      </parameters>
    </function>
    <function name="movemail" c:identifier="camel_movemail" throws="1">
      <doc xml:space="preserve">This copies an mbox file from a shared directory with multiple
readers and writers into a private (presumably Camel-controlled)
directory. Dot locking is used on the source file (but not the
destination).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Returns -1 on error or 0 on success.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">source file</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">destination file</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_destroy"
              c:identifier="camel_msgport_destroy"
              version="2.24"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msgport" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsgPort</doc>
          <type name="MsgPort" c:type="CamelMsgPort*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_fd"
              c:identifier="camel_msgport_fd"
              version="2.24"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="msgport" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsgPort</doc>
          <type name="MsgPort" c:type="CamelMsgPort*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_new"
              c:identifier="camel_msgport_new"
              version="2.24"
              introspectable="0">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #CamelMsgPort</doc>
        <type name="MsgPort" c:type="CamelMsgPort*"/>
      </return-value>
    </function>
    <function name="msgport_pop"
              c:identifier="camel_msgport_pop"
              version="2.24"
              introspectable="0">
      <return-value>
        <type name="Msg" c:type="CamelMsg*"/>
      </return-value>
      <parameters>
        <parameter name="msgport" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsgPort</doc>
          <type name="MsgPort" c:type="CamelMsgPort*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_prfd"
              c:identifier="camel_msgport_prfd"
              version="2.24"
              introspectable="0">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="PRFileDesc*"/>
      </return-value>
      <parameters>
        <parameter name="msgport" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsgPort</doc>
          <type name="MsgPort" c:type="CamelMsgPort*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_push"
              c:identifier="camel_msgport_push"
              version="2.24"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msgport" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsgPort</doc>
          <type name="MsgPort" c:type="CamelMsgPort*"/>
        </parameter>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsg</doc>
          <type name="Msg" c:type="CamelMsg*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_reply"
              c:identifier="camel_msgport_reply"
              version="2.24"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="msg" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsg</doc>
          <type name="Msg" c:type="CamelMsg*"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_timeout_pop"
              c:identifier="camel_msgport_timeout_pop"
              version="3.8"
              introspectable="0">
      <return-value>
        <type name="Msg" c:type="CamelMsg*"/>
      </return-value>
      <parameters>
        <parameter name="msgport" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsgPort</doc>
          <type name="MsgPort" c:type="CamelMsgPort*"/>
        </parameter>
        <parameter name="timeout" transfer-ownership="none">
          <doc xml:space="preserve">number of microseconds to wait</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="msgport_try_pop"
              c:identifier="camel_msgport_try_pop"
              version="2.24"
              introspectable="0">
      <return-value>
        <type name="Msg" c:type="CamelMsg*"/>
      </return-value>
      <parameters>
        <parameter name="msgport" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMsgPort</doc>
          <type name="MsgPort" c:type="CamelMsgPort*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_bag_new"
              c:identifier="camel_object_bag_new"
              moved-to="ObjectBag.new"
              introspectable="0">
      <doc xml:space="preserve">Returns a new object bag.  Object bags are keyed hash tables of objects
that can be updated atomically using transaction semantics.  Use
camel_object_bag_destroy() to free the object bag.</doc>
      <return-value>
        <doc xml:space="preserve">a newly-allocated #CamelObjectBag</doc>
        <type name="ObjectBag" c:type="CamelObjectBag*"/>
      </return-value>
      <parameters>
        <parameter name="key_hash_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve">a hashing function for keys</doc>
          <type name="GLib.HashFunc" c:type="GHashFunc"/>
        </parameter>
        <parameter name="key_equal_func"
                   transfer-ownership="none"
                   scope="call">
          <doc xml:space="preserve">a comparison function for keys</doc>
          <type name="GLib.EqualFunc" c:type="GEqualFunc"/>
        </parameter>
        <parameter name="key_copy_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve">a function to copy keys</doc>
          <type name="CopyFunc" c:type="CamelCopyFunc"/>
        </parameter>
        <parameter name="key_free_func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve">a function to free keys</doc>
          <type name="GLib.FreeFunc" c:type="GFreeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_tracker_dump"
              c:identifier="camel_pointer_tracker_dump"
              version="3.6">
      <doc xml:space="preserve">Prints information about currently stored pointers
in the pointer tracker. This is called automatically
on application exit if camel_pointer_tracker_track() or
camel_pointer_tracker_track_with_info() was called.

Note: If the library is configured with --enable-backtraces,
then also backtraces where the pointer was added is printed
in the summary.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pointer_tracker_track_with_info"
              c:identifier="camel_pointer_tracker_track_with_info"
              version="3.6">
      <doc xml:space="preserve">Adds pointer to the pointer tracker, with associated information,
which is printed in summary of pointer tracker printed by
camel_pointer_tracker_dump(). For convenience can be used
camel_pointer_tracker_track(), which adds place of the caller
as @info. Added pointer should be removed with pair function
camel_pointer_tracker_untrack().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to add to the pointer tracker</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">info to print in tracker summary</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pointer_tracker_untrack"
              c:identifier="camel_pointer_tracker_untrack"
              version="3.6">
      <doc xml:space="preserve">Removes pointer from the pointer tracker. It's an error to try
to remove pointer which was not added to the tracker by
camel_pointer_tracker_track() or camel_pointer_tracker_track_with_info(),
or a pointer which was already removed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to remove from the tracker</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="provider_get"
              c:identifier="camel_provider_get"
              moved-to="Provider.get"
              throws="1">
      <doc xml:space="preserve">Returns the registered #CamelProvider for @protocol, loading it
from disk if necessary.  If no #CamelProvider can be found for
@protocol, or the provider module fails to load, the function
sets @error and returns %NULL.

The returned #CamelProvider is owned by Camel and should not be
modified or freed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #CamelProvider for %protocol, or %NULL</doc>
        <type name="Provider" c:type="CamelProvider*"/>
      </return-value>
      <parameters>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelProvider protocol name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="provider_init"
              c:identifier="camel_provider_init"
              moved-to="Provider.init">
      <doc xml:space="preserve">Initialize the Camel provider system by reading in the .urls
files in the provider directory and creating a hash table mapping
URLs to module names.

A .urls file has the same initial prefix as the shared library it
correspond to, and consists of a series of lines containing the URL
protocols that that library handles.

TODO: This should be pathed?
TODO: This should be plugin-d?</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="provider_list"
              c:identifier="camel_provider_list"
              moved-to="Provider.list">
      <doc xml:space="preserve">This returns a list of available providers. If @load is %TRUE, it will
first load in all available providers that haven't yet been loaded.

Free the returned list with g_list_free().  The #CamelProvider structs
in the list are owned by Camel and should not be modified or freed.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a #GList of #CamelProvider structs</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Provider"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="load" transfer-ownership="none">
          <doc xml:space="preserve">whether or not to load in providers that are not already loaded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="provider_load"
              c:identifier="camel_provider_load"
              moved-to="Provider.load"
              throws="1">
      <doc xml:space="preserve">Loads the provider at @path, and calls its initialization function,
passing @session as an argument. The provider should then register
itself with @session.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the path to a shared library</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="provider_module_init"
              c:identifier="camel_provider_module_init"
              moved-to="ProviderModule.init">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pstring_add" c:identifier="camel_pstring_add">
      <doc xml:space="preserve">Add @string to the pool.

The %NULL and empty strings are special cased to constant values.

Unreference the returned string with camel_pstring_free().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a canonicalized copy of @string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">string to add to the string pool</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="own" transfer-ownership="none">
          <doc xml:space="preserve">whether the string pool will own the memory pointed to by
      @string, if @string is not yet in the pool</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="pstring_contains"
              c:identifier="camel_pstring_contains"
              version="3.22">
      <doc xml:space="preserve">Returns whether the @string exists in the string pool.

The %NULL and empty strings are special cased to constant values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the @string exists in the string pool</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">string to look up in the string pool</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pstring_dump_stat"
              c:identifier="camel_pstring_dump_stat"
              version="3.6">
      <doc xml:space="preserve">Dumps to stdout memory statistic about the string pool.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pstring_free" c:identifier="camel_pstring_free">
      <doc xml:space="preserve">Unreferences a pooled string.  If the string's reference count drops to
zero it will be deallocated.  %NULL and the empty string are special cased.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">string to free</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pstring_peek"
              c:identifier="camel_pstring_peek"
              version="2.24">
      <doc xml:space="preserve">Returns the canonicalized copy of @string without increasing its
reference count in the string pool.  If necessary, @string is first
added to the string pool.

The %NULL and empty strings are special cased to constant values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a canonicalized copy of @string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">string to fetch from the string pool</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pstring_strdup" c:identifier="camel_pstring_strdup">
      <doc xml:space="preserve">Create a new pooled string entry for @strings.  A pooled string
is a table where common strings are canonicalized.  They are also
reference counted and freed when no longer referenced.

The %NULL and empty strings are special cased to constant values.

Unreference the returned string with camel_pstring_free().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a canonicalized copy of @string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:space="preserve">string to copy</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="quoted_decode_step"
              c:identifier="camel_quoted_decode_step">
      <doc xml:space="preserve">Decodes a block of quoted-printable encoded data. Performs a
'decode step' on a chunk of QP encoded data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes decoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input stream</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">max length of data to decode</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output stream</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="savestate"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">holds the number of bits that are stored in @saveme</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="saveme"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">leftover bits that have not yet been decoded</doc>
          <array length="3" zero-terminated="0" c:type="gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="quoted_encode_close"
              c:identifier="camel_quoted_encode_close">
      <doc xml:space="preserve">Quoted-printable encodes a block of text. Call this when finished
encoding data with camel_quoted_encode_step() to flush off
the last little bit.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes encoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input stream</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the input</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output string</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">holds the number of bits that are stored in @save</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">leftover bits that have not yet been encoded</doc>
          <array length="3" zero-terminated="0" c:type="gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="quoted_encode_step"
              c:identifier="camel_quoted_encode_step">
      <doc xml:space="preserve">Quoted-printable encodes a block of text. Performs an 'encode
step', saves left-over state in state and save (initialise to -1 on
first invocation).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes encoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input stream</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the input</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output string</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">holds the number of bits that are stored in @save</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">leftover bits that have not yet been encoded</doc>
          <array length="3" zero-terminated="0" c:type="gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="read" c:identifier="camel_read" throws="1">
      <doc xml:space="preserve">Cancellable libc read() replacement.

Code that intends to be portable to Win32 should call this function
only on file descriptors returned from open(), not on sockets.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of bytes read or -1 on fail. On failure, errno will
be set appropriately.</doc>
        <type name="gssize" c:type="gssize"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">buffer to fill</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes to read into @buf</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_build_match_regex"
              c:identifier="camel_search_build_match_regex"
              introspectable="0"
              throws="1">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="pattern" transfer-ownership="none">
          <type c:type="regex_t*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <type name="_search_flags_t" c:type="camel_search_flags_t"/>
        </parameter>
        <parameter name="argc" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="argv" transfer-ownership="none">
          <type name="SExpResult" c:type="CamelSExpResult**"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_camel_header_soundex"
              c:identifier="camel_search_camel_header_soundex">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="header" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_get_all_headers_decoded"
              c:identifier="camel_search_get_all_headers_decoded"
              version="3.22">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">All headers of the @message, decoded where needed.
   Free the returned pointer with g_free() when done with it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMessage</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_get_default_charset_from_message"
              c:identifier="camel_search_get_default_charset_from_message"
              version="3.22">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Default charset of the @message; if none cannot be determined,
   UTF-8 is returned.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelMimeMessage</doc>
          <type name="MimeMessage" c:type="CamelMimeMessage*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_get_header_decoded"
              c:identifier="camel_search_get_header_decoded"
              version="3.22">
      <doc xml:space="preserve">Decodes @header_value, if needed, either from an address header
or the Subject header. Other @header_name headers are returned
as is.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">decoded header value, suitable for text comparison.
   Free the returned pointer with g_free() when done with it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="header_name" transfer-ownership="none">
          <doc xml:space="preserve">the header name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="header_value" transfer-ownership="none">
          <doc xml:space="preserve">the header value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_charset"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the default charset to use for the decode, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_header_is_address"
              c:identifier="camel_search_header_is_address"
              version="3.22">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Whether the @header_name is a header with a mail address</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="header_name" transfer-ownership="none">
          <doc xml:space="preserve">A header name, like "Subject"</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_header_match"
              c:identifier="camel_search_header_match">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="how" transfer-ownership="none">
          <type name="_search_match_t" c:type="camel_search_match_t"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <type name="_search_t" c:type="camel_search_t"/>
        </parameter>
        <parameter name="default_charset" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_message_body_contains"
              c:identifier="camel_search_message_body_contains"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <type name="DataWrapper" c:type="CamelDataWrapper*"/>
        </parameter>
        <parameter name="pattern" transfer-ownership="none">
          <type c:type="regex_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_words_free" c:identifier="camel_search_words_free">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="words"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="_camel_search_words*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_words_simple"
              c:identifier="camel_search_words_simple">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="_camel_search_words*"/>
      </return-value>
      <parameters>
        <parameter name="words"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="_camel_search_words*"/>
        </parameter>
      </parameters>
    </function>
    <function name="search_words_split"
              c:identifier="camel_search_words_split">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="_camel_search_words*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="guint8" c:type="const guchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shutdown" c:identifier="camel_shutdown" version="2.24">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="store_info_name"
              c:identifier="camel_store_info_name"
              moved-to="StoreInfo.name">
      <doc xml:space="preserve">Returns the last segment of the path string from @info.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the last segment of the path string from @info</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="summary" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelStoreSummary</doc>
          <type name="StoreSummary" c:type="CamelStoreSummary*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelStoreInfo</doc>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="store_info_path"
              c:identifier="camel_store_info_path"
              moved-to="StoreInfo.path">
      <doc xml:space="preserve">Returns the path string from @info.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the path string from @info</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="summary" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelStoreSummary</doc>
          <type name="StoreSummary" c:type="CamelStoreSummary*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelStoreInfo</doc>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="store_info_set_string"
              c:identifier="camel_store_info_set_string"
              moved-to="StoreInfo.set_string">
      <doc xml:space="preserve">Set a specific string on the @info.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="summary" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelStoreSummary object</doc>
          <type name="StoreSummary" c:type="CamelStoreSummary*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelStoreInfo</doc>
          <type name="StoreInfo" c:type="CamelStoreInfo*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">specific string being set</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">string value to set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strcase_equal" c:identifier="camel_strcase_equal">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="b"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="strcase_hash" c:identifier="camel_strcase_hash">
      <return-value transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="v"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="strdown" c:identifier="camel_strdown">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="strstrcase" c:identifier="camel_strstrcase">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="needle" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="system_flag" c:identifier="camel_system_flag">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the integer value of the system flag string</doc>
        <type name="MessageFlags" c:type="CamelMessageFlags"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of a system flag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="system_flag_get" c:identifier="camel_system_flag_get">
      <doc xml:space="preserve">Find the state of the flag @name in @flags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the named flag is set or %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">bitwise system flags</doc>
          <type name="MessageFlags" c:type="CamelMessageFlags"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of the flag to check for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_to_html" c:identifier="camel_text_to_html">
      <doc xml:space="preserve">Convert @in from plain text into HTML.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing the HTMLified version
of @in</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input text</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">bitwise flags defining the html conversion behaviour</doc>
          <type name="MimeFilterToHTMLFlags"
                c:type="CamelMimeFilterToHTMLFlags"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">color to use when syntax highlighting</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="time_value_apply"
              c:identifier="camel_time_value_apply"
              version="3.24">
      <doc xml:space="preserve">Applies the given time @value in unit @unit to the @src_time.
Use negative value to subtract it. The time part is rounded
to the beginning of the day.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@src_time modified by the given parameters as date, with
   the time part being beginning of the day.</doc>
        <type name="glong" c:type="time_t"/>
      </return-value>
      <parameters>
        <parameter name="src_time" transfer-ownership="none">
          <doc xml:space="preserve">a time_t to apply the value to, or -1 to use the current time</doc>
          <type name="glong" c:type="time_t"/>
        </parameter>
        <parameter name="unit" transfer-ownership="none">
          <doc xml:space="preserve">a #CamelTimeUnit</doc>
          <type name="TimeUnit" c:type="CamelTimeUnit"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a value to apply</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="transfer_encoding_from_string"
              c:identifier="camel_transfer_encoding_from_string"
              moved-to="TransferEncoding.from_string">
      <return-value transfer-ownership="none">
        <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="transfer_encoding_to_string"
              c:identifier="camel_transfer_encoding_to_string"
              moved-to="TransferEncoding.to_string">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="encoding" transfer-ownership="none">
          <type name="TransferEncoding" c:type="CamelTransferEncoding"/>
        </parameter>
      </parameters>
    </function>
    <function name="trie_new"
              c:identifier="camel_trie_new"
              moved-to="Trie.new"
              version="2.24"
              introspectable="0">
      <doc xml:space="preserve">Creates a new #CamelTrie. If @icase is %TRUE, then pattern matching
done by the CamelTrie will be case insensitive.</doc>
      <return-value>
        <doc xml:space="preserve">The newly-created #CamelTrie.</doc>
        <type name="Trie" c:type="CamelTrie*"/>
      </return-value>
      <parameters>
        <parameter name="icase" transfer-ownership="none">
          <doc xml:space="preserve">Case sensitivity for the #CamelTrie.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="ucs2_utf8" c:identifier="camel_ucs2_utf8">
      <doc xml:space="preserve">Convert a ucs2 string into a UTF-8 one. The ucs2 string is treated
as network byte ordered, and terminated with a 16-bit %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The converted string. Free it with g_free(),
   when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="ptr" transfer-ownership="none">
          <doc xml:space="preserve">a ucs2 string to convert</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uid_cache_free_uids"
              c:identifier="camel_uid_cache_free_uids"
              moved-to="UIDCache.free_uids">
      <doc xml:space="preserve">Frees the array of UIDs.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uids" transfer-ownership="full">
          <doc xml:space="preserve">an array returned from camel_uid_cache_get_new_uids()</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="uid_cache_new"
              c:identifier="camel_uid_cache_new"
              moved-to="UIDCache.new"
              introspectable="0">
      <doc xml:space="preserve">Creates a new UID cache, initialized from @filename. If @filename
doesn't already exist, the UID cache will be empty. Otherwise, if
it does exist but can't be read, the function will return %NULL.</doc>
      <return-value>
        <doc xml:space="preserve">a new UID cache, or %NULL</doc>
        <type name="UIDCache" c:type="CamelUIDCache*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">path to load the cache from</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unlock_dot" c:identifier="camel_unlock_dot">
      <doc xml:space="preserve">Attempt to unlock a .lock lock.

The function does nothing, when dot locking had not been compiled.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">a path to unlock</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="unlock_fcntl" c:identifier="camel_unlock_fcntl">
      <doc xml:space="preserve">Unlock an fcntl lock.

The function does nothing, when fcntl locking had not been compiled.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="unlock_flock" c:identifier="camel_unlock_flock">
      <doc xml:space="preserve">Unlock an flock lock.

The function does nothing, when flock locking had not been compiled.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="unlock_folder" c:identifier="camel_unlock_folder">
      <doc xml:space="preserve">Free a lock on a folder.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">Filename of folder.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">Open descrptor on which locks were placed.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_addrspec_end"
              c:identifier="camel_url_addrspec_end"
              moved-to="URL.addrspec_end">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="inend" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="UrlMatch" c:type="CamelUrlMatch*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_addrspec_start"
              c:identifier="camel_url_addrspec_start"
              moved-to="URL.addrspec_start">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="inend" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="UrlMatch" c:type="CamelUrlMatch*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_decode"
              c:identifier="camel_url_decode"
              moved-to="URL.decode">
      <doc xml:space="preserve">%-decodes the passed-in URL *in place*. The decoded version is
never longer than the encoded version, so there does not need to
be any additional space at the end of the string.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="part" transfer-ownership="none">
          <doc xml:space="preserve">a URL part</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_decode_path"
              c:identifier="camel_url_decode_path"
              moved-to="URL.decode_path">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_encode"
              c:identifier="camel_url_encode"
              moved-to="URL.encode">
      <doc xml:space="preserve">This %-encodes the given URL part and returns the escaped version
in allocated memory, which the caller must free when it is done.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the encoded string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="part" transfer-ownership="none">
          <doc xml:space="preserve">a URL part</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="escape_extra" transfer-ownership="none">
          <doc xml:space="preserve">additional characters beyond " \"%#&lt;&gt;{}|\^[]`"
to escape (or %NULL)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_file_end"
              c:identifier="camel_url_file_end"
              moved-to="URL.file_end">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="inend" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="UrlMatch" c:type="CamelUrlMatch*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_file_start"
              c:identifier="camel_url_file_start"
              moved-to="URL.file_start">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="inend" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="UrlMatch" c:type="CamelUrlMatch*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_scanner_new"
              c:identifier="camel_url_scanner_new"
              moved-to="UrlScanner.new"
              introspectable="0">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Creates a new #CamelUrlScanner</doc>
        <type name="UrlScanner" c:type="CamelUrlScanner*"/>
      </return-value>
    </function>
    <function name="url_web_end"
              c:identifier="camel_url_web_end"
              moved-to="URL.web_end">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="inend" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="UrlMatch" c:type="CamelUrlMatch*"/>
        </parameter>
      </parameters>
    </function>
    <function name="url_web_start"
              c:identifier="camel_url_web_start"
              moved-to="URL.web_start">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="inend" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="match" transfer-ownership="none">
          <type name="UrlMatch" c:type="CamelUrlMatch*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ustrstrcase" c:identifier="camel_ustrstrcase">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="haystack" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="needle" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf7_utf8" c:identifier="camel_utf7_utf8">
      <doc xml:space="preserve">Convert a modified UTF-7 string to UTF-8.  If the UTF-7 string
contains 8 bit characters, they are treated as iso-8859-1.

The IMAP rules [rfc2060] are used in the UTF-7 encoding.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The converted string. Free it with g_free(),
   when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="ptr" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-7 string to convert</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_getc" c:identifier="camel_utf8_getc">
      <doc xml:space="preserve">Get a Unicode character from a UTF-8 stream.  @ptr will be advanced
to the next character position.  Invalid utf8 characters will be
silently skipped. The @ptr should point to a NUL terminated array.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The next Unicode character. The @ptr will be advanced to
   the next character always.</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="ptr"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">a pointer to read the character from</doc>
          <type name="guint8" c:type="const guchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_getc_limit" c:identifier="camel_utf8_getc_limit">
      <doc xml:space="preserve">Get the next UTF-8 gchar at @ptr, and return it, advancing @ptr to
the next character. If @end is reached before a full UTF-8
character can be read, then the invalid Unicode gchar 0xffff is
returned as a sentinel (Unicode 3.1, section 2.7), and @ptr is not
advanced.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The next UTF-8 char, or 0xffff.</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="ptr"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">a pointer to read the character from</doc>
          <type name="guint8" c:type="const guchar**"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">upper limit for the read, must not be %NULL</doc>
          <type name="guint8" c:type="const guchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_make_valid"
              c:identifier="camel_utf8_make_valid"
              version="2.26">
      <doc xml:space="preserve">Ensures the returned text will be valid UTF-8 string, with incorrect letters
changed to question marks.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Valid UTF-8 string, with replaced incorrect letters.
   Free it with g_free(), when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="text" transfer-ownership="none">
          <doc xml:space="preserve">a text to make valid</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_putc" c:identifier="camel_utf8_putc">
      <doc xml:space="preserve">Output a 32 bit unicode character as UTF-8 octets.  At most 4 octets will
be written to @ptr. The @ptr will be advanced to the next character position.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ptr"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">pointer to write the character to</doc>
          <type name="guint8" c:type="guchar**"/>
        </parameter>
        <parameter name="c" transfer-ownership="none">
          <doc xml:space="preserve">a Unicode character to write</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_ucs2" c:identifier="camel_utf8_ucs2">
      <doc xml:space="preserve">Convert a UTF-8 string into a ucs2 one. The ucs string will be in
network byte order, and terminated with a 16-bit %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The converted string. Free it with g_free(),
   when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="ptr" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 string to convert</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utf8_utf7" c:identifier="camel_utf8_utf7">
      <doc xml:space="preserve">Convert a UTF-8 string to a modified UTF-7 format.

The IMAP rules [rfc2060] are used in the UTF-7 encoding.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The converted string. Free it with g_free(),
   when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="ptr" transfer-ownership="none">
          <doc xml:space="preserve">a UTF-8 string to convert</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_bdata_get_number"
              c:identifier="camel_util_bdata_get_number"
              version="3.24">
      <doc xml:space="preserve">Reads a numeric data from the @bdata_ptr and moves the @bdata_ptr
after that number. If the number cannot be read, then the @default_value
is returned instead and the @bdata_ptr is left unchanged. The number
might be previously stored with the camel_util_bdata_put_number().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The read number, or the @default_value, if the @bdata_ptr doesn't
   point to a number.</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="bdata_ptr" transfer-ownership="none">
          <doc xml:space="preserve">a backend specific data (bdata) pointer</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">a value to return, when no data can be read</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_bdata_get_string"
              c:identifier="camel_util_bdata_get_string"
              version="3.24">
      <doc xml:space="preserve">Reads a string data from the @bdata_ptr and moves the @bdata_ptr
after that string. If the string cannot be read, then the @default_value
is returned instead and the @bdata_ptr is left unchanged. The string
might be previously stored with the camel_util_bdata_put_string().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Newly allocated string, which was read, or
   dupped the @default_value, if the @bdata_ptr doesn't point to a string.
   Free returned pointer with g_free() when done with it.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="bdata_ptr" transfer-ownership="none">
          <doc xml:space="preserve">a backend specific data (bdata) pointer</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">a value to return, when no data can be read</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_bdata_put_number"
              c:identifier="camel_util_bdata_put_number"
              version="3.24">
      <doc xml:space="preserve">Puts the number @value at the end of the @bdata_str. In case the @bdata_str
is not empty a space is added before the numeric @value. The stored value
can be read back with the camel_util_bdata_get_number().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bdata_str" transfer-ownership="none">
          <doc xml:space="preserve">a #GString to store a backend specific data (bdata)</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a value to store</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_bdata_put_string"
              c:identifier="camel_util_bdata_put_string"
              version="3.24">
      <doc xml:space="preserve">Puts the string @value at the end of the @bdata_str. In case the @bdata_str
is not empty a space is added before the string @value. The stored value
can be read back with the camel_util_bdata_get_string().

The strings are encoded as "length-value", quotes for clarity only.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bdata_str" transfer-ownership="none">
          <doc xml:space="preserve">a #GString to store a backend specific data (bdata)</doc>
          <type name="GLib.String" c:type="GString*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a value to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uudecode_step" c:identifier="camel_uudecode_step">
      <doc xml:space="preserve">Uudecodes a chunk of data. Performs a 'decode step' on a chunk of
uuencoded data. Assumes the "begin mode filename" line has
been stripped off.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes decoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input stream</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="inlen" transfer-ownership="none">
          <doc xml:space="preserve">max length of data to decode</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output stream</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">holds the number of bits that are stored in @save</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">leftover bits that have not yet been decoded</doc>
          <array length="3" zero-terminated="0" c:type="guint32*">
            <type name="guint32" c:type="guint32"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="uuencode_close" c:identifier="camel_uuencode_close">
      <doc xml:space="preserve">Uuencodes a chunk of data. Call this when finished encoding data
with camel_uuencode_step() to flush off the last little bit.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes encoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input stream</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">input stream length</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output stream</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="uubuf"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">temporary buffer of 60 bytes</doc>
          <array zero-terminated="0" c:type="guchar*" fixed-size="60">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">holds the number of bits that are stored in @save</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">leftover bits that have not yet been encoded</doc>
          <array length="4" zero-terminated="0" c:type="guint32*">
            <type name="guint32" c:type="guint32"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="uuencode_step" c:identifier="camel_uuencode_step">
      <doc xml:space="preserve">Uuencodes a chunk of data. Performs an 'encode step', only encodes
blocks of 45 characters to the output at a time, saves left-over
state in @uubuf, @state and @save (initialize to 0 on first
invocation).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes encoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input stream</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">input stream length</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output stream</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="uubuf"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">temporary buffer of 60 bytes</doc>
          <array zero-terminated="0" c:type="guchar*" fixed-size="60">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">holds the number of bits that are stored in @save</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="save"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">leftover bits that have not yet been encoded</doc>
          <array length="4" zero-terminated="0" c:type="guint32*">
            <type name="guint32" c:type="guint32"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="write" c:identifier="camel_write" throws="1">
      <doc xml:space="preserve">Cancellable libc write() replacement.

Code that intends to be portable to Win32 should call this function
only on file descriptors returned from open(), not on sockets.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of bytes written or -1 on fail. On failure, errno will
be set appropriately.</doc>
        <type name="gssize" c:type="gssize"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">buffer to write</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">number of bytes of @buf to write</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">optional #GCancellable object, or %NULL</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="ydecode_step" c:identifier="camel_ydecode_step">
      <doc xml:space="preserve">Performs a 'decode step' on a chunk of yEncoded data of length
@inlen pointed to by @in and writes to @out. Assumes the =ybegin
and =ypart lines have already been stripped off.

To get the crc32 value of the part, use #CAMEL_MIME_YENCODE_CRC_FINAL
(@pcrc). If there are more parts, you should reuse @crc without
re-initializing. Once all parts have been decoded, you may get the
combined crc32 value of all the parts using #CAMEL_MIME_YENCODE_CRC_FINAL
(@crc).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes decoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input buffer</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="inlen" transfer-ownership="none">
          <doc xml:space="preserve">input buffer length</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output buffer</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">ydecode state</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="pcrc"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">part crc state</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
        <parameter name="crc"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">crc state</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
      </parameters>
    </function>
    <function name="yencode_close" c:identifier="camel_yencode_close">
      <doc xml:space="preserve">Call this function when finished encoding data with
camel_yencode_step() to flush off the remaining state.

#CAMEL_MIME_YENCODE_CRC_FINAL (@pcrc) will give you the crc32 of the
encoded "part". If there are more "parts" to encode, you should
re-use @crc when encoding the next "parts" and then use
#CAMEL_MIME_YENCODE_CRC_FINAL (@crc) to get the combined crc32 value of
all the parts.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes encoded.</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input buffer</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="inlen" transfer-ownership="none">
          <doc xml:space="preserve">input buffer length</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output buffer</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">yencode state</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="pcrc"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">part crc state</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
        <parameter name="crc"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">crc state</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
      </parameters>
    </function>
    <function name="yencode_step" c:identifier="camel_yencode_step">
      <doc xml:space="preserve">Performs an yEncode 'encode step' on a chunk of raw data of length
@inlen pointed to by @in and writes to @out.

@state should be initialized to #CAMEL_MIME_YENCODE_STATE_INIT before
beginning making the first call to this function. Subsequent calls
should reuse @state.

Along the same lines, @pcrc and @crc should be initialized to
#CAMEL_MIME_YENCODE_CRC_INIT before using.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of bytes encoded</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="in" transfer-ownership="none">
          <doc xml:space="preserve">input buffer</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="inlen" transfer-ownership="none">
          <doc xml:space="preserve">input buffer length</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="out"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">output buffer</doc>
          <array zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="state"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">yencode state</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="pcrc"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">part crc state</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
        <parameter name="crc"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">crc state</doc>
          <type name="guint32" c:type="guint32*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
