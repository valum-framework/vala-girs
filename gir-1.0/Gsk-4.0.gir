<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gdk" version="4.0"/>
  <include name="Graphene" version="1.0"/>
  <include name="cairo" version="1.0"/>
  <package name="gsk-4.0"/>
  <c:include name="gsk/gsk.h"/>
  <namespace name="Gsk"
             version="4.0"
             shared-library="libgtk-4.so.0"
             c:identifier-prefixes="Gsk"
             c:symbol-prefixes="gsk">
    <enumeration name="BlendMode" version="3.90" c:type="GskBlendMode">
      <doc xml:space="preserve">The blend modes available for render nodes.

The implementation of each blend mode is deferred to the
rendering pipeline.</doc>
      <member name="default" value="0" c:identifier="GSK_BLEND_MODE_DEFAULT">
        <doc xml:space="preserve">The default blend mode, which specifies no blending</doc>
      </member>
      <member name="multiply" value="1" c:identifier="GSK_BLEND_MODE_MULTIPLY">
        <doc xml:space="preserve">The source color is multiplied by the destination
  and replaces the destination</doc>
      </member>
      <member name="screen" value="2" c:identifier="GSK_BLEND_MODE_SCREEN">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="overlay" value="3" c:identifier="GSK_BLEND_MODE_OVERLAY">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="darken" value="4" c:identifier="GSK_BLEND_MODE_DARKEN">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="lighten" value="5" c:identifier="GSK_BLEND_MODE_LIGHTEN">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="color_dodge"
              value="6"
              c:identifier="GSK_BLEND_MODE_COLOR_DODGE">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="color_burn"
              value="7"
              c:identifier="GSK_BLEND_MODE_COLOR_BURN">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="hard_light"
              value="8"
              c:identifier="GSK_BLEND_MODE_HARD_LIGHT">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="soft_light"
              value="9"
              c:identifier="GSK_BLEND_MODE_SOFT_LIGHT">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="difference"
              value="10"
              c:identifier="GSK_BLEND_MODE_DIFFERENCE">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="exclusion"
              value="11"
              c:identifier="GSK_BLEND_MODE_EXCLUSION">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="color" value="12" c:identifier="GSK_BLEND_MODE_COLOR">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="hue" value="13" c:identifier="GSK_BLEND_MODE_HUE">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="saturation"
              value="14"
              c:identifier="GSK_BLEND_MODE_SATURATION">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="luminosity"
              value="15"
              c:identifier="GSK_BLEND_MODE_LUMINOSITY">
        <doc xml:space="preserve">...</doc>
      </member>
    </enumeration>
    <record name="ColorStop" c:type="GskColorStop">
      <field name="offset" writable="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="color" writable="1">
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
    </record>
    <enumeration name="Corner" c:type="GskCorner">
      <doc xml:space="preserve">The corner indices used by #GskRoundedRect.</doc>
      <member name="top_left" value="0" c:identifier="GSK_CORNER_TOP_LEFT">
        <doc xml:space="preserve">The top left corner</doc>
      </member>
      <member name="top_right" value="1" c:identifier="GSK_CORNER_TOP_RIGHT">
        <doc xml:space="preserve">The top right corner</doc>
      </member>
      <member name="bottom_right"
              value="2"
              c:identifier="GSK_CORNER_BOTTOM_RIGHT">
        <doc xml:space="preserve">The bottom right corner</doc>
      </member>
      <member name="bottom_left"
              value="3"
              c:identifier="GSK_CORNER_BOTTOM_LEFT">
        <doc xml:space="preserve">The bottom left corner</doc>
      </member>
    </enumeration>
    <record name="RenderNode"
            c:type="GskRenderNode"
            version="3.90"
            glib:type-name="GskRenderNode"
            glib:get-type="gsk_render_node_get_type"
            c:symbol-prefix="render_node">
      <doc xml:space="preserve">The `GskRenderNode` structure contains only private data.</doc>
      <method name="draw" c:identifier="gsk_render_node_draw">
        <doc xml:space="preserve">Draw the contents of @node to the given cairo context.

Typically, you'll use this function to implement fallback rendering
of #GskRenderNodes on an intermediate Cairo context, instead of using
the drawing context associated to a #GdkWindow's rendering buffer.

For advanced nodes that cannot be supported using Cairo, in particular
for nodes doing 3D operations, this function may fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">cairo context to draw to</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounds"
              c:identifier="gsk_render_node_get_bounds"
              version="3.90">
        <doc xml:space="preserve">Retrieves the boundaries of the @node. The node will not draw outside
of its boundaries.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="bounds"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for the boundaries</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="gsk_render_node_get_name"
              version="3.90">
        <doc xml:space="preserve">Retrieves the name previously set via gsk_render_node_set_name().
If no name has been set, %NULL is returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The name previously set via
    gsk_render_node_set_name() or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_node_type"
              c:identifier="gsk_render_node_get_node_type"
              version="3.90">
        <doc xml:space="preserve">Returns the type of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the #GskRenderNode</doc>
          <type name="RenderNodeType" c:type="GskRenderNodeType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_render_node_ref" version="3.90">
        <doc xml:space="preserve">Acquires a reference on the given #GskRenderNode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GskRenderNode with an additional reference</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="gsk_render_node_serialize">
        <doc xml:space="preserve">Serializes the @node for later deserialization via
gsk_render_node_deserialize(). No guarantees are made about the format
used other than that the same version of GTK+ will be able to deserialize
the result of a call to gsk_render_node_serialize() and
gsk_render_node_deserialize() will correctly reject files it cannot open
that were created with previous versions of GTK+.

The intended use of this functions is testing, benchmarking and debugging.
The format is not meant as a permanent storage format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes representing the node.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_name"
              c:identifier="gsk_render_node_set_name"
              version="3.90">
        <doc xml:space="preserve">Sets the name of the node.

A name is generally useful for debugging purposes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a name for the node</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scaling_filters"
              c:identifier="gsk_render_node_set_scaling_filters">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <type name="ScalingFilter" c:type="GskScalingFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <type name="ScalingFilter" c:type="GskScalingFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_render_node_unref" version="3.90">
        <doc xml:space="preserve">Releases a reference on the given #GskRenderNode.

If the reference was the last, the resources associated to the @node are
freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_to_file"
              c:identifier="gsk_render_node_write_to_file"
              throws="1">
        <doc xml:space="preserve">This function is equivalent to calling gsk_render_node_serialize()
followed by g_file_set_contents(). See those two functions for details
on the arguments.

It is mostly intended for use inside a debugger to quickly dump a render
node to a file for later inspection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if saving was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the file to save it to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <function name="deserialize"
                c:identifier="gsk_render_node_deserialize"
                throws="1">
        <doc xml:space="preserve">Loads data previously created via gsk_render_node_serialize(). For a
discussion of the supported format, see that function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GskRenderNode or %NULL on
    error.</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">the bytes containing the data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="RenderNodeType"
                 version="3.90"
                 c:type="GskRenderNodeType">
      <doc xml:space="preserve">The type of a node determines what the node is rendering.</doc>
      <member name="not_a_render_node"
              value="0"
              c:identifier="GSK_NOT_A_RENDER_NODE">
        <doc xml:space="preserve">Error type. No node will ever have this type.</doc>
      </member>
      <member name="container_node"
              value="1"
              c:identifier="GSK_CONTAINER_NODE">
        <doc xml:space="preserve">A node containing a stack of children</doc>
      </member>
      <member name="cairo_node" value="2" c:identifier="GSK_CAIRO_NODE">
        <doc xml:space="preserve">A node drawing a #cairo_surface_t</doc>
      </member>
      <member name="color_node" value="3" c:identifier="GSK_COLOR_NODE">
        <doc xml:space="preserve">A node drawing a single color rectangle</doc>
      </member>
      <member name="linear_gradient_node"
              value="4"
              c:identifier="GSK_LINEAR_GRADIENT_NODE">
        <doc xml:space="preserve">A node drawing a linear gradient</doc>
      </member>
      <member name="repeating_linear_gradient_node"
              value="5"
              c:identifier="GSK_REPEATING_LINEAR_GRADIENT_NODE">
        <doc xml:space="preserve">A node drawing a repeating
    linear gradient</doc>
      </member>
      <member name="border_node" value="6" c:identifier="GSK_BORDER_NODE">
        <doc xml:space="preserve">A node stroking a border around an area</doc>
      </member>
      <member name="texture_node" value="7" c:identifier="GSK_TEXTURE_NODE">
        <doc xml:space="preserve">A node drawing a #GskTexture</doc>
      </member>
      <member name="inset_shadow_node"
              value="8"
              c:identifier="GSK_INSET_SHADOW_NODE">
        <doc xml:space="preserve">A node drawing an inset shadow</doc>
      </member>
      <member name="outset_shadow_node"
              value="9"
              c:identifier="GSK_OUTSET_SHADOW_NODE">
        <doc xml:space="preserve">A node drawing an outset shadow</doc>
      </member>
      <member name="transform_node"
              value="10"
              c:identifier="GSK_TRANSFORM_NODE">
        <doc xml:space="preserve">A node that renders its child after applying a
    matrix transform</doc>
      </member>
      <member name="opacity_node" value="11" c:identifier="GSK_OPACITY_NODE">
        <doc xml:space="preserve">A node that changes the opacity of its child</doc>
      </member>
      <member name="color_matrix_node"
              value="12"
              c:identifier="GSK_COLOR_MATRIX_NODE">
        <doc xml:space="preserve">A node that applies a color matrix to every pixel</doc>
      </member>
      <member name="repeat_node" value="13" c:identifier="GSK_REPEAT_NODE">
        <doc xml:space="preserve">A node that repeats the child's contents</doc>
      </member>
      <member name="clip_node" value="14" c:identifier="GSK_CLIP_NODE">
        <doc xml:space="preserve">A node that clips its child to a rectangular area</doc>
      </member>
      <member name="rounded_clip_node"
              value="15"
              c:identifier="GSK_ROUNDED_CLIP_NODE">
        <doc xml:space="preserve">A node that clips its child to a rounded rectangle</doc>
      </member>
      <member name="shadow_node" value="16" c:identifier="GSK_SHADOW_NODE">
        <doc xml:space="preserve">A node that draws a shadow below its child</doc>
      </member>
      <member name="blend_node" value="17" c:identifier="GSK_BLEND_NODE">
        <doc xml:space="preserve">A node the blends two children together</doc>
      </member>
      <member name="cross_fade_node"
              value="18"
              c:identifier="GSK_CROSS_FADE_NODE">
        <doc xml:space="preserve">A node the cross-fades between two children</doc>
      </member>
    </enumeration>
    <class name="Renderer"
           c:symbol-prefix="renderer"
           c:type="GskRenderer"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GskRenderer"
           glib:get-type="gsk_renderer_get_type"
           glib:type-struct="RendererClass">
      <constructor name="new_for_window"
                   c:identifier="gsk_renderer_new_for_window"
                   version="3.90">
        <doc xml:space="preserve">Creates an appropriate #GskRenderer instance for the given @window.

The renderer will be realized when it is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GskRenderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
        <parameters>
          <parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GdkWindow</doc>
            <type name="Gdk.Window" c:type="GdkWindow*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="begin_draw_frame"
              c:identifier="gsk_renderer_begin_draw_frame"
              version="3.90">
        <doc xml:space="preserve">Indicates that you are beginning the process of redrawing @region using
@renderer, and provides you with a #GdkDrawingContext to use for this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GdkDrawingContext context that should be used to
draw the contents of the @renderer. This context is owned by GDK.</doc>
          <type name="Gdk.DrawingContext" c:type="GdkDrawingContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve">the #cairo_region_t that you wish to draw</doc>
            <type name="cairo.Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="end_draw_frame" c:identifier="gsk_renderer_end_draw_frame">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <type name="Gdk.DrawingContext" c:type="GdkDrawingContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_display"
              c:identifier="gsk_renderer_get_display"
              version="3.90">
        <doc xml:space="preserve">Retrieves the #GdkDisplay used when creating the #GskRenderer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GdkDisplay</doc>
          <type name="Gdk.Display" c:type="GdkDisplay*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_scale_factor"
              c:identifier="gsk_renderer_get_scale_factor"
              version="3.90">
        <doc xml:space="preserve">Gets the scale factor for the @renderer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the scale factor</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport"
              c:identifier="gsk_renderer_get_viewport"
              version="3.90">
        <doc xml:space="preserve">Retrieves the viewport of the #GskRenderer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="viewport"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for the viewport rectangle</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_window"
              c:identifier="gsk_renderer_get_window"
              version="3.90">
        <doc xml:space="preserve">Retrieves the #GdkWindow set using gsk_renderer_realize(). If the renderer
has not been realized yet, %NULL will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GdkWindow</doc>
          <type name="Gdk.Window" c:type="GdkWindow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="realize"
              c:identifier="gsk_renderer_realize"
              version="3.90"
              throws="1">
        <doc xml:space="preserve">Creates the resources needed by the @renderer to render the scene
graph.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">the #GdkWindow renderer will be used on</doc>
            <type name="Gdk.Window" c:type="GdkWindow*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render" c:identifier="gsk_renderer_render" version="3.90">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
using the given #GdkDrawingContext.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">The drawing context created via gsk_renderer_begin_draw_frame()</doc>
            <type name="Gdk.DrawingContext" c:type="GdkDrawingContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render_texture"
              c:identifier="gsk_renderer_render_texture"
              version="3.90">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
to a #GskTexture.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress, and will make the tree immutable.

If you want to apply any transformations to @root, you should put it into a
transform node and pass that node instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GskTexture with the rendered contents of @root.</doc>
          <type name="Texture" c:type="GskTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a realized #GdkRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="viewport"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the section to draw or %NULL to use @root's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scale_factor"
              c:identifier="gsk_renderer_set_scale_factor"
              version="3.90">
        <doc xml:space="preserve">Sets the scale factor for the renderer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="scale_factor" transfer-ownership="none">
            <doc xml:space="preserve">the new scale factor</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_viewport"
              c:identifier="gsk_renderer_set_viewport"
              version="3.90">
        <doc xml:space="preserve">Sets the visible rectangle to be used as the viewport for
the rendering.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="viewport"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the viewport rectangle used by the @renderer</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unrealize"
              c:identifier="gsk_renderer_unrealize"
              version="3.90">
        <doc xml:space="preserve">Releases all the resources created by gsk_renderer_realize().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="display"
                version="3.90"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GdkDisplay used by the #GskRenderer.</doc>
        <type name="Gdk.Display"/>
      </property>
      <property name="drawing-context"
                version="3.90"
                transfer-ownership="none">
        <doc xml:space="preserve">The drawing context used when rendering.</doc>
        <type name="Gdk.DrawingContext"/>
      </property>
      <property name="scale-factor"
                version="3.90"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The scale factor used when rendering.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="viewport"
                version="3.90"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The visible area used by the #GskRenderer to render its contents.</doc>
        <type name="Graphene.Rect"/>
      </property>
      <property name="window"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Gdk.Window"/>
      </property>
    </class>
    <record name="RendererClass"
            c:type="GskRendererClass"
            disguised="1"
            glib:is-gtype-struct-for="Renderer">
    </record>
    <record name="RoundedRect" c:type="GskRoundedRect" version="3.90">
      <doc xml:space="preserve">A rectanglular region with rounded corners.

Application code should normalize rectangles using gsk_rounded_rect_normalize();
this function will ensure that the bounds of the rectanlge are normalized
and ensure that the corner values are positive and the corners do not overlap.
All functions taking a #GskRoundedRect as an argument will internally operate on
a normalized copy; all functions returning a #GskRoundedRect will always return
a normalized one.</doc>
      <field name="bounds" writable="1">
        <doc xml:space="preserve">the bounds of the rectangle</doc>
        <type name="Graphene.Rect" c:type="graphene_rect_t"/>
      </field>
      <field name="corner" writable="1">
        <doc xml:space="preserve">the size of the 4 rounded corners</doc>
        <array zero-terminated="0" c:type="graphene_size_t" fixed-size="4">
          <type name="Graphene.Size" c:type="graphene_size_t"/>
        </array>
      </field>
      <method name="contains_point"
              c:identifier="gsk_rounded_rect_contains_point">
        <doc xml:space="preserve">Checks if the given @point is inside the rounded rectangle. This function
returns %FALSE if the point is in the rounded corner areas.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @point is inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to check</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_rect"
              c:identifier="gsk_rounded_rect_contains_rect">
        <doc xml:space="preserve">Checks if the given @rect is contained inside the rounded rectangle.
This function returns %FALSE if @rect extends into one of the rounded
corner areas.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect is fully contained inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gsk_rounded_rect_init" version="3.90">
        <doc xml:space="preserve">Initializes the given #GskRoundedRect with the given values.

This function will implicitly normalize the #GskRoundedRect
before returning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to initialize</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t describing the bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="top_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="top_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_copy"
              c:identifier="gsk_rounded_rect_init_copy"
              version="3.90">
        <doc xml:space="preserve">Initializes @self using the given @src rectangle.

This function will not normalize the #GskRoundedRect, so
make sure the source is normalized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_rect"
              c:identifier="gsk_rounded_rect_init_from_rect">
        <doc xml:space="preserve">Initializes @self to the given @bounds and sets the radius of all
four corners to @radius.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the border radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_rect"
              c:identifier="gsk_rounded_rect_intersects_rect">
        <doc xml:space="preserve">Checks if part of the given @rect is contained inside the rounded rectangle.
This function returns %FALSE if @rect only extends into one of the rounded
corner areas but not into the rounded rectangle itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect intersects with the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_rectilinear"
              c:identifier="gsk_rounded_rect_is_rectilinear">
        <doc xml:space="preserve">Checks if all corners of @self are right angles and the
rectangle covers all of its bounds.

This information can be used to decide if gsk_clip_node_new()
or gsk_rounded_clip_node_new() should be called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the rectangle is rectilinear</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GskRoundedRect to check</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="normalize"
              c:identifier="gsk_rounded_rect_normalize"
              version="3.90">
        <doc xml:space="preserve">Normalizes the passed rectangle.

this function will ensure that the bounds of the rectanlge are normalized
and ensure that the corner values are positive and the corners do not overlap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offset"
              c:identifier="gsk_rounded_rect_offset"
              version="3.90">
        <doc xml:space="preserve">Offsets the bound's origin by @dx and @dy.

The size and corners of the rectangle are unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">the vertical offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink" c:identifier="gsk_rounded_rect_shrink">
        <doc xml:space="preserve">Shrinks (or grows) the given rectangle by moving the 4 sides
according to the offsets given. The corner radii will be changed
in a way that tries to keep the center of the corner circle intact.
This emulates CSS behavior.

This function also works for growing rectangles if you pass
negative values for the @top, @right, @bottom or @left.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the resized #GskRoundedRect</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to shrink or grow</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the top side downwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the right side to the left</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the bottom side upwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the left side to the right</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="ScalingFilter" version="3.90" c:type="GskScalingFilter">
      <doc xml:space="preserve">The filters used when scaling texture data.

The actual implementation of each filter is deferred to the
rendering pipeline.</doc>
      <member name="linear" value="0" c:identifier="GSK_SCALING_FILTER_LINEAR">
        <doc xml:space="preserve">linear interpolation filter</doc>
      </member>
      <member name="nearest"
              value="1"
              c:identifier="GSK_SCALING_FILTER_NEAREST">
        <doc xml:space="preserve">nearest neighbor interpolation filter</doc>
      </member>
      <member name="trilinear"
              value="2"
              c:identifier="GSK_SCALING_FILTER_TRILINEAR">
        <doc xml:space="preserve">linear interpolation along each axis,
  plus mipmap generation, with linear interpolation along the mipmap
  levels</doc>
      </member>
    </enumeration>
    <enumeration name="SerializationError"
                 c:type="GskSerializationError"
                 glib:error-domain="gsk-serialization-error-quark">
      <doc xml:space="preserve">Errors that can happen during (de)serialization.</doc>
      <member name="unsupported_format"
              value="0"
              c:identifier="GSK_SERIALIZATION_UNSUPPORTED_FORMAT">
        <doc xml:space="preserve">The format can not be
    identified</doc>
      </member>
      <member name="unsupported_version"
              value="1"
              c:identifier="GSK_SERIALIZATION_UNSUPPORTED_VERSION">
        <doc xml:space="preserve">The version of the data
    is not understood</doc>
      </member>
      <member name="invalid_data"
              value="2"
              c:identifier="GSK_SERIALIZATION_INVALID_DATA">
        <doc xml:space="preserve">The given data may not exist in
    a proper serialization</doc>
      </member>
    </enumeration>
    <record name="Shadow" c:type="GskShadow">
      <field name="color" writable="1">
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
      <field name="dx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="dy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="radius" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <function name="node_new"
                c:identifier="gsk_shadow_node_new"
                version="3.90">
        <doc xml:space="preserve">Creates a #GskRenderNode that will draw a @child with the given
@shadows below it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="shadows" transfer-ownership="none">
            <doc xml:space="preserve">The shadows to apply</doc>
            <array length="2" zero-terminated="0" c:type="GskShadow*">
              <type name="Shadow" c:type="GskShadow"/>
            </array>
          </parameter>
          <parameter name="n_shadows" transfer-ownership="none">
            <doc xml:space="preserve">number of entries in the @shadows array</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="Texture"
           c:symbol-prefix="texture"
           c:type="GskTexture"
           version="3.90"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GskTexture"
           glib:get-type="gsk_texture_get_type"
           glib:type-struct="TextureClass">
      <doc xml:space="preserve">The `GskTexture` structure contains only private data.</doc>
      <constructor name="new_for_data" c:identifier="gsk_texture_new_for_data">
        <return-value transfer-ownership="full">
          <type name="Texture" c:type="GskTexture*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="stride" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_pixbuf"
                   c:identifier="gsk_texture_new_for_pixbuf">
        <return-value transfer-ownership="full">
          <type name="Texture" c:type="GskTexture*"/>
        </return-value>
        <parameters>
          <parameter name="pixbuf" transfer-ownership="none">
            <type name="GdkPixbuf.Pixbuf" c:type="GdkPixbuf*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="download" c:identifier="gsk_texture_download">
        <doc xml:space="preserve">Downloads the @texture into local memory. This may be
an expensive operation, as the actual texture data may
reside on a GPU or on a remote display server.

The data format of the downloaded data is equivalent to
%CAIRO_FORMAT_ARGB32, so every downloaded pixel requires
4 bytes of memory.

Downloading a texture into a Cairo image surface:
|[&lt;!-- language="C" --&gt;
surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,
                                      gsk_texture_get_width (texture),
                                      gsk_texture_get_height (texture));
gsk_texture_download (texture,
                      cairo_image_surface_get_data (surface),
                      cairo_image_surface_get_stride (surface));
cairo_surface_mark_dirty (surface);
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTexture</doc>
            <type name="Texture" c:type="GskTexture*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">pointer to enough memory to be filled with the
    downloaded data of @texture</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="stride" transfer-ownership="none">
            <doc xml:space="preserve">rowstride in bytes</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="gsk_texture_get_height"
              version="3.90">
        <doc xml:space="preserve">Returns the height of the @texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the height of the #GskTexture</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTexture</doc>
            <type name="Texture" c:type="GskTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="gsk_texture_get_width"
              version="3.90">
        <doc xml:space="preserve">Returns the width of @texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the width of the #GskTexture</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #GskTexture</doc>
            <type name="Texture" c:type="GskTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="node_new"
              c:identifier="gsk_texture_node_new"
              version="3.90">
        <doc xml:space="preserve">Creates a #GskRenderNode that will render the given
@texture into the area given by @bounds.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">the #GskTexture</doc>
            <type name="Texture" c:type="GskTexture*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render the texture into</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <property name="height"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="width"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
    </class>
    <record name="TextureClass"
            c:type="GskTextureClass"
            disguised="1"
            glib:is-gtype-struct-for="Texture">
    </record>
    <function name="blend_node_get_blend_mode"
              c:identifier="gsk_blend_node_get_blend_mode">
      <return-value transfer-ownership="none">
        <type name="BlendMode" c:type="GskBlendMode"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="blend_node_new"
              c:identifier="gsk_blend_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will use @blend_mode to blend the @top
node onto the @bottom node.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:space="preserve">The bottom node to be drawn</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">The node to be blended onto the @bottom node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="blend_mode" transfer-ownership="none">
          <doc xml:space="preserve">The blend mode to use</doc>
          <type name="BlendMode" c:type="GskBlendMode"/>
        </parameter>
      </parameters>
    </function>
    <function name="border_node_new"
              c:identifier="gsk_border_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will stroke a border rectangle inside the
given @outline. The 4 sides of the border can have different widths and
colors.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="outline" transfer-ownership="none">
          <doc xml:space="preserve">a #GskRoundedRect describing the outline of the border</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
        <parameter name="border_width" transfer-ownership="none">
          <doc xml:space="preserve">the stroke width of the border on the top, right, bottom and
    left side respectively.</doc>
          <type name="gfloat" c:type="const float"/>
        </parameter>
        <parameter name="border_color" transfer-ownership="none">
          <doc xml:space="preserve">the color used on the top, right, bottom and left side.</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA"/>
        </parameter>
      </parameters>
    </function>
    <function name="cairo_node_get_draw_context"
              c:identifier="gsk_cairo_node_get_draw_context"
              version="3.90">
      <doc xml:space="preserve">Creates a Cairo context for drawing using the surface associated
to the render node.
If no surface exists yet, a surface will be created optimized for
rendering to @renderer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a Cairo context used for drawing; use
  cairo_destroy() when done drawing</doc>
        <type name="cairo.Context" c:type="cairo_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a cairo #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="renderer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Renderer to optimize for or %NULL for any</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cairo_node_new"
              c:identifier="gsk_cairo_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render a cairo surface
into the area given by @bounds. You can draw to the cairo
surface using gsk_cairo_node_get_draw_context()</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render to</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_node_get_child"
              c:identifier="gsk_clip_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting clipped</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a clip @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_node_new"
              c:identifier="gsk_clip_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="clip" transfer-ownership="none">
          <doc xml:space="preserve">The clip to apply</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_matrix_node_new"
              c:identifier="gsk_color_matrix_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@color_matrix.

In particular, the node will transform the operation
  pixel = color_matrix * pixel + color_offset
for every pixel.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="color_matrix" transfer-ownership="none">
          <doc xml:space="preserve">The matrix to apply</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </parameter>
        <parameter name="color_offset" transfer-ownership="none">
          <doc xml:space="preserve">Values to add to the color</doc>
          <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_node_new"
              c:identifier="gsk_color_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render the color specified by @rgba into
the area given by @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="rgba" transfer-ownership="none">
          <doc xml:space="preserve">a #GdkRGBA specifying a color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </parameter>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render the color into</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="container_node_get_child"
              c:identifier="gsk_container_node_get_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="idx" transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="container_node_get_n_children"
              c:identifier="gsk_container_node_get_n_children"
              version="3.90">
      <doc xml:space="preserve">Retrieves the number of direct children of @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of children of the #GskRenderNode</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a container #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="container_node_new"
              c:identifier="gsk_container_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a new #GskRenderNode instance for holding the given @children.
The new node will acquire a reference to each of the children.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="children" transfer-ownership="none">
          <doc xml:space="preserve">The children of the node</doc>
          <array length="1" zero-terminated="0" c:type="GskRenderNode**">
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </array>
        </parameter>
        <parameter name="n_children" transfer-ownership="none">
          <doc xml:space="preserve">Number of children in the @children array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cross_fade_node_new"
              c:identifier="gsk_cross_fade_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will do a cross-fade between @start and @end.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">The start node to be drawn</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">The node to be cross_fadeed onto the @start node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="progress" transfer-ownership="none">
          <doc xml:space="preserve">How far the fade has progressed from start to end. The value will
    be clamped to the range [0 ... 1]</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_new"
              c:identifier="gsk_inset_shadow_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render an inset shadow
into the box given by @outline.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="outline" transfer-ownership="none">
          <doc xml:space="preserve">outline of the region containing the shadow</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">color of the shadow</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </parameter>
        <parameter name="dx" transfer-ownership="none">
          <doc xml:space="preserve">horizontal offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="dy" transfer-ownership="none">
          <doc xml:space="preserve">vertical offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="spread" transfer-ownership="none">
          <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="blur_radius" transfer-ownership="none">
          <doc xml:space="preserve">how much blur to apply to the shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="linear_gradient_node_new"
              c:identifier="gsk_linear_gradient_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will create a linear gradient from the given
points and color stops, and render that into the area given by @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="color_stops" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient</doc>
          <type name="ColorStop" c:type="const GskColorStop*"/>
        </parameter>
        <parameter name="n_color_stops" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in @color_stops</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="opacity_node_get_child"
              c:identifier="gsk_opacity_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting opacityed by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting opacityed</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a opacity @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="opacity_node_new"
              c:identifier="gsk_opacity_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@opacity.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="opacity" transfer-ownership="none">
          <doc xml:space="preserve">The opacity to apply</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_new"
              c:identifier="gsk_outset_shadow_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render an outset shadow
around the box given by @outline.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="outline" transfer-ownership="none">
          <doc xml:space="preserve">outline of the region surrounded by shadow</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">color of the shadow</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </parameter>
        <parameter name="dx" transfer-ownership="none">
          <doc xml:space="preserve">horizontal offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="dy" transfer-ownership="none">
          <doc xml:space="preserve">vertical offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="spread" transfer-ownership="none">
          <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="blur_radius" transfer-ownership="none">
          <doc xml:space="preserve">how much blur to apply to the shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="render_node_deserialize"
              c:identifier="gsk_render_node_deserialize"
              moved-to="RenderNode.deserialize"
              throws="1">
      <doc xml:space="preserve">Loads data previously created via gsk_render_node_serialize(). For a
discussion of the supported format, see that function.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new #GskRenderNode or %NULL on
    error.</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:space="preserve">the bytes containing the data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </parameter>
      </parameters>
    </function>
    <function name="repeat_node_new"
              c:identifier="gsk_repeat_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will repeat the drawing of @child across
the given @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">The bounds of the area to be painted</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The child to repeat</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="child_bounds"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The area of the child to repeat or %NULL to
    use the child's bounds</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="repeating_linear_gradient_node_new"
              c:identifier="gsk_repeating_linear_gradient_node_new">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="color_stops" transfer-ownership="none">
          <type name="ColorStop" c:type="const GskColorStop*"/>
        </parameter>
        <parameter name="n_color_stops" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="rounded_clip_node_get_child"
              c:identifier="gsk_rounded_clip_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting clipped</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a clip @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rounded_clip_node_new"
              c:identifier="gsk_rounded_clip_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="clip" transfer-ownership="none">
          <doc xml:space="preserve">The clip to apply</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
      </parameters>
    </function>
    <function name="serialization_error_quark"
              c:identifier="gsk_serialization_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="shadow_node_new"
              c:identifier="gsk_shadow_node_new"
              moved-to="Shadow.node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will draw a @child with the given
@shadows below it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="shadows" transfer-ownership="none">
          <doc xml:space="preserve">The shadows to apply</doc>
          <array length="2" zero-terminated="0" c:type="GskShadow*">
            <type name="Shadow" c:type="GskShadow"/>
          </array>
        </parameter>
        <parameter name="n_shadows" transfer-ownership="none">
          <doc xml:space="preserve">number of entries in the @shadows array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform_node_get_child"
              c:identifier="gsk_transform_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting transformed by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting transformed</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a transform @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform_node_new"
              c:identifier="gsk_transform_node_new"
              version="3.90">
      <doc xml:space="preserve">Creates a #GskRenderNode that will transform the given @child
with the given @transform.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to transform</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="transform" transfer-ownership="none">
          <doc xml:space="preserve">The transform to apply</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
